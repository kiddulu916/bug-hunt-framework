"""
Exploit Results Module
backend/tools/exploitation/exploit_results.py

Handles processing, analysis, and reporting of exploitation results.
"""

import json
import logging
import os
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import hashlib
from pathlib import Path
import sqlite3
from collections import defaultdict

logger = logging.getLogger(__name__)

@dataclass
class ExploitEvidence:
    """Represents evidence from an exploitation attempt"""
    evidence_id: str
    exploit_id: str
    evidence_type: str  # screenshot, log, response, payload
    file_path: Optional[str]
    content: Optional[str]
    metadata: Dict[str, Any]
    timestamp: datetime

@dataclass
class VulnerabilityImpact:
    """Represents the impact of a successful exploitation"""
    confidentiality_impact: str  # none, low, medium, high
    integrity_impact: str
    availability_impact: str
    access_level: str  # none, user, admin, system
    data_exposure: List[str]  # types of data exposed
    business_impact: str  # description of business impact

@dataclass
class ExploitSummary:
    """Summary of exploitation results"""
    target_url: str
    vulnerability_type: str
    exploit_attempts: int
    successful_exploits: int
    failed_exploits: int
    highest_severity: str
    impact_assessment: VulnerabilityImpact
    evidence_count: int
    timestamps: Dict[str, datetime]

class ExploitResultProcessor:
    """
    Processes and analyzes exploitation results
    """

    def __init__(self, results_directory: str = "scan_results"):
        self.results_directory = Path(results_directory)
        self.results_directory.mkdir(exist_ok=True)

        # Create subdirectories
        (self.results_directory / "raw").mkdir(exist_ok=True)
        (self.results_directory / "parsed").mkdir(exist_ok=True)
        (self.results_directory / "evidence").mkdir(exist_ok=True)
        (self.results_directory / "reports").mkdir(exist_ok=True)

        self.db_path = self.results_directory / "exploitation_results.db"
        self.init_database()

    def init_database(self):
        """Initialize SQLite database for results storage"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Create tables
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploit_sessions (
                session_id TEXT PRIMARY KEY,
                target_url TEXT NOT NULL,
                vulnerability_type TEXT NOT NULL,
                started_at TIMESTAMP NOT NULL,
                completed_at TIMESTAMP,
                status TEXT NOT NULL,
                total_attempts INTEGER DEFAULT 0,
                successful_attempts INTEGER DEFAULT 0,
                metadata TEXT
            )
        ''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploit_results (
                result_id TEXT PRIMARY KEY,
                session_id TEXT NOT NULL,
                payload TEXT NOT NULL,
                success BOOLEAN NOT NULL,
                response_code INTEGER,
                response_size INTEGER,
                execution_time REAL,
                timestamp TIMESTAMP NOT NULL,
                result_data TEXT,
                FOREIGN KEY (session_id) REFERENCES exploit_sessions (session_id)
            )
        ''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploit_evidence (
                evidence_id TEXT PRIMARY KEY,
                result_id TEXT NOT NULL,
                evidence_type TEXT NOT NULL,
                file_path TEXT,
                content TEXT,
                metadata TEXT,
                timestamp TIMESTAMP NOT NULL,
                FOREIGN KEY (result_id) REFERENCES exploit_results (result_id)
            )
        ''')

        conn.commit()
        conn.close()

    def generate_result_id(self, payload: str, timestamp: datetime) -> str:
        """Generate unique result ID"""
        content = f"{payload}_{timestamp.isoformat()}"
        return hashlib.md5(content.encode()).hexdigest()

    def store_exploit_session(self, session_data: Dict[str, Any]) -> str:
        """Store exploitation session data"""
        session_id = session_data.get('session_id', self.generate_session_id())

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO exploit_sessions
            (session_id, target_url, vulnerability_type, started_at, completed_at,
             status, total_attempts, successful_attempts, metadata)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            session_id,
            session_data.get('target_url'),
            session_data.get('vulnerability_type'),
            session_data.get('started_at'),
            session_data.get('completed_at'),
            session_data.get('status', 'running'),
            session_data.get('total_attempts', 0),
            session_data.get('successful_attempts', 0),
            json.dumps(session_data.get('metadata', {}))
        ))

        conn.commit()
        conn.close()

        return session_id

    def store_exploit_result(self, session_id: str, result_data: Dict[str, Any]) -> str:
        """Store individual exploit result"""
        result_id = self.generate_result_id(
            result_data.get('payload', ''),
            datetime.now()
        )

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO exploit_results
            (result_id, session_id, payload, success, response_code, response_size,
             execution_time, timestamp, result_data)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            result_id,
            session_id,
            result_data.get('payload', ''),
            result_data.get('success', False),
            result_data.get('response_code'),
            result_data.get('response_size'),
            result_data.get('execution_time'),
            result_data.get('timestamp', datetime.now()),
            json.dumps(result_data)
        ))

        conn.commit()
        conn.close()

        return result_id

    def store_evidence(self, result_id: str, evidence: ExploitEvidence):
        """Store exploitation evidence"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO exploit_evidence
            (evidence_id, result_id, evidence_type, file_path, content, metadata, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            evidence.evidence_id,
            result_id,
            evidence.evidence_type,
            evidence.file_path,
            evidence.content,
            json.dumps(evidence.metadata),
            evidence.timestamp
        ))

        conn.commit()
        conn.close()

    def generate_session_id(self) -> str:
        """Generate unique session ID"""
        return hashlib.md5(str(datetime.now()).encode()).hexdigest()

    def analyze_exploitation_session(self, session_id: str) -> ExploitSummary:
        """Analyze results from an exploitation session"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Get session data
        cursor.execute('''
            SELECT target_url, vulnerability_type, started_at, completed_at,
                   total_attempts, successful_attempts
            FROM exploit_sessions WHERE session_id = ?
        ''', (session_id,))

        session_data = cursor.fetchone()
        if not session_data:
            raise ValueError(f"Session {session_id} not found")

        target_url, vuln_type, started_at, completed_at, total_attempts, successful_attempts = session_data

        # Get detailed results
        cursor.execute('''
            SELECT payload, success, response_code, response_size, timestamp, result_data
            FROM exploit_results WHERE session_id = ?
            ORDER BY timestamp
        ''', (session_id,))

        results = cursor.fetchall()

        # Count evidence
        cursor.execute('''
            SELECT COUNT(*) FROM exploit_evidence e
            JOIN exploit_results r ON e.result_id = r.result_id
            WHERE r.session_id = ?
        ''', (session_id,))

        evidence_count = cursor.fetchone()[0]

        conn.close()

        # Analyze impact
        impact = self.assess_vulnerability_impact(vuln_type, results)

        # Determine highest severity
        severity_levels = ['info', 'low', 'medium', 'high', 'critical']
        highest_severity = 'info'

        for result in results:
            if result[1]:  # successful exploit
                result_data = json.loads(result[5])
                result_severity = result_data.get('severity', 'medium')
                if severity_levels.index(result_severity) > severity_levels.index(highest_severity):
                    highest_severity = result_severity

        return ExploitSummary(
            target_url=target_url,
            vulnerability_type=vuln_type,
            exploit_attempts=total_attempts or len(results),
            successful_exploits=successful_attempts or sum(1 for r in results if r[1]),
            failed_exploits=(total_attempts or len(results)) - (successful_attempts or sum(1 for r in results if r[1])),
            highest_severity=highest_severity,
            impact_assessment=impact,
            evidence_count=evidence_count,
            timestamps={
                'started_at': datetime.fromisoformat(started_at) if started_at else None,
                'completed_at': datetime.fromisoformat(completed_at) if completed_at else None
            }
        )

    def assess_vulnerability_impact(self, vuln_type: str, results: List[Tuple]) -> VulnerabilityImpact:
        """Assess the impact of successful exploitation"""

        # Default impact assessments by vulnerability type
        impact_matrix = {
            'sql_injection': {
                'confidentiality_impact': 'high',
                'integrity_impact': 'high',
                'availability_impact': 'medium',
                'access_level': 'user',
                'data_exposure': ['database_contents', 'user_credentials', 'sensitive_data'],
                'business_impact': 'Data breach, unauthorized data access, potential compliance violations'
            },
            'xss': {
                'confidentiality_impact': 'medium',
                'integrity_impact': 'medium',
                'availability_impact': 'low',
                'access_level': 'user',
                'data_exposure': ['session_tokens', 'user_data'],
                'business_impact': 'Session hijacking, defacement, malware distribution'
            },
            'command_injection': {
                'confidentiality_impact': 'high',
                'integrity_impact': 'high',
                'availability_impact': 'high',
                'access_level': 'system',
                'data_exposure': ['system_files', 'application_data', 'credentials'],
                'business_impact': 'Full system compromise, data theft, service disruption'
            },
            'file_upload': {
                'confidentiality_impact': 'high',
                'integrity_impact': 'high',
                'availability_impact': 'medium',
                'access_level': 'admin',
                'data_exposure': ['application_files', 'server_access'],
                'business_impact': 'Code execution, backdoor installation, data manipulation'
            }
        }

        base_impact = impact_matrix.get(vuln_type, {
            'confidentiality_impact': 'medium',
            'integrity_impact': 'medium',
            'availability_impact': 'low',
            'access_level': 'user',
            'data_exposure': ['limited_data'],
            'business_impact': 'Limited security impact'
        })

        # Analyze successful results to adjust impact
        successful_results = [r for r in results if r[1]]  # r[1] is success boolean

        if successful_results:
            # Escalate impact based on number of successful exploits
            if len(successful_results) > 3:
                if base_impact['confidentiality_impact'] == 'medium':
                    base_impact['confidentiality_impact'] = 'high'
                if base_impact['access_level'] == 'user':
                    base_impact['access_level'] = 'admin'

        return VulnerabilityImpact(**base_impact)

    def generate_exploitation_report(self, session_id: str) -> Dict[str, Any]:
        """Generate comprehensive exploitation report"""
        summary = self.analyze_exploitation_session(session_id)

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Get detailed results
        cursor.execute('''
            SELECT r.payload, r.success, r.response_code, r.timestamp, r.result_data,
                   GROUP_CONCAT(e.evidence_type) as evidence_types
            FROM exploit_results r
            LEFT JOIN exploit_evidence e ON r.result_id = e.result_id
            WHERE r.session_id = ?
            GROUP BY r.result_id
            ORDER BY r.timestamp
        ''', (session_id,))

        detailed_results = cursor.fetchall()
        conn.close()

        report = {
            'session_id': session_id,
            'generated_at': datetime.now().isoformat(),
            'summary': asdict(summary),
            'detailed_results': [],
            'recommendations': self.generate_recommendations(summary),
            'risk_assessment': self.calculate_risk_score(summary)
        }

        for result in detailed_results:
            payload, success, response_code, timestamp, result_data, evidence_types = result

            report['detailed_results'].append({
                'payload': payload,
                'success': success,
                'response_code': response_code,
                'timestamp': timestamp,
                'result_data': json.loads(result_data) if result_data else {},
                'evidence_types': evidence_types.split(',') if evidence_types else []
            })

        return report

    def generate_recommendations(self, summary: ExploitSummary) -> List[str]:
        """Generate security recommendations based on exploitation results"""
        recommendations = []

        if summary.successful_exploits > 0:
            vuln_type = summary.vulnerability_type

            if vuln_type == 'sql_injection':
                recommendations.extend([
                    "Implement parameterized queries/prepared statements",
                    "Apply input validation and sanitization",
                    "Use least privilege database accounts",
                    "Enable SQL injection detection in WAF",
                    "Regular security code reviews"
                ])

            elif vuln_type == 'xss':
                recommendations.extend([
                    "Implement output encoding/escaping",
                    "Use Content Security Policy (CSP)",
                    "Validate and sanitize all user inputs",
                    "Use secure development frameworks",
                    "Regular XSS scanning and testing"
                ])

            elif vuln_type == 'command_injection':
                recommendations.extend([
                    "Avoid executing system commands with user input",
                    "Use parameterized command execution",
                    "Implement strict input validation",
                    "Run applications with minimal privileges",
                    "Use application sandboxing"
                ])

            elif vuln_type == 'file_upload':
                recommendations.extend([
                    "Implement file type validation",
                    "Use virus scanning for uploaded files",
                    "Store uploads outside web root",
                    "Limit file upload permissions",
                    "Implement file size restrictions"
                ])

        # General recommendations
        recommendations.extend([
            "Implement regular security assessments",
            "Keep software and dependencies updated",
            "Use Web Application Firewall (WAF)",
            "Implement proper logging and monitoring",
            "Conduct security training for developers"
        ])

        return recommendations

    def calculate_risk_score(self, summary: ExploitSummary) -> Dict[str, Any]:
        """Calculate risk score based on exploitation results"""

        # Base scores
        severity_scores = {
            'info': 1,
            'low': 2,
            'medium': 5,
            'high': 8,
            'critical': 10
        }

        impact_scores = {
            'none': 0,
            'low': 2,
            'medium': 5,
            'high': 8
        }

        access_level_scores = {
            'none': 0,
            'user': 3,
            'admin': 7,
            'system': 10
        }

        # Calculate components
        severity_score = severity_scores.get(summary.highest_severity, 5)

        impact = summary.impact_assessment
        confidentiality_score = impact_scores.get(impact.confidentiality_impact, 5)
        integrity_score = impact_scores.get(impact.integrity_impact, 5)
        availability_score = impact_scores.get(impact.availability_impact, 5)
        access_score = access_level_scores.get(impact.access_level, 3)

        # Exploitation factor
        if summary.exploit_attempts > 0:
            exploit_success_rate = summary.successful_exploits / summary.exploit_attempts
        else:
            exploit_success_rate = 0

        # Calculate final score (0-100)
        base_score = (severity_score + confidentiality_score + integrity_score +
                     availability_score + access_score) / 5

        # Apply exploitation factor
        final_score = min(100, base_score * 10 * (1 + exploit_success_rate))

        # Risk level
        if final_score >= 90:
            risk_level = 'CRITICAL'
        elif final_score >= 70:
            risk_level = 'HIGH'
        elif final_score >= 40:
            risk_level = 'MEDIUM'
        elif final_score >= 20:
            risk_level = 'LOW'
        else:
            risk_level = 'INFO'

        return {
            'score': round(final_score, 2),
            'level': risk_level,
            'components': {
                'severity': severity_score,
                'confidentiality': confidentiality_score,
                'integrity': integrity_score,
                'availability': availability_score,
                'access_level': access_score,
                'exploit_success_rate': round(exploit_success_rate, 2)
            }
        }

    def export_results(self, session_id: str, format: str = 'json') -> str:
        """Export exploitation results in specified format"""
        report = self.generate_exploitation_report(session_id)

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"exploitation_report_{session_id}_{timestamp}"

        if format.lower() == 'json':
            filepath = self.results_directory / "reports" / f"{filename}.json"
            with open(filepath, 'w') as f:
                json.dump(report, f, indent=2, default=str)

        elif format.lower() == 'html':
            filepath = self.results_directory / "reports" / f"{filename}.html"
            html_content = self.generate_html_report(report)
            with open(filepath, 'w') as f:
                f.write(html_content)

        elif format.lower() == 'csv':
            filepath = self.results_directory / "reports" / f"{filename}.csv"
            self.generate_csv_report(report, filepath)

        return str(filepath)

    def generate_html_report(self, report: Dict[str, Any]) -> str:
        """Generate HTML report"""
        summary = report['summary']

        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Exploitation Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background-color: #f0f0f0; padding: 10px; border-radius: 5px; }}
                .section {{ margin: 20px 0; }}
                .risk-{summary['risk_assessment']['level'].lower()} {{
                    color: {'red' if summary['risk_assessment']['level'] in ['CRITICAL', 'HIGH'] else 'orange' if summary['risk_assessment']['level'] == 'MEDIUM' else 'green'};
                    font-weight: bold;
                }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Exploitation Report</h1>
                <p>Target: {summary['target_url']}</p>
                <p>Vulnerability Type: {summary['vulnerability_type']}</p>
                <p>Generated: {report['generated_at']}</p>
            </div>

            <div class="section">
                <h2>Summary</h2>
                <p>Total Attempts: {summary['exploit_attempts']}</p>
                <p>Successful Exploits: {summary['successful_exploits']}</p>
                <p>Failed Exploits: {summary['failed_exploits']}</p>
                <p class="risk-{summary['risk_assessment']['level'].lower()}">
                    Risk Level: {summary['risk_assessment']['level']}
                    (Score: {summary['risk_assessment']['score']})
                </p>
            </div>

            <div class="section">
                <h2>Impact Assessment</h2>
                <ul>
                    <li>Confidentiality Impact: {summary['impact_assessment']['confidentiality_impact']}</li>
                    <li>Integrity Impact: {summary['impact_assessment']['integrity_impact']}</li>
                    <li>Availability Impact: {summary['impact_assessment']['availability_impact']}</li>
                    <li>Access Level: {summary['impact_assessment']['access_level']}</li>
                </ul>
            </div>

            <div class="section">
                <h2>Recommendations</h2>
                <ul>
        """

        for rec in report['recommendations']:
            html += f"<li>{rec}</li>"

        html += """
                </ul>
            </div>
        </body>
        </html>
        """

        return html

    def generate_csv_report(self, report: Dict[str, Any], filepath: Path):
        """Generate CSV report"""
        import csv

        with open(filepath, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)

            # Write summary
            writer.writerow(['Summary'])
            writer.writerow(['Target URL', report['summary']['target_url']])
            writer.writerow(['Vulnerability Type', report['summary']['vulnerability_type']])
            writer.writerow(['Total Attempts', report['summary']['exploit_attempts']])
            writer.writerow(['Successful Exploits', report['summary']['successful_exploits']])
            writer.writerow(['Risk Level', report['summary']['risk_assessment']['level']])
            writer.writerow([])

            # Write detailed results
            writer.writerow(['Detailed Results'])
            writer.writerow(['Payload', 'Success', 'Response Code', 'Timestamp'])

            for result in report['detailed_results']:
                writer.writerow([
                    result['payload'],
                    result['success'],
                    result.get('response_code', ''),
                    result['timestamp']
                ])

# Example usage
def main():
    """Example usage of the ExploitResultProcessor"""
    processor = ExploitResultProcessor("./scan_results")

    # Create sample session
    session_data = {
        'target_url': 'http://example.com',
        'vulnerability_type': 'sql_injection',
        'started_at': datetime.now(),
        'status': 'completed',
        'total_attempts': 5,
        'successful_attempts': 2
    }

    session_id = processor.store_exploit_session(session_data)

    # Add sample results
    for i in range(5):
        result_data = {
            'payload': f"' OR '1'='1 -- {i}",
            'success': i < 2,  # First 2 are successful
            'response_code': 200 if i < 2 else 403,
            'response_size': 1024,
            'execution_time': 0.5,
            'timestamp': datetime.now(),
            'severity': 'high' if i < 2 else 'info'
        }
        processor.store_exploit_result(session_id, result_data)

    # Generate report
    report_path = processor.export_results(session_id, 'json')
    print(f"Report generated: {report_path}")

    # Analyze session
    summary = processor.analyze_exploitation_session(session_id)
    print(f"Risk Score: {summary.impact_assessment}")

if __name__ == "__main__":
    main()