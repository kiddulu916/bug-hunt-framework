"""
Unit tests for Exploitation models
"""

import pytest
from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from django.utils import timezone

from apps.exploitation.models import (
    ExploitationSession, ExploitResult, ExploitChain, ExploitTemplate,
    ExploitationType, ExploitationStatus, ExploitationSeverity
)
from tests.factories import (
    ExploitationSessionFactory, ExploitResultFactory, ExploitChainFactory,
    ExploitTemplateFactory, VulnerabilityFactory, TargetFactory
)
from tests.test_utils import DatabaseTestMixin


@pytest.mark.unit
class ExploitationSessionModelTest(TestCase, DatabaseTestMixin):
    """Test ExploitationSession model functionality"""

    def setUp(self):
        self.target = TargetFactory.create()
        self.vulnerability = VulnerabilityFactory.create()

        self.exploitation_session_data = {
            'vulnerability': self.vulnerability,
            'target': self.target,
            'exploitation_type': ExploitationType.SQL_INJECTION,
            'status': ExploitationStatus.PENDING,
            'severity': ExploitationSeverity.HIGH,
            'payloads_used': ["' OR 1=1 --", "' UNION SELECT 1,2,3 --"],
            'notes': 'Automated exploitation attempt for SQL injection vulnerability'
        }

    def test_exploitation_session_creation(self):
        """Test basic exploitation session creation"""
        session = ExploitationSession.objects.create(**self.exploitation_session_data)

        self.assertEqual(session.vulnerability, self.vulnerability)
        self.assertEqual(session.target, self.target)
        self.assertEqual(session.exploitation_type, ExploitationType.SQL_INJECTION)
        self.assertEqual(session.status, ExploitationStatus.PENDING)
        self.assertEqual(session.severity, ExploitationSeverity.HIGH)
        self.assertEqual(len(session.payloads_used), 2)
        self.assertTrue(session.automated)
        self.assertIsNotNone(session.id)
        self.assertIsNotNone(session.started_at)

    def test_exploitation_session_string_representation(self):
        """Test exploitation session string representation"""
        session = ExploitationSession.objects.create(**self.exploitation_session_data)
        expected_str = f"Exploitation Session {session.id} - {self.vulnerability}"
        self.assertEqual(str(session), expected_str)

    def test_exploitation_session_required_fields(self):
        """Test that required fields are enforced"""
        # Missing vulnerability
        incomplete_data = self.exploitation_session_data.copy()
        del incomplete_data['vulnerability']

        with self.assertRaises(IntegrityError):
            ExploitationSession.objects.create(**incomplete_data)

        # Missing target
        incomplete_data = self.exploitation_session_data.copy()
        del incomplete_data['target']

        with self.assertRaises(IntegrityError):
            ExploitationSession.objects.create(**incomplete_data)

    def test_exploitation_session_choices(self):
        """Test choice field validation"""
        # Test exploitation types
        valid_types = [
            ExploitationType.SQL_INJECTION,
            ExploitationType.XSS,
            ExploitationType.CSRF,
            ExploitationType.COMMAND_INJECTION,
            ExploitationType.FILE_UPLOAD,
            ExploitationType.RCE
        ]

        for exploitation_type in valid_types:
            session_data = self.exploitation_session_data.copy()
            session_data['exploitation_type'] = exploitation_type
            session_data['vulnerability'] = VulnerabilityFactory.create()  # Unique per test

            session = ExploitationSession.objects.create(**session_data)
            self.assertEqual(session.exploitation_type, exploitation_type)

        # Test exploitation statuses
        valid_statuses = [
            ExploitationStatus.PENDING,
            ExploitationStatus.IN_PROGRESS,
            ExploitationStatus.SUCCESSFUL,
            ExploitationStatus.FAILED,
            ExploitationStatus.PARTIAL,
            ExploitationStatus.BLOCKED,
            ExploitationStatus.TIMEOUT
        ]

        for status in valid_statuses:
            session_data = self.exploitation_session_data.copy()
            session_data['status'] = status
            session_data['vulnerability'] = VulnerabilityFactory.create()  # Unique per test

            session = ExploitationSession.objects.create(**session_data)
            self.assertEqual(session.status, status)

    def test_exploitation_session_default_values(self):
        """Test model default values"""
        minimal_data = {
            'vulnerability': self.vulnerability,
            'target': self.target,
            'exploitation_type': ExploitationType.XSS
        }

        session = ExploitationSession.objects.create(**minimal_data)

        # Check default values
        self.assertEqual(session.status, ExploitationStatus.PENDING)
        self.assertEqual(session.severity, ExploitationSeverity.INFO)
        self.assertEqual(session.exploit_chain_data, {})
        self.assertEqual(session.payloads_used, [])
        self.assertEqual(session.notes, '')
        self.assertTrue(session.automated)

    def test_exploitation_session_json_fields(self):
        """Test JSON field functionality"""
        session_data = self.exploitation_session_data.copy()
        session_data['exploit_chain_data'] = {
            'steps': [
                {
                    'step': 1,
                    'action': 'reconnaissance',
                    'description': 'Identify injection points',
                    'status': 'completed',
                    'timestamp': '2023-10-01T10:00:00Z'
                },
                {
                    'step': 2,
                    'action': 'exploitation',
                    'description': 'Execute SQL injection payload',
                    'status': 'in_progress',
                    'timestamp': '2023-10-01T10:05:00Z'
                },
                {
                    'step': 3,
                    'action': 'post_exploitation',
                    'description': 'Extract sensitive data',
                    'status': 'pending',
                    'timestamp': None
                }
            ],
            'current_step': 2,
            'total_steps': 3,
            'success_criteria': [
                'Authentication bypass achieved',
                'Database access confirmed',
                'Sensitive data extracted'
            ]
        }

        session = ExploitationSession.objects.create(**session_data)

        # Test nested JSON structure
        self.assertEqual(len(session.exploit_chain_data['steps']), 3)
        self.assertEqual(session.exploit_chain_data['current_step'], 2)
        self.assertEqual(session.exploit_chain_data['steps'][0]['status'], 'completed')
        self.assertEqual(session.exploit_chain_data['steps'][1]['action'], 'exploitation')
        self.assertIn('Authentication bypass achieved', session.exploit_chain_data['success_criteria'])

    def test_exploitation_session_array_fields(self):
        """Test array field functionality"""
        session_data = self.exploitation_session_data.copy()
        session_data['payloads_used'] = [
            "admin' OR '1'='1' --",
            "' UNION SELECT 1,username,password FROM users --",
            "'; DROP TABLE sessions; --",
            "admin'/**/OR/**/1=1#",
            "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x)a) --"
        ]

        session = ExploitationSession.objects.create(**session_data)

        self.assertEqual(len(session.payloads_used), 5)
        self.assertIn("admin' OR '1'='1' --", session.payloads_used)
        self.assertIn("'; DROP TABLE sessions; --", session.payloads_used)

    def test_exploitation_session_timing_fields(self):
        """Test timing-related fields"""
        session = ExploitationSession.objects.create(**self.exploitation_session_data)

        # started_at should be auto-populated
        self.assertIsNotNone(session.started_at)

        # completed_at should initially be None
        self.assertIsNone(session.completed_at)

        # Set completion time
        session.completed_at = timezone.now()
        session.save()

        session.refresh_from_db()
        self.assertIsNotNone(session.completed_at)

    def test_exploitation_session_ordering(self):
        """Test model ordering (should be by -started_at)"""
        # Create multiple exploitation sessions
        session1 = ExploitationSessionFactory.create()
        session2 = ExploitationSessionFactory.create()
        session3 = ExploitationSessionFactory.create()

        # Get all sessions (should be ordered by -started_at)
        sessions = list(ExploitationSession.objects.all())

        # The most recently started should be first
        self.assertEqual(sessions[0], session3)
        self.assertEqual(sessions[1], session2)
        self.assertEqual(sessions[2], session1)

    def test_exploitation_session_relationships(self):
        """Test exploitation session relationships"""
        session = ExploitationSession.objects.create(**self.exploitation_session_data)

        # Test vulnerability relationship
        self.assertEqual(session.vulnerability, self.vulnerability)

        # Test target relationship
        self.assertEqual(session.target, self.target)

        # Test reverse relationship from vulnerability
        self.assertIn(session, self.vulnerability.exploitation_sessions.all())

        # Test reverse relationship from target
        self.assertIn(session, self.target.exploitation_sessions.all())

        # Test results relationship exists
        self.assertTrue(hasattr(session, 'results'))
        self.assertEqual(session.results.count(), 0)

    def test_exploitation_session_db_table_name(self):
        """Test that the database table name is correct"""
        session = ExploitationSession.objects.create(**self.exploitation_session_data)
        self.assertEqual(session._meta.db_table, 'exploitation_sessions')


@pytest.mark.unit
class ExploitResultModelTest(TestCase, DatabaseTestMixin):
    """Test ExploitResult model functionality"""

    def setUp(self):
        self.exploitation_session = ExploitationSessionFactory.create()

        self.exploit_result_data = {
            'session': self.exploitation_session,
            'payload': "admin' OR '1'='1' --",
            'response_data': {
                'status_code': 200,
                'response_time': 0.234,
                'content_length': 1024,
                'headers': {
                    'Content-Type': 'text/html',
                    'Set-Cookie': 'session=abc123; HttpOnly'
                },
                'body_excerpt': 'Welcome to admin dashboard'
            },
            'success': True,
            'impact_level': ExploitationSeverity.HIGH,
            'proof_of_concept': 'Successfully bypassed authentication using SQL injection'
        }

    def test_exploit_result_creation(self):
        """Test basic exploit result creation"""
        result = ExploitResult.objects.create(**self.exploit_result_data)

        self.assertEqual(result.session, self.exploitation_session)
        self.assertEqual(result.payload, "admin' OR '1'='1' --")
        self.assertTrue(result.success)
        self.assertEqual(result.impact_level, ExploitationSeverity.HIGH)
        self.assertIsNotNone(result.id)
        self.assertIsNotNone(result.timestamp)

    def test_exploit_result_string_representation(self):
        """Test exploit result string representation"""
        result = ExploitResult.objects.create(**self.exploit_result_data)
        expected_str = f"Exploit Result {result.id} - Success"
        self.assertEqual(str(result), expected_str)

        # Test failed result
        failed_data = self.exploit_result_data.copy()
        failed_data['success'] = False
        failed_result = ExploitResult.objects.create(**failed_data)
        expected_str_failed = f"Exploit Result {failed_result.id} - Failed"
        self.assertEqual(str(failed_result), expected_str_failed)

    def test_exploit_result_required_fields(self):
        """Test that required fields are enforced"""
        # Missing session
        incomplete_data = self.exploit_result_data.copy()
        del incomplete_data['session']

        with self.assertRaises(IntegrityError):
            ExploitResult.objects.create(**incomplete_data)

        # Missing payload
        incomplete_data = self.exploit_result_data.copy()
        del incomplete_data['payload']

        with self.assertRaises(IntegrityError):
            ExploitResult.objects.create(**incomplete_data)

    def test_exploit_result_default_values(self):
        """Test model default values"""
        minimal_data = {
            'session': self.exploitation_session,
            'payload': 'test_payload'
        }

        result = ExploitResult.objects.create(**minimal_data)

        # Check default values
        self.assertEqual(result.response_data, {})
        self.assertFalse(result.success)
        self.assertEqual(result.impact_level, ExploitationSeverity.INFO)
        self.assertEqual(result.evidence_files, [])
        self.assertEqual(result.proof_of_concept, '')

    def test_exploit_result_json_fields(self):
        """Test JSON field functionality"""
        result_data = self.exploit_result_data.copy()
        result_data['response_data'] = {
            'request': {
                'method': 'POST',
                'url': 'https://example.com/login',
                'headers': {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'User-Agent': 'BugBountyBot/1.0'
                },
                'body': 'username=admin%27+OR+%271%27%3D%271%27+--&password=test'
            },
            'response': {
                'status_code': 200,
                'response_time': 0.234,
                'headers': {
                    'Content-Type': 'text/html; charset=utf-8',
                    'Set-Cookie': 'session=abc123def456; HttpOnly; Secure',
                    'Location': '/dashboard'
                },
                'body_excerpt': '<html><body><h1>Welcome Administrator</h1>',
                'body_length': 2048
            },
            'analysis': {
                'sql_injection_confirmed': True,
                'authentication_bypassed': True,
                'admin_access_gained': True,
                'sensitive_data_exposed': False
            }
        }

        result = ExploitResult.objects.create(**result_data)

        # Test nested JSON structure
        self.assertEqual(result.response_data['request']['method'], 'POST')
        self.assertEqual(result.response_data['response']['status_code'], 200)
        self.assertTrue(result.response_data['analysis']['sql_injection_confirmed'])
        self.assertTrue(result.response_data['analysis']['authentication_bypassed'])

    def test_exploit_result_array_fields(self):
        """Test array field functionality"""
        result_data = self.exploit_result_data.copy()
        result_data['evidence_files'] = [
            '/evidence/exploits/screenshot_001.png',
            '/evidence/exploits/response_log.txt',
            '/evidence/exploits/proof_of_concept.py',
            '/evidence/exploits/database_dump.sql',
            '/evidence/exploits/session_capture.pcap'
        ]

        result = ExploitResult.objects.create(**result_data)

        self.assertEqual(len(result.evidence_files), 5)
        self.assertIn('/evidence/exploits/screenshot_001.png', result.evidence_files)
        self.assertIn('/evidence/exploits/database_dump.sql', result.evidence_files)

    def test_exploit_result_impact_levels(self):
        """Test impact level choices"""
        impact_levels = [
            ExploitationSeverity.INFO,
            ExploitationSeverity.LOW,
            ExploitationSeverity.MEDIUM,
            ExploitationSeverity.HIGH,
            ExploitationSeverity.CRITICAL
        ]

        for impact_level in impact_levels:
            result_data = self.exploit_result_data.copy()
            result_data['impact_level'] = impact_level
            result_data['payload'] = f'test_payload_{impact_level}'

            result = ExploitResult.objects.create(**result_data)
            self.assertEqual(result.impact_level, impact_level)

    def test_exploit_result_ordering(self):
        """Test model ordering (should be by -timestamp)"""
        # Create multiple exploit results
        result1 = ExploitResultFactory.create(session=self.exploitation_session)
        result2 = ExploitResultFactory.create(session=self.exploitation_session)
        result3 = ExploitResultFactory.create(session=self.exploitation_session)

        # Get all results (should be ordered by -timestamp)
        results = list(ExploitResult.objects.all())

        # The most recently created should be first
        self.assertEqual(results[0], result3)
        self.assertEqual(results[1], result2)
        self.assertEqual(results[2], result1)

    def test_exploit_result_relationships(self):
        """Test exploit result relationships"""
        result = ExploitResult.objects.create(**self.exploit_result_data)

        # Test session relationship
        self.assertEqual(result.session, self.exploitation_session)

        # Test reverse relationship from session
        self.assertIn(result, self.exploitation_session.results.all())

    def test_exploit_result_db_table_name(self):
        """Test that the database table name is correct"""
        result = ExploitResult.objects.create(**self.exploit_result_data)
        self.assertEqual(result._meta.db_table, 'exploit_results')


@pytest.mark.unit
class ExploitChainModelTest(TestCase, DatabaseTestMixin):
    """Test ExploitChain model functionality"""

    def setUp(self):
        self.vulnerability1 = VulnerabilityFactory.create()
        self.vulnerability2 = VulnerabilityFactory.create()

        self.exploit_chain_data = {
            'name': 'SQL Injection to RCE Chain',
            'description': 'Multi-step exploitation chain from SQL injection to remote code execution',
            'chain_steps': [
                {
                    'step': 1,
                    'name': 'SQL Injection Discovery',
                    'description': 'Identify and confirm SQL injection vulnerability',
                    'payload': "admin' OR '1'='1' --",
                    'expected_result': 'Authentication bypass'
                },
                {
                    'step': 2,
                    'name': 'Database Enumeration',
                    'description': 'Extract database schema and user information',
                    'payload': "' UNION SELECT table_name,column_name FROM information_schema.columns --",
                    'expected_result': 'Database structure revealed'
                },
                {
                    'step': 3,
                    'name': 'File Upload',
                    'description': 'Upload malicious file through admin interface',
                    'payload': '<?php system($_GET["cmd"]); ?>',
                    'expected_result': 'Web shell uploaded'
                },
                {
                    'step': 4,
                    'name': 'Remote Code Execution',
                    'description': 'Execute arbitrary commands on the server',
                    'payload': 'cmd=whoami',
                    'expected_result': 'Command execution confirmed'
                }
            ],
            'success_rate': 0.85
        }

    def test_exploit_chain_creation(self):
        """Test basic exploit chain creation"""
        chain = ExploitChain.objects.create(**self.exploit_chain_data)

        self.assertEqual(chain.name, 'SQL Injection to RCE Chain')
        self.assertEqual(len(chain.chain_steps), 4)
        self.assertEqual(chain.success_rate, 0.85)
        self.assertIsNotNone(chain.id)
        self.assertIsNotNone(chain.created_at)
        self.assertIsNotNone(chain.updated_at)

    def test_exploit_chain_string_representation(self):
        """Test exploit chain string representation"""
        chain = ExploitChain.objects.create(**self.exploit_chain_data)
        expected_str = "Exploit Chain: SQL Injection to RCE Chain"
        self.assertEqual(str(chain), expected_str)

    def test_exploit_chain_required_fields(self):
        """Test that required fields are enforced"""
        # Missing name
        incomplete_data = self.exploit_chain_data.copy()
        del incomplete_data['name']

        with self.assertRaises(IntegrityError):
            ExploitChain.objects.create(**incomplete_data)

        # Missing description
        incomplete_data = self.exploit_chain_data.copy()
        del incomplete_data['description']

        with self.assertRaises(IntegrityError):
            ExploitChain.objects.create(**incomplete_data)

    def test_exploit_chain_default_values(self):
        """Test model default values"""
        minimal_data = {
            'name': 'Minimal Chain',
            'description': 'Basic exploit chain'
        }

        chain = ExploitChain.objects.create(**minimal_data)

        # Check default values
        self.assertEqual(chain.chain_steps, [])
        self.assertEqual(chain.success_rate, 0.0)

    def test_exploit_chain_json_fields(self):
        """Test JSON field functionality"""
        chain = ExploitChain.objects.create(**self.exploit_chain_data)

        # Test chain steps structure
        steps = chain.chain_steps
        self.assertEqual(len(steps), 4)
        self.assertEqual(steps[0]['name'], 'SQL Injection Discovery')
        self.assertEqual(steps[1]['step'], 2)
        self.assertEqual(steps[2]['payload'], '<?php system($_GET["cmd"]); ?>')
        self.assertEqual(steps[3]['expected_result'], 'Command execution confirmed')

    def test_exploit_chain_many_to_many_relationships(self):
        """Test many-to-many relationships with vulnerabilities"""
        chain = ExploitChain.objects.create(**self.exploit_chain_data)

        # Add vulnerabilities to the chain
        chain.target_vulnerabilities.add(self.vulnerability1, self.vulnerability2)

        # Test relationships
        self.assertEqual(chain.target_vulnerabilities.count(), 2)
        self.assertIn(self.vulnerability1, chain.target_vulnerabilities.all())
        self.assertIn(self.vulnerability2, chain.target_vulnerabilities.all())

        # Test reverse relationships
        self.assertIn(chain, self.vulnerability1.exploit_chains.all())
        self.assertIn(chain, self.vulnerability2.exploit_chains.all())

    def test_exploit_chain_ordering(self):
        """Test model ordering (should be by -created_at)"""
        # Create multiple exploit chains
        chain1 = ExploitChainFactory.create()
        chain2 = ExploitChainFactory.create()
        chain3 = ExploitChainFactory.create()

        # Get all chains (should be ordered by -created_at)
        chains = list(ExploitChain.objects.all())

        # The most recently created should be first
        self.assertEqual(chains[0], chain3)
        self.assertEqual(chains[1], chain2)
        self.assertEqual(chains[2], chain1)

    def test_exploit_chain_db_table_name(self):
        """Test that the database table name is correct"""
        chain = ExploitChain.objects.create(**self.exploit_chain_data)
        self.assertEqual(chain._meta.db_table, 'exploit_chains')


@pytest.mark.unit
class ExploitTemplateModelTest(TestCase, DatabaseTestMixin):
    """Test ExploitTemplate model functionality"""

    def setUp(self):
        self.exploit_template_data = {
            'name': 'SQL Injection Template',
            'exploitation_type': ExploitationType.SQL_INJECTION,
            'payload_template': "{username}' OR '1'='1' --",
            'configuration': {
                'timeout': 30,
                'retries': 3,
                'delay_between_requests': 1.0,
                'user_agent': 'BugBountyBot/1.0',
                'follow_redirects': True,
                'verify_ssl': False
            },
            'prerequisites': [
                'Target must have a login form',
                'SQL injection vulnerability must be confirmed',
                'Rate limiting should be considered'
            ]
        }

    def test_exploit_template_creation(self):
        """Test basic exploit template creation"""
        template = ExploitTemplate.objects.create(**self.exploit_template_data)

        self.assertEqual(template.name, 'SQL Injection Template')
        self.assertEqual(template.exploitation_type, ExploitationType.SQL_INJECTION)
        self.assertEqual(template.payload_template, "{username}' OR '1'='1' --")
        self.assertEqual(len(template.prerequisites), 3)
        self.assertIsNotNone(template.id)
        self.assertIsNotNone(template.created_at)
        self.assertIsNotNone(template.updated_at)

    def test_exploit_template_string_representation(self):
        """Test exploit template string representation"""
        template = ExploitTemplate.objects.create(**self.exploit_template_data)
        expected_str = "Exploit Template: SQL Injection Template"
        self.assertEqual(str(template), expected_str)

    def test_exploit_template_required_fields(self):
        """Test that required fields are enforced"""
        # Missing name
        incomplete_data = self.exploit_template_data.copy()
        del incomplete_data['name']

        with self.assertRaises(IntegrityError):
            ExploitTemplate.objects.create(**incomplete_data)

        # Missing exploitation_type
        incomplete_data = self.exploit_template_data.copy()
        del incomplete_data['exploitation_type']

        with self.assertRaises(IntegrityError):
            ExploitTemplate.objects.create(**incomplete_data)

    def test_exploit_template_exploitation_types(self):
        """Test exploitation type choices"""
        exploitation_types = [
            ExploitationType.SQL_INJECTION,
            ExploitationType.XSS,
            ExploitationType.CSRF,
            ExploitationType.COMMAND_INJECTION,
            ExploitationType.FILE_UPLOAD,
            ExploitationType.SSRF,
            ExploitationType.XXE,
            ExploitationType.RCE
        ]

        for exploitation_type in exploitation_types:
            template_data = self.exploit_template_data.copy()
            template_data['name'] = f'Template for {exploitation_type}'
            template_data['exploitation_type'] = exploitation_type

            template = ExploitTemplate.objects.create(**template_data)
            self.assertEqual(template.exploitation_type, exploitation_type)

    def test_exploit_template_default_values(self):
        """Test model default values"""
        minimal_data = {
            'name': 'Minimal Template',
            'exploitation_type': ExploitationType.XSS,
            'payload_template': '<script>alert("{payload}")</script>'
        }

        template = ExploitTemplate.objects.create(**minimal_data)

        # Check default values
        self.assertEqual(template.configuration, {})
        self.assertEqual(template.prerequisites, [])

    def test_exploit_template_json_and_array_fields(self):
        """Test JSON and array field functionality"""
        template_data = self.exploit_template_data.copy()
        template_data['configuration'] = {
            'http_settings': {
                'timeout': 30,
                'retries': 3,
                'delay_between_requests': 1.0,
                'max_redirects': 5
            },
            'headers': {
                'User-Agent': 'BugBountyBot/1.0',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5'
            },
            'payload_settings': {
                'encode_payload': True,
                'url_encode': True,
                'html_encode': False,
                'custom_encoding': None
            },
            'validation': {
                'success_indicators': ['admin dashboard', 'welcome administrator'],
                'failure_indicators': ['invalid credentials', 'access denied'],
                'response_time_threshold': 5.0
            }
        }

        template_data['prerequisites'] = [
            'Target application must be accessible',
            'Authentication form must be present',
            'SQL injection vulnerability confirmed in username parameter',
            'No rate limiting on login attempts',
            'Database errors are visible in responses'
        ]

        template = ExploitTemplate.objects.create(**template_data)

        # Test nested JSON configuration
        self.assertEqual(template.configuration['http_settings']['timeout'], 30)
        self.assertEqual(template.configuration['headers']['User-Agent'], 'BugBountyBot/1.0')
        self.assertTrue(template.configuration['payload_settings']['encode_payload'])
        self.assertIn('admin dashboard', template.configuration['validation']['success_indicators'])

        # Test prerequisites array
        self.assertEqual(len(template.prerequisites), 5)
        self.assertIn('SQL injection vulnerability confirmed in username parameter', template.prerequisites)

    def test_exploit_template_ordering(self):
        """Test model ordering (should be by name)"""
        # Create multiple exploit templates
        template_c = ExploitTemplateFactory.create(name='C Template')
        template_a = ExploitTemplateFactory.create(name='A Template')
        template_b = ExploitTemplateFactory.create(name='B Template')

        # Get all templates (should be ordered by name)
        templates = list(ExploitTemplate.objects.all())

        # Should be ordered alphabetically by name
        self.assertEqual(templates[0], template_a)
        self.assertEqual(templates[1], template_b)
        self.assertEqual(templates[2], template_c)

    def test_exploit_template_db_table_name(self):
        """Test that the database table name is correct"""
        template = ExploitTemplate.objects.create(**self.exploit_template_data)
        self.assertEqual(template._meta.db_table, 'exploit_templates')


@pytest.mark.unit
class ExploitationChoicesTest(TestCase):
    """Test exploitation model choices"""

    def test_exploitation_type_choices(self):
        """Test ExploitationType choices"""
        expected_types = [
            'sql_injection', 'xss', 'csrf', 'command_injection', 'file_upload',
            'directory_traversal', 'ssrf', 'xxe', 'deserialization',
            'privilege_escalation', 'auth_bypass', 'authz_bypass', 'rce',
            'lfi', 'rfi', 'buffer_overflow', 'race_condition'
        ]

        choice_values = [choice[0] for choice in ExploitationType.choices]
        for expected_type in expected_types:
            self.assertIn(expected_type, choice_values)

    def test_exploitation_status_choices(self):
        """Test ExploitationStatus choices"""
        expected_statuses = [
            'pending', 'in_progress', 'successful', 'failed',
            'partial', 'blocked', 'timeout'
        ]

        choice_values = [choice[0] for choice in ExploitationStatus.choices]
        for expected_status in expected_statuses:
            self.assertIn(expected_status, choice_values)

    def test_exploitation_severity_choices(self):
        """Test ExploitationSeverity choices"""
        expected_severities = ['info', 'low', 'medium', 'high', 'critical']

        choice_values = [choice[0] for choice in ExploitationSeverity.choices]
        for expected_severity in expected_severities:
            self.assertIn(expected_severity, choice_values)


@pytest.mark.unit
class ExploitationFactoryTest(TestCase):
    """Test exploitation factory functionality"""

    def test_exploitation_session_factory_creation(self):
        """Test that ExploitationSessionFactory creates valid sessions"""
        session = ExploitationSessionFactory.create()

        self.assertIsInstance(session, ExploitationSession)
        self.assertIsNotNone(session.vulnerability)
        self.assertIsNotNone(session.target)
        self.assertIsNotNone(session.exploitation_type)

    def test_exploit_result_factory_creation(self):
        """Test that ExploitResultFactory creates valid results"""
        result = ExploitResultFactory.create()

        self.assertIsInstance(result, ExploitResult)
        self.assertIsNotNone(result.session)
        self.assertIsNotNone(result.payload)

    def test_successful_exploitation_factory(self):
        """Test SuccessfulExploitationFactory trait"""
        from tests.factories import SuccessfulExploitationFactory

        successful_session = SuccessfulExploitationFactory.create()

        self.assertEqual(successful_session.status, ExploitationStatus.SUCCESSFUL)
        self.assertEqual(successful_session.severity, ExploitationSeverity.HIGH)

        # Check that exploit chain data indicates completion
        chain_data = successful_session.exploit_chain_data
        self.assertIn('steps', chain_data)
        self.assertIn('current_step', chain_data)

    def test_exploitation_factory_realistic_data(self):
        """Test that factories generate realistic data"""
        session = ExploitationSessionFactory.create()

        # Target should match vulnerability's scan session target
        self.assertEqual(session.target, session.vulnerability.scan_session.target)

        # Payloads should be appropriate for exploitation type
        if session.exploitation_type == ExploitationType.SQL_INJECTION:
            for payload in session.payloads_used:
                self.assertTrue(any(marker in payload for marker in ["'", "OR", "UNION", "--"]))

        # Exploit chain data should have proper structure if present
        if session.exploit_chain_data:
            if 'steps' in session.exploit_chain_data:
                for step in session.exploit_chain_data['steps']:
                    self.assertIn('step', step)
                    self.assertIn('action', step)
                    self.assertIn('status', step)