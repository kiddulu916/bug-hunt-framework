"""
Comprehensive tests for vulnerability models with edge cases.
Tests all model methods, properties, validations, and edge cases.
"""

import pytest
import uuid
from datetime import datetime, timedelta
from decimal import Decimal
from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db import IntegrityError, transaction
from django.db.models import Q

from apps.vulnerabilities.models import (
    Vulnerability, VulnSeverity
)
from apps.targets.models import Target, BugBountyPlatform
from apps.scanning.models import ScanSession, ScanStatus
from tests.factories import (
    VulnerabilityFactory, TargetFactory, ScanSessionFactory,
    UserFactory
)


@pytest.mark.unit
class TestVulnerabilityModel(TestCase):
    """Comprehensive tests for Vulnerability model."""

    def setUp(self):
        """Set up test data."""
        self.user = UserFactory()
        # BugBountyPlatform is a TextChoices enum
        self.target = TargetFactory(
            platform=BugBountyPlatform.PRIVATE,
            researcher_username="test_user"
        )
        self.scan_session = ScanSessionFactory(
            target=self.target,
            initiated_by=self.user
        )

    def test_vulnerability_creation_valid_data(self):
        """Test creating vulnerability with valid data."""
        vulnerability = Vulnerability.objects.create(
            vulnerability_name="SQL Injection in Login",
            vulnerability_type="sql_injection",
            severity=VulnSeverity.HIGH,
            affected_url="https://example.com/login",
            impact_description="Allows unauthorized access to user data",
            target=self.target,
            scan_session=self.scan_session,
            discovered_by_tool="sqlmap",
            discovery_method="automated_scanning"
        )

        self.assertIsNotNone(vulnerability.id)
        self.assertEqual(vulnerability.vulnerability_name, "SQL Injection in Login")
        self.assertEqual(vulnerability.severity, VulnSeverity.HIGH)
        # Default status field doesn't exist in current model
        self.assertIsNotNone(vulnerability.id)
        self.assertIsInstance(vulnerability.discovered_at, datetime)

    def test_vulnerability_string_representation(self):
        """Test string representation of vulnerability."""
        vulnerability = VulnerabilityFactory(
            vulnerability_name="XSS Vulnerability",
            target=self.target
        )
        expected = f"XSS Vulnerability - {vulnerability.target.target_name}"
        self.assertEqual(str(vulnerability), expected)

    def test_vulnerability_severity_choices(self):
        """Test all severity choices are valid."""
        severities = [
            VulnSeverity.CRITICAL,
            VulnSeverity.HIGH,
            VulnSeverity.MEDIUM,
            VulnSeverity.LOW,
            VulnSeverity.INFO
        ]

        for severity in severities:
            vulnerability = VulnerabilityFactory(
                target=self.target,
                severity=severity
            )
            self.assertEqual(vulnerability.severity, severity)

    def test_vulnerability_status_choices(self):
        """Test all status choices are valid."""
        # VulnerabilityStatus doesn't exist in current model
        # Test with different vulnerability types instead
        vuln_types = ["xss", "sqli", "rce", "csrf", "idor"]

        for vuln_type in vuln_types:
            vulnerability = VulnerabilityFactory(
                scan_session=self.scan_session,
                vulnerability_type=vuln_type
            )
            self.assertEqual(vulnerability.vulnerability_type, vuln_type)

    def test_vulnerability_cvss_score_validation(self):
        """Test CVSS score validation."""
        # Valid CVSS scores
        valid_scores = [0.0, 5.5, 10.0]
        for score in valid_scores:
            vulnerability = VulnerabilityFactory(
                target=self.target,
                cvss_score=score
            )
            self.assertEqual(float(vulnerability.cvss_score), score)

        # Invalid CVSS scores should be handled by model constraints
        with self.assertRaises(IntegrityError):
            with transaction.atomic():
                Vulnerability.objects.create(
                    vulnerability_name="Test",
                    vulnerability_type="xss",
                    severity=VulnSeverity.HIGH,
                    affected_url="https://example.com",
                    impact_description="Test impact",
                    target=self.target,
                    scan_session=self.scan_session,
                    discovered_by_tool="test",
                    discovery_method="manual",
                    cvss_score=-1.0  # Invalid negative score
                )

    def test_vulnerability_confidence_level_validation(self):
        """Test confidence level validation."""
        # Valid confidence levels
        valid_levels = [0.0, 0.5, 1.0]
        for level in valid_levels:
            vulnerability = VulnerabilityFactory(
                target=self.target,
                confidence_level=level
            )
            self.assertEqual(float(vulnerability.confidence_level), level)

    def test_vulnerability_false_positive_likelihood_validation(self):
        """Test false positive likelihood validation."""
        # Valid false positive likelihoods
        valid_likelihoods = [0.0, 0.3, 1.0]
        for likelihood in valid_likelihoods:
            vulnerability = VulnerabilityFactory(
                target=self.target,
                false_positive_likelihood=likelihood
            )
            self.assertEqual(float(vulnerability.false_positive_likelihood), likelihood)

    def test_vulnerability_url_validation(self):
        """Test URL field validation."""
        # Valid URLs
        valid_urls = [
            "https://example.com",
            "http://test.com/path?param=value",
            "https://subdomain.example.com:8080/api/v1/endpoint"
        ]

        for url in valid_urls:
            vulnerability = VulnerabilityFactory(
                target=self.target,
                affected_url=url
            )
            self.assertEqual(vulnerability.affected_url, url)

    def test_vulnerability_optional_fields(self):
        """Test optional fields can be None or empty."""
        vulnerability = Vulnerability.objects.create(
            vulnerability_name="Test Vulnerability",
            vulnerability_type="xss",
            severity=VulnSeverity.MEDIUM,
            affected_url="https://example.com",
            impact_description="Test impact",
            target=self.target,
            scan_session=self.scan_session,
            discovered_by_tool="manual",
            discovery_method="manual_testing",
            # Optional fields left as None/empty
            owasp_category=None,
            cwe_id=None,
            affected_parameter=None,
            http_method=None,
            payload_used=None,
            request_data=None,
            response_data=None,
            exploitation_notes=None,
            remediation_suggestion=None
        )

        self.assertIsNone(vulnerability.owasp_category)
        self.assertIsNone(vulnerability.cwe_id)
        self.assertIsNone(vulnerability.affected_parameter)

    def test_vulnerability_json_fields(self):
        """Test JSON fields functionality."""
        additional_evidence = {
            "headers": {"X-Powered-By": "PHP/7.4"},
            "technologies": ["PHP", "Apache"],
            "cookies": ["PHPSESSID=abc123"]
        }

        vulnerability = VulnerabilityFactory(
            target=self.target,
            additional_evidence=additional_evidence
        )

        self.assertEqual(vulnerability.additional_evidence, additional_evidence)
        self.assertEqual(vulnerability.additional_evidence["headers"]["X-Powered-By"], "PHP/7.4")

    def test_vulnerability_screenshot_paths_array(self):
        """Test screenshot paths array field."""
        screenshot_paths = [
            "/media/screenshots/vuln1_screenshot1.png",
            "/media/screenshots/vuln1_screenshot2.png"
        ]

        vulnerability = VulnerabilityFactory(
            target=self.target,
            screenshot_paths=screenshot_paths
        )

        self.assertEqual(vulnerability.screenshot_paths, screenshot_paths)
        self.assertEqual(len(vulnerability.screenshot_paths), 2)

    def test_vulnerability_foreign_key_relationships(self):
        """Test foreign key relationships."""
        vulnerability = VulnerabilityFactory(
            target=self.target,
            scan_session=self.scan_session
        )

        # Test target relationship
        self.assertEqual(vulnerability.target, self.target)
        self.assertIn(vulnerability, self.target.vulnerabilities.all())

        # Test scan session relationship
        self.assertEqual(vulnerability.scan_session, self.scan_session)
        self.assertIn(vulnerability, self.scan_session.vulnerabilities.all())

    def test_vulnerability_ordering(self):
        """Test default ordering by discovered_at descending."""
        older_vuln = VulnerabilityFactory(target=self.target)
        # Manually set discovered_at to ensure ordering
        older_vuln.discovered_at = datetime.now() - timedelta(hours=1)
        older_vuln.save()

        newer_vuln = VulnerabilityFactory(target=self.target)

        vulnerabilities = Vulnerability.objects.all()
        self.assertEqual(vulnerabilities.first(), newer_vuln)
        self.assertEqual(vulnerabilities.last(), older_vuln)

    def test_vulnerability_indexes(self):
        """Test database indexes exist for performance."""
        # Create multiple vulnerabilities to test index usage
        for i in range(10):
            VulnerabilityFactory(
                target=self.target,
                severity=VulnSeverity.HIGH if i % 2 == 0 else VulnSeverity.LOW,
                vulnerability_type="xss" if i % 3 == 0 else "sql_injection"
            )

        # These queries should use indexes efficiently
        high_severity_vulns = Vulnerability.objects.filter(severity=VulnSeverity.HIGH)
        xss_vulns = Vulnerability.objects.filter(vulnerability_type="xss")
        target_vulns = Vulnerability.objects.filter(target=self.target)

        self.assertTrue(high_severity_vulns.exists())
        self.assertTrue(xss_vulns.exists())
        self.assertTrue(target_vulns.exists())

    def test_vulnerability_unique_constraints(self):
        """Test unique constraints where applicable."""
        # Create first vulnerability
        vuln1 = VulnerabilityFactory(
            target=self.target,
            affected_url="https://example.com/login",
            vulnerability_type="sql_injection"
        )

        # Creating similar vulnerability should be allowed (no unique constraint)
        vuln2 = VulnerabilityFactory(
            target=self.target,
            affected_url="https://example.com/login",
            vulnerability_type="sql_injection"
        )

        self.assertNotEqual(vuln1.id, vuln2.id)

    def test_vulnerability_cascade_deletion(self):
        """Test cascade deletion behavior."""
        vulnerability = VulnerabilityFactory(target=self.target)
        vuln_id = vulnerability.id

        # Deleting target should cascade delete vulnerability
        self.target.delete()

        with self.assertRaises(Vulnerability.DoesNotExist):
            Vulnerability.objects.get(id=vuln_id)

    def test_vulnerability_query_optimization(self):
        """Test query optimization with select_related and prefetch_related."""
        vulnerability = VulnerabilityFactory(target=self.target, scan_session=self.scan_session)

        # Test select_related for foreign keys
        vuln_with_related = Vulnerability.objects.select_related(
            'target', 'scan_session'
        ).get(id=vulnerability.id)

        # These should not trigger additional queries
        self.assertEqual(vuln_with_related.target.target_name, self.target.target_name)
        self.assertEqual(vuln_with_related.scan_session.id, self.scan_session.id)

    def test_vulnerability_edge_cases(self):
        """Test edge cases and boundary conditions."""
        # Test with maximum length strings
        long_name = "A" * 255  # Assuming max_length=255
        long_description = "B" * 1000  # Long description

        vulnerability = VulnerabilityFactory(
            target=self.target,
            vulnerability_name=long_name,
            impact_description=long_description
        )

        self.assertEqual(len(vulnerability.vulnerability_name), 255)
        self.assertEqual(len(vulnerability.impact_description), 1000)

    def test_vulnerability_business_logic(self):
        """Test business logic and computed properties."""
        vulnerability = VulnerabilityFactory(
            target=self.target,
            severity=VulnSeverity.CRITICAL,
            cvss_score=9.5,
            confidence_level=0.9,
            false_positive_likelihood=0.1
        )

        # Test any computed properties or business logic methods
        # (These would need to be implemented in the model)
        self.assertTrue(hasattr(vulnerability, 'severity'))
        self.assertEqual(vulnerability.severity, VulnSeverity.CRITICAL)


# VulnerabilityEvidence and VulnerabilityNote models don't exist in current implementation
# Removed these test classes as the models are not implemented


@pytest.mark.unit
class TestVulnerabilityQuerysets(TestCase):
    """Test custom querysets and managers for Vulnerability model."""

    def setUp(self):
        """Set up test data."""
        self.user = UserFactory()
        self.target = TargetFactory(
            platform=BugBountyPlatform.PRIVATE,
            researcher_username="test_user"
        )

    def test_severity_filtering(self):
        """Test filtering by severity."""
        # Create vulnerabilities with different severities
        critical_vuln = VulnerabilityFactory(
            scan_session__target=self.target,
            severity=VulnSeverity.CRITICAL
        )
        high_vuln = VulnerabilityFactory(
            scan_session__target=self.target,
            severity=VulnSeverity.HIGH
        )
        low_vuln = VulnerabilityFactory(
            scan_session__target=self.target,
            severity=VulnSeverity.LOW
        )

        # Test filtering
        critical_vulns = Vulnerability.objects.filter(severity=VulnSeverity.CRITICAL)
        self.assertIn(critical_vuln, critical_vulns)
        self.assertNotIn(high_vuln, critical_vulns)

    def test_status_filtering(self):
        """Test filtering by status."""
        open_vuln = VulnerabilityFactory(
            target=self.target,
            manually_verified=True  # Use existing field instead of"open"
        )
        fixed_vuln = VulnerabilityFactory(
            target=self.target,
            manually_verified=True  # Use existing field instead of"fixed"
        )

        # Test filtering
        open_vulns = Vulnerability.objects.filter(manually_verified=True)  # Use existing field instead of "open"
        self.assertIn(open_vuln, open_vulns)
        self.assertNotIn(fixed_vuln, open_vulns)

    def test_complex_queries(self):
        """Test complex queries with multiple filters."""
        # Create test data
        target_vuln = VulnerabilityFactory(
            target=self.target,
            severity=VulnSeverity.HIGH,
            vulnerability_type="sql_injection",
            manually_verified=True  # Use existing field instead of"open"
        )

        other_target = TargetFactory(researcher_username="test_user")
        other_vuln = VulnerabilityFactory(
            target=other_target,
            severity=VulnSeverity.HIGH,
            vulnerability_type="sql_injection",
            manually_verified=True  # Use existing field instead of"open"
        )

        # Complex query
        target_high_sql_vulns = Vulnerability.objects.filter(
            target=self.target,
            severity=VulnSeverity.HIGH,
            vulnerability_type="sql_injection",
            manually_verified=True  # Use existing field instead of"open"
        )

        self.assertIn(target_vuln, target_high_sql_vulns)
        self.assertNotIn(other_vuln, target_high_sql_vulns)

    def test_date_range_filtering(self):
        """Test filtering by date ranges."""
        old_vuln = VulnerabilityFactory(target=self.target)
        old_vuln.discovered_at = datetime.now() - timedelta(days=30)
        old_vuln.save()

        recent_vuln = VulnerabilityFactory(target=self.target)

        # Filter recent vulnerabilities (last 7 days)
        recent_date = datetime.now() - timedelta(days=7)
        recent_vulns = Vulnerability.objects.filter(discovered_at__gte=recent_date)

        self.assertIn(recent_vuln, recent_vulns)
        self.assertNotIn(old_vuln, recent_vulns)