"""
Unit tests for Vulnerability models
"""

import pytest
from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db import IntegrityError

from apps.vulnerabilities.models import (
    Vulnerability, VulnSeverity, ExploitationDifficulty,
    RemediationPriority, ExploitationChain
)
from tests.factories import (
    VulnerabilityFactory, ScanSessionFactory, TargetFactory
)
from tests.test_utils import DatabaseTestMixin


@pytest.mark.unit
class VulnerabilityModelTest(TestCase, DatabaseTestMixin):
    """Test Vulnerability model functionality"""

    def setUp(self):
        self.target = TargetFactory.create()
        self.scan_session = ScanSessionFactory.create(target=self.target)

        self.vulnerability_data = {
            'scan_session': self.scan_session,
            'vulnerability_name': 'SQL Injection in Login Form',
            'vulnerability_type': 'sql_injection',
            'owasp_category': 'A03',
            'cwe_id': 'CWE-89',
            'severity': VulnSeverity.HIGH,
            'cvss_score': 8.1,
            'impact_description': 'Potential data breach and unauthorized access',
            'affected_url': 'https://example.com/login',
            'affected_parameter': 'username',
            'http_method': 'POST',
            'payload_used': "admin' OR '1'='1' --",
            'discovered_by_tool': 'sqlmap',
            'discovery_method': 'automated_parameter_fuzzing',
            'confidence_level': 0.9,
            'remediation_suggestion': 'Use parameterized queries'
        }

    def test_vulnerability_creation(self):
        """Test basic vulnerability creation"""
        vulnerability = Vulnerability.objects.create(**self.vulnerability_data)

        self.assertEqual(vulnerability.vulnerability_name, 'SQL Injection in Login Form')
        self.assertEqual(vulnerability.vulnerability_type, 'sql_injection')
        self.assertEqual(vulnerability.severity, VulnSeverity.HIGH)
        self.assertEqual(vulnerability.cvss_score, 8.1)
        self.assertEqual(vulnerability.scan_session, self.scan_session)
        self.assertIsNotNone(vulnerability.id)
        self.assertIsNotNone(vulnerability.discovered_at)
        self.assertIsNotNone(vulnerability.updated_at)

    def test_vulnerability_string_representation(self):
        """Test vulnerability string representation"""
        vulnerability = Vulnerability.objects.create(**self.vulnerability_data)
        expected_str = "SQL Injection in Login Form - High"
        self.assertEqual(str(vulnerability), expected_str)

    def test_vulnerability_required_fields(self):
        """Test that required fields are enforced"""
        # Missing scan_session
        incomplete_data = self.vulnerability_data.copy()
        del incomplete_data['scan_session']

        with self.assertRaises(IntegrityError):
            Vulnerability.objects.create(**incomplete_data)

        # Missing vulnerability_name
        incomplete_data = self.vulnerability_data.copy()
        del incomplete_data['vulnerability_name']

        with self.assertRaises(IntegrityError):
            Vulnerability.objects.create(**incomplete_data)

    def test_vulnerability_severity_choices(self):
        """Test severity choice validation"""
        valid_severities = [
            VulnSeverity.CRITICAL,
            VulnSeverity.HIGH,
            VulnSeverity.MEDIUM,
            VulnSeverity.LOW,
            VulnSeverity.INFO
        ]

        for severity in valid_severities:
            vuln_data = self.vulnerability_data.copy()
            vuln_data['vulnerability_name'] = f'Test Vulnerability {severity}'
            vuln_data['severity'] = severity

            vulnerability = Vulnerability.objects.create(**vuln_data)
            self.assertEqual(vulnerability.severity, severity)

    def test_vulnerability_severity_score_property(self):
        """Test severity_score property"""
        severity_scores = {
            VulnSeverity.CRITICAL: 5,
            VulnSeverity.HIGH: 4,
            VulnSeverity.MEDIUM: 3,
            VulnSeverity.LOW: 2,
            VulnSeverity.INFO: 1
        }

        for severity, expected_score in severity_scores.items():
            vuln_data = self.vulnerability_data.copy()
            vuln_data['vulnerability_name'] = f'Test Vulnerability {severity}'
            vuln_data['severity'] = severity

            vulnerability = Vulnerability.objects.create(**vuln_data)
            self.assertEqual(vulnerability.severity_score, expected_score)

    def test_vulnerability_has_evidence_property(self):
        """Test has_evidence property"""
        # Vulnerability without evidence
        vuln_no_evidence = Vulnerability.objects.create(**self.vulnerability_data)
        self.assertFalse(vuln_no_evidence.has_evidence)

        # Vulnerability with screenshot evidence
        vuln_data_with_screenshots = self.vulnerability_data.copy()
        vuln_data_with_screenshots['vulnerability_name'] = 'Vuln with Screenshots'
        vuln_data_with_screenshots['screenshot_paths'] = [
            '/evidence/screenshots/vuln_001.png',
            '/evidence/screenshots/vuln_002.png'
        ]

        vuln_with_screenshots = Vulnerability.objects.create(**vuln_data_with_screenshots)
        self.assertTrue(vuln_with_screenshots.has_evidence)

        # Vulnerability with additional evidence
        vuln_data_with_additional = self.vulnerability_data.copy()
        vuln_data_with_additional['vulnerability_name'] = 'Vuln with Additional Evidence'
        vuln_data_with_additional['additional_evidence'] = {
            'log_files': ['/evidence/logs/scan.log'],
            'pcap_files': ['/evidence/pcap/traffic.pcap']
        }

        vuln_with_additional = Vulnerability.objects.create(**vuln_data_with_additional)
        self.assertTrue(vuln_with_additional.has_evidence)

    def test_vulnerability_owasp_description_method(self):
        """Test get_owasp_description method"""
        owasp_mappings = {
            'A01': 'Broken Access Control',
            'A02': 'Cryptographic Failures',
            'A03': 'Injection',
            'A04': 'Insecure Design',
            'A05': 'Security Misconfiguration',
            'A06': 'Vulnerable and Outdated Components',
            'A07': 'Identification and Authentication Failures',
            'A08': 'Software and Data Integrity Failures',
            'A09': 'Security Logging and Monitoring Failures',
            'A10': 'Server-Side Request Forgery'
        }

        for owasp_id, expected_description in owasp_mappings.items():
            vuln_data = self.vulnerability_data.copy()
            vuln_data['vulnerability_name'] = f'Test Vulnerability {owasp_id}'
            vuln_data['owasp_category'] = owasp_id

            vulnerability = Vulnerability.objects.create(**vuln_data)
            self.assertEqual(vulnerability.get_owasp_description(), expected_description)

        # Test unknown OWASP category
        vuln_data_unknown = self.vulnerability_data.copy()
        vuln_data_unknown['vulnerability_name'] = 'Unknown OWASP'
        vuln_data_unknown['owasp_category'] = 'A99'

        vuln_unknown = Vulnerability.objects.create(**vuln_data_unknown)
        self.assertEqual(vuln_unknown.get_owasp_description(), '')

    def test_vulnerability_default_values(self):
        """Test model default values"""
        minimal_data = {
            'scan_session': self.scan_session,
            'vulnerability_name': 'Minimal Vulnerability',
            'vulnerability_type': 'other',
            'severity': VulnSeverity.LOW,
            'impact_description': 'Minimal impact',
            'affected_url': 'https://example.com/test',
            'discovered_by_tool': 'manual',
            'discovery_method': 'manual testing'
        }

        vulnerability = Vulnerability.objects.create(**minimal_data)

        # Check default values
        self.assertEqual(vulnerability.screenshot_paths, [])
        self.assertEqual(vulnerability.additional_evidence, {})
        self.assertFalse(vulnerability.is_exploitable)
        self.assertFalse(vulnerability.manually_verified)
        self.assertEqual(vulnerability.confidence_level, 0.0)
        self.assertEqual(vulnerability.false_positive_likelihood, 0.0)

    def test_vulnerability_array_fields(self):
        """Test array field functionality"""
        vuln_data = self.vulnerability_data.copy()
        vuln_data['screenshot_paths'] = [
            '/evidence/screenshots/vuln_001.png',
            '/evidence/screenshots/vuln_002.png',
            '/evidence/screenshots/vuln_003.png'
        ]

        vulnerability = Vulnerability.objects.create(**vuln_data)

        self.assertEqual(len(vulnerability.screenshot_paths), 3)
        self.assertIn('/evidence/screenshots/vuln_001.png', vulnerability.screenshot_paths)
        self.assertIn('/evidence/screenshots/vuln_002.png', vulnerability.screenshot_paths)
        self.assertIn('/evidence/screenshots/vuln_003.png', vulnerability.screenshot_paths)

    def test_vulnerability_json_fields(self):
        """Test JSON field functionality"""
        vuln_data = self.vulnerability_data.copy()
        vuln_data['additional_evidence'] = {
            'log_files': ['/evidence/logs/scan.log', '/evidence/logs/exploit.log'],
            'network_traces': ['/evidence/pcap/traffic.pcap'],
            'source_code': '/evidence/source/vulnerable_code.php',
            'database_dumps': ['/evidence/db/users.sql'],
            'metadata': {
                'discovered_time': '2023-10-01T12:00:00Z',
                'scanner_version': '1.2.3',
                'confidence_factors': ['pattern_match', 'response_analysis']
            }
        }

        vulnerability = Vulnerability.objects.create(**vuln_data)

        # Test nested JSON structure
        self.assertEqual(len(vulnerability.additional_evidence['log_files']), 2)
        self.assertIn('/evidence/logs/scan.log', vulnerability.additional_evidence['log_files'])
        self.assertEqual(vulnerability.additional_evidence['source_code'], '/evidence/source/vulnerable_code.php')
        self.assertEqual(
            vulnerability.additional_evidence['metadata']['scanner_version'],
            '1.2.3'
        )

    def test_vulnerability_exploitation_fields(self):
        """Test exploitation-related fields"""
        vuln_data = self.vulnerability_data.copy()
        vuln_data.update({
            'is_exploitable': True,
            'exploitation_difficulty': ExploitationDifficulty.MEDIUM,
            'exploitation_notes': 'Successfully exploited using custom payload',
            'remediation_priority': RemediationPriority.HIGH
        })

        vulnerability = Vulnerability.objects.create(**vuln_data)

        self.assertTrue(vulnerability.is_exploitable)
        self.assertEqual(vulnerability.exploitation_difficulty, ExploitationDifficulty.MEDIUM)
        self.assertEqual(vulnerability.exploitation_notes, 'Successfully exploited using custom payload')
        self.assertEqual(vulnerability.remediation_priority, RemediationPriority.HIGH)

    def test_vulnerability_verification_fields(self):
        """Test manual verification fields"""
        vuln_data = self.vulnerability_data.copy()
        vuln_data.update({
            'manually_verified': True,
            'verification_notes': 'Manually confirmed the vulnerability exists and is exploitable.'
        })

        vulnerability = Vulnerability.objects.create(**vuln_data)

        self.assertTrue(vulnerability.manually_verified)
        self.assertEqual(
            vulnerability.verification_notes,
            'Manually confirmed the vulnerability exists and is exploitable.'
        )

    def test_vulnerability_ordering(self):
        """Test model ordering (should be by -discovered_at)"""
        # Create multiple vulnerabilities
        vuln1 = VulnerabilityFactory.create(scan_session=self.scan_session)
        vuln2 = VulnerabilityFactory.create(scan_session=self.scan_session)
        vuln3 = VulnerabilityFactory.create(scan_session=self.scan_session)

        # Get all vulnerabilities (should be ordered by -discovered_at)
        vulnerabilities = list(Vulnerability.objects.all())

        # The most recently discovered should be first
        self.assertEqual(vulnerabilities[0], vuln3)
        self.assertEqual(vulnerabilities[1], vuln2)
        self.assertEqual(vulnerabilities[2], vuln1)

    def test_vulnerability_relationships(self):
        """Test vulnerability relationships with other models"""
        vulnerability = VulnerabilityFactory.create(scan_session=self.scan_session)

        # Test scan_session relationship
        self.assertEqual(vulnerability.scan_session, self.scan_session)

        # Test reverse relationship from scan_session
        self.assertIn(vulnerability, self.scan_session.vulnerabilities.all())

        # Test exploitation_sessions relationship exists
        self.assertTrue(hasattr(vulnerability, 'exploitation_sessions'))
        self.assertEqual(vulnerability.exploitation_sessions.count(), 0)

        # Test exploitation_chains relationship exists
        self.assertTrue(hasattr(vulnerability, 'exploitation_chains'))
        self.assertEqual(vulnerability.exploitation_chains.count(), 0)

    def test_vulnerability_severity_stats_classmethod(self):
        """Test get_severity_stats class method"""
        # Create vulnerabilities with different severities
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.CRITICAL)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.CRITICAL)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.HIGH)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.HIGH)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.HIGH)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.MEDIUM)
        VulnerabilityFactory.create(scan_session=self.scan_session, severity=VulnSeverity.LOW)

        # Test stats for all vulnerabilities
        all_stats = Vulnerability.get_severity_stats()
        self.assertEqual(all_stats['total'], 7)
        self.assertEqual(all_stats['critical'], 2)
        self.assertEqual(all_stats['high'], 3)
        self.assertEqual(all_stats['medium'], 1)
        self.assertEqual(all_stats['low'], 1)
        self.assertEqual(all_stats['info'], 0)

        # Test stats for specific scan session
        session_stats = Vulnerability.get_severity_stats(scan_session=self.scan_session)
        self.assertEqual(session_stats['total'], 7)
        self.assertEqual(session_stats['critical'], 2)
        self.assertEqual(session_stats['high'], 3)

        # Create vulnerabilities for different scan session
        other_scan = ScanSessionFactory.create()
        VulnerabilityFactory.create(scan_session=other_scan, severity=VulnSeverity.INFO)

        # Stats for original scan session should remain the same
        session_stats_after = Vulnerability.get_severity_stats(scan_session=self.scan_session)
        self.assertEqual(session_stats_after['total'], 7)

        # Stats for all vulnerabilities should include the new one
        all_stats_after = Vulnerability.get_severity_stats()
        self.assertEqual(all_stats_after['total'], 8)
        self.assertEqual(all_stats_after['info'], 1)

    def test_vulnerability_indexing(self):
        """Test that database indexes are created correctly"""
        # Create vulnerabilities with different attributes
        VulnerabilityFactory.create_batch(
            3, scan_session=self.scan_session, severity=VulnSeverity.HIGH
        )
        VulnerabilityFactory.create_batch(
            2, scan_session=self.scan_session, vulnerability_type='xss'
        )
        VulnerabilityFactory.create_batch(
            2, scan_session=self.scan_session, owasp_category='A03'
        )

        # These queries should be efficient due to indexes
        high_vulnerabilities = Vulnerability.objects.filter(severity=VulnSeverity.HIGH)
        xss_vulnerabilities = Vulnerability.objects.filter(vulnerability_type='xss')
        a03_vulnerabilities = Vulnerability.objects.filter(owasp_category='A03')
        verified_vulnerabilities = Vulnerability.objects.filter(manually_verified=True)

        self.assertEqual(high_vulnerabilities.count(), 3)
        self.assertEqual(xss_vulnerabilities.count(), 2)
        self.assertEqual(a03_vulnerabilities.count(), 2)
        # No manually verified vulnerabilities created
        self.assertEqual(verified_vulnerabilities.count(), 0)

    def test_vulnerability_db_table_name(self):
        """Test that the database table name is correct"""
        vulnerability = VulnerabilityFactory.create()
        self.assertEqual(vulnerability._meta.db_table, 'vulnerabilities')


@pytest.mark.unit
class ExploitationChainModelTest(TestCase, DatabaseTestMixin):
    """Test ExploitationChain model functionality"""

    def setUp(self):
        self.target = TargetFactory.create()
        self.scan_session = ScanSessionFactory.create(target=self.target)
        self.vulnerability = VulnerabilityFactory.create(scan_session=self.scan_session)

        self.chain_data = {
            'vulnerability': self.vulnerability,
            'chain_name': 'SQL Injection Chain',
            'chain_description': 'Multi-step SQL injection exploitation',
            'step_number': 1,
            'total_steps': 3,
            'step_description': 'Initial reconnaissance and parameter discovery',
            'payload': "admin' OR '1'='1' --",
            'expected_result': 'Authentication bypass',
            'actual_result': 'Successfully bypassed authentication',
            'step_successful': True
        }

    def test_exploitation_chain_creation(self):
        """Test basic exploitation chain creation"""
        chain = ExploitationChain.objects.create(**self.chain_data)

        self.assertEqual(chain.vulnerability, self.vulnerability)
        self.assertEqual(chain.chain_name, 'SQL Injection Chain')
        self.assertEqual(chain.step_number, 1)
        self.assertEqual(chain.total_steps, 3)
        self.assertTrue(chain.step_successful)
        self.assertIsNotNone(chain.id)
        self.assertIsNotNone(chain.executed_at)

    def test_exploitation_chain_string_representation(self):
        """Test exploitation chain string representation"""
        chain = ExploitationChain.objects.create(**self.chain_data)
        expected_str = "SQL Injection Chain - Step 1/3"
        self.assertEqual(str(chain), expected_str)

    def test_exploitation_chain_is_final_step_property(self):
        """Test is_final_step property"""
        # Not final step
        chain_step1 = ExploitationChain.objects.create(**self.chain_data)
        self.assertFalse(chain_step1.is_final_step)

        # Final step
        final_step_data = self.chain_data.copy()
        final_step_data['step_number'] = 3  # Same as total_steps
        chain_final = ExploitationChain.objects.create(**final_step_data)
        self.assertTrue(chain_final.is_final_step)

    def test_exploitation_chain_success_percentage_property(self):
        """Test success_percentage property"""
        chain_name = 'Test Chain'

        # Create multiple steps for the same chain
        step1_data = self.chain_data.copy()
        step1_data.update({
            'chain_name': chain_name,
            'step_number': 1,
            'total_steps': 4,
            'step_successful': True
        })

        step2_data = self.chain_data.copy()
        step2_data.update({
            'chain_name': chain_name,
            'step_number': 2,
            'total_steps': 4,
            'step_successful': True
        })

        step3_data = self.chain_data.copy()
        step3_data.update({
            'chain_name': chain_name,
            'step_number': 3,
            'total_steps': 4,
            'step_successful': False
        })

        step4_data = self.chain_data.copy()
        step4_data.update({
            'chain_name': chain_name,
            'step_number': 4,
            'total_steps': 4,
            'step_successful': True
        })

        step1 = ExploitationChain.objects.create(**step1_data)
        step2 = ExploitationChain.objects.create(**step2_data)
        step3 = ExploitationChain.objects.create(**step3_data)
        step4 = ExploitationChain.objects.create(**step4_data)

        # 3 out of 4 steps successful = 75%
        self.assertEqual(step1.success_percentage, 75.0)
        self.assertEqual(step2.success_percentage, 75.0)
        self.assertEqual(step3.success_percentage, 75.0)
        self.assertEqual(step4.success_percentage, 75.0)

    def test_exploitation_chain_ordering(self):
        """Test model ordering (should be by vulnerability, step_number)"""
        # Create multiple chain steps
        step2_data = self.chain_data.copy()
        step2_data['step_number'] = 2

        step3_data = self.chain_data.copy()
        step3_data['step_number'] = 3

        step3 = ExploitationChain.objects.create(**step3_data)
        step1 = ExploitationChain.objects.create(**self.chain_data)
        step2 = ExploitationChain.objects.create(**step2_data)

        # Get all chains (should be ordered by vulnerability, step_number)
        chains = list(ExploitationChain.objects.all())

        # Should be ordered by step number
        self.assertEqual(chains[0], step1)
        self.assertEqual(chains[1], step2)
        self.assertEqual(chains[2], step3)

    def test_exploitation_chain_relationships(self):
        """Test exploitation chain relationships"""
        chain = ExploitationChain.objects.create(**self.chain_data)

        # Test vulnerability relationship
        self.assertEqual(chain.vulnerability, self.vulnerability)

        # Test reverse relationship from vulnerability
        self.assertIn(chain, self.vulnerability.exploitation_chains.all())

    def test_exploitation_chain_impact_fields(self):
        """Test impact assessment fields"""
        chain_data = self.chain_data.copy()
        chain_data.update({
            'impact_increase': 'high',
            'final_impact_description': 'Full database access achieved through SQL injection',
            'chain_successful': True
        })

        chain = ExploitationChain.objects.create(**chain_data)

        self.assertEqual(chain.impact_increase, 'high')
        self.assertEqual(
            chain.final_impact_description,
            'Full database access achieved through SQL injection'
        )
        self.assertTrue(chain.chain_successful)

    def test_exploitation_chain_evidence_fields(self):
        """Test evidence fields"""
        chain_data = self.chain_data.copy()
        chain_data.update({
            'screenshot_path': '/evidence/chain/step1_screenshot.png',
            'request_response_log': '''Request:
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=admin%27+OR+%271%27%3D%271%27+--&password=test

Response:
HTTP/1.1 200 OK
Set-Cookie: session=abc123; HttpOnly
Location: /dashboard'''
        })

        chain = ExploitationChain.objects.create(**chain_data)

        self.assertEqual(chain.screenshot_path, '/evidence/chain/step1_screenshot.png')
        self.assertIn('POST /login HTTP/1.1', chain.request_response_log)
        self.assertIn('Location: /dashboard', chain.request_response_log)

    def test_exploitation_chain_db_table_name(self):
        """Test that the database table name is correct"""
        chain = ExploitationChain.objects.create(**self.chain_data)
        self.assertEqual(chain._meta.db_table, 'exploitation_chains')


@pytest.mark.unit
class VulnerabilityChoicesTest(TestCase):
    """Test vulnerability model choices"""

    def test_vulnerability_severity_choices(self):
        """Test VulnSeverity choices"""
        expected_choices = {
            'critical': 'Critical',
            'high': 'High',
            'medium': 'Medium',
            'low': 'Low',
            'info': 'Info'
        }

        for choice_value, choice_label in VulnSeverity.choices:
            self.assertIn(choice_value, expected_choices)
            self.assertEqual(expected_choices[choice_value], choice_label)

    def test_exploitation_difficulty_choices(self):
        """Test ExploitationDifficulty choices"""
        expected_choices = {
            'easy': 'Easy',
            'medium': 'Medium',
            'hard': 'Hard',
            'unknown': 'Unknown'
        }

        for choice_value, choice_label in ExploitationDifficulty.choices:
            self.assertIn(choice_value, expected_choices)
            self.assertEqual(expected_choices[choice_value], choice_label)

    def test_remediation_priority_choices(self):
        """Test RemediationPriority choices"""
        expected_choices = {
            'immediate': 'Immediate',
            'high': 'High',
            'medium': 'Medium',
            'low': 'Low',
            'info_only': 'Info Only'
        }

        for choice_value, choice_label in RemediationPriority.choices:
            self.assertIn(choice_value, expected_choices)
            self.assertEqual(expected_choices[choice_value], choice_label)


@pytest.mark.unit
class VulnerabilityFactoryTest(TestCase):
    """Test Vulnerability factory functionality"""

    def test_vulnerability_factory_creation(self):
        """Test that VulnerabilityFactory creates valid vulnerabilities"""
        vulnerability = VulnerabilityFactory.create()

        self.assertIsInstance(vulnerability, Vulnerability)
        self.assertIsNotNone(vulnerability.vulnerability_name)
        self.assertIsNotNone(vulnerability.vulnerability_type)
        self.assertIsNotNone(vulnerability.severity)
        self.assertIsNotNone(vulnerability.scan_session)

    def test_vulnerability_factory_realistic_data(self):
        """Test that factory generates realistic data"""
        vulnerability = VulnerabilityFactory.create()

        # CVSS score should match severity
        if vulnerability.severity == VulnSeverity.CRITICAL:
            self.assertGreaterEqual(vulnerability.cvss_score, 9.0)
        elif vulnerability.severity == VulnSeverity.HIGH:
            self.assertGreaterEqual(vulnerability.cvss_score, 7.0)
            self.assertLess(vulnerability.cvss_score, 9.0)
        elif vulnerability.severity == VulnSeverity.MEDIUM:
            self.assertGreaterEqual(vulnerability.cvss_score, 4.0)
            self.assertLess(vulnerability.cvss_score, 7.0)

        # URL should be related to scan session target
        self.assertIn(
            vulnerability.scan_session.target.main_url.split('://')[1],
            vulnerability.affected_url
        )

        # Payload should match vulnerability type
        if vulnerability.vulnerability_type == 'sql_injection':
            self.assertIn("'", vulnerability.payload_used)
        elif vulnerability.vulnerability_type == 'xss':
            self.assertIn('<script>', vulnerability.payload_used)

    def test_critical_vulnerability_factory(self):
        """Test CriticalVulnerabilityFactory trait"""
        from tests.factories import CriticalVulnerabilityFactory

        critical_vuln = CriticalVulnerabilityFactory.create()

        self.assertEqual(critical_vuln.severity, VulnSeverity.CRITICAL)
        self.assertGreaterEqual(critical_vuln.cvss_score, 9.0)
        self.assertTrue(critical_vuln.is_exploitable)
        self.assertTrue(critical_vuln.manually_verified)