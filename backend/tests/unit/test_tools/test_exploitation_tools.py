"""
Unit tests for Exploitation Tools
"""

import pytest
import asyncio
from unittest.mock import Mock, patch, AsyncMock
from django.test import TestCase
from pathlib import Path
import tempfile
import json

from tools.exploitation.initial_exploit import InitialExploit, ExploitResult
from tools.exploitation.exploit_chain import ExploitChain, ChainExecution
from tools.exploitation.exploit_results import ExploitResultsManager
from tests.factories import VulnerabilityFactory, TargetFactory
from tests.test_utils import MockToolExecutor, TestDataGenerator


@pytest.mark.unit
class InitialExploitTest(TestCase):
    """Test InitialExploit functionality"""

    def setUp(self):
        self.target_url = 'https://example.com'
        self.vulnerability_type = 'sql_injection'
        self.exploit = InitialExploit(self.target_url, self.vulnerability_type)

    @patch('aiohttp.ClientSession.post')
    def test_sql_injection_exploit(self, mock_post):
        """Test SQL injection exploitation"""
        # Mock response indicating successful injection
        mock_response = Mock()
        mock_response.status = 200
        mock_response.text = AsyncMock(return_value='Database error: syntax error near \'\'\'')
        mock_response.headers = {'Content-Type': 'text/html'}
        mock_post.return_value.__aenter__.return_value = mock_response

        # Run async test
        async def run_test():
            results = await self.exploit.exploit({
                'username': 'admin',
                'password': 'password'
            })
            return results

        results = asyncio.run(run_test())

        self.assertIsInstance(results, list)
        self.assertGreater(len(results), 0)

        # Check first result
        result = results[0]
        self.assertIsInstance(result, ExploitResult)
        self.assertEqual(result.vulnerability_type, 'sql_injection')
        self.assertIn("'", result.payload)

    @patch('aiohttp.ClientSession.get')
    def test_xss_exploit(self, mock_get):
        """Test XSS exploitation"""
        exploit = InitialExploit(self.target_url, 'xss')

        # Mock response with reflected payload
        mock_response = Mock()
        mock_response.status = 200
        mock_response.text = AsyncMock(return_value='<script>alert("XSS")</script>')
        mock_response.headers = {'Content-Type': 'text/html'}
        mock_get.return_value.__aenter__.return_value = mock_response

        async def run_test():
            results = await exploit.exploit({'search': 'test'})
            return results

        results = asyncio.run(run_test())

        self.assertGreater(len(results), 0)
        result = results[0]
        self.assertEqual(result.vulnerability_type, 'xss')
        self.assertIn('<script>', result.payload)

    @patch('aiohttp.ClientSession.post')
    def test_command_injection_exploit(self, mock_post):
        """Test command injection exploitation"""
        exploit = InitialExploit(self.target_url, 'command_injection')

        # Mock response with command output
        mock_response = Mock()
        mock_response.status = 200
        mock_response.text = AsyncMock(return_value='uid=33(www-data) gid=33(www-data)')
        mock_response.headers = {'Content-Type': 'text/plain'}
        mock_post.return_value.__aenter__.return_value = mock_response

        async def run_test():
            results = await exploit.exploit({'cmd': 'test'})
            return results

        results = asyncio.run(run_test())

        self.assertGreater(len(results), 0)
        result = results[0]
        self.assertEqual(result.vulnerability_type, 'command_injection')
        self.assertTrue(result.success)

    def test_payload_generation(self):
        """Test payload generation for different vulnerability types"""
        # SQL Injection payloads
        sql_exploit = InitialExploit(self.target_url, 'sql_injection')
        sql_payloads = sql_exploit._generate_payloads({'username': 'admin'})

        self.assertGreater(len(sql_payloads), 0)
        self.assertTrue(any("'" in payload for payload in sql_payloads))
        self.assertTrue(any("OR" in payload for payload in sql_payloads))

        # XSS payloads
        xss_exploit = InitialExploit(self.target_url, 'xss')
        xss_payloads = xss_exploit._generate_payloads({'search': 'test'})

        self.assertGreater(len(xss_payloads), 0)
        self.assertTrue(any("<script>" in payload for payload in xss_payloads))
        self.assertTrue(any("alert" in payload for payload in xss_payloads))

    def test_evidence_collection(self):
        """Test evidence collection during exploitation"""
        with tempfile.TemporaryDirectory() as temp_dir:
            exploit = InitialExploit(self.target_url, 'sql_injection')
            exploit.evidence_dir = Path(temp_dir)

            # Mock successful exploitation
            result = ExploitResult(
                vulnerability_type='sql_injection',
                target_url=self.target_url,
                payload="admin' OR '1'='1' --",
                success=True,
                response_data={'status_code': 200, 'body': 'Welcome admin'},
                evidence={}
            )

            evidence_path = exploit._collect_evidence(result)

            self.assertIsNotNone(evidence_path)
            self.assertTrue(evidence_path.exists())

    def test_rate_limiting(self):
        """Test rate limiting compliance"""
        exploit = InitialExploit(self.target_url, 'sql_injection')
        exploit.requests_per_second = 2.0
        exploit.request_delay = 0.5

        # Test that delays are calculated correctly
        delay = exploit._calculate_request_delay()
        self.assertGreaterEqual(delay, 0.5)

    @patch('aiohttp.ClientSession.post')
    def test_error_handling(self, mock_post):
        """Test error handling during exploitation"""
        # Mock network error
        mock_post.side_effect = Exception("Network error")

        async def run_test():
            results = await self.exploit.exploit({'username': 'admin'})
            return results

        results = asyncio.run(run_test())

        # Should handle errors gracefully
        self.assertIsInstance(results, list)
        # May have partial results or error results


@pytest.mark.unit
class ExploitChainTest(TestCase):
    """Test ExploitChain functionality"""

    def setUp(self):
        self.target_url = 'https://example.com'
        self.chain_config = {
            'name': 'SQL Injection to RCE',
            'description': 'Chain SQL injection to achieve RCE',
            'steps': [
                {
                    'type': 'sql_injection',
                    'description': 'Exploit SQL injection',
                    'parameters': {'endpoint': '/login'}
                },
                {
                    'type': 'file_upload',
                    'description': 'Upload web shell',
                    'parameters': {'upload_endpoint': '/admin/upload'}
                },
                {
                    'type': 'command_injection',
                    'description': 'Execute commands',
                    'parameters': {'shell_path': '/uploads/shell.php'}
                }
            ]
        }
        self.exploit_chain = ExploitChain(self.target_url, self.chain_config)

    @patch('tools.exploitation.initial_exploit.InitialExploit.exploit')
    def test_chain_execution(self, mock_exploit):
        """Test complete chain execution"""
        # Mock successful results for each step
        mock_exploit.side_effect = [
            # SQL injection results
            [ExploitResult(
                vulnerability_type='sql_injection',
                target_url=self.target_url,
                payload="admin' OR '1'='1' --",
                success=True,
                response_data={'admin_access': True}
            )],
            # File upload results
            [ExploitResult(
                vulnerability_type='file_upload',
                target_url=self.target_url,
                payload='<?php system($_GET["cmd"]); ?>',
                success=True,
                response_data={'file_uploaded': '/uploads/shell.php'}
            )],
            # Command injection results
            [ExploitResult(
                vulnerability_type='command_injection',
                target_url=self.target_url,
                payload='whoami',
                success=True,
                response_data={'command_output': 'www-data'}
            )]
        ]

        async def run_test():
            execution = await self.exploit_chain.execute_chain()
            return execution

        execution = asyncio.run(run_test())

        self.assertIsInstance(execution, ChainExecution)
        self.assertTrue(execution.success)
        self.assertEqual(len(execution.step_results), 3)
        self.assertTrue(all(step.success for step in execution.step_results))

    @patch('tools.exploitation.initial_exploit.InitialExploit.exploit')
    def test_chain_failure_handling(self, mock_exploit):
        """Test chain failure and recovery"""
        # Mock first step failure
        mock_exploit.side_effect = [
            # SQL injection fails
            [ExploitResult(
                vulnerability_type='sql_injection',
                target_url=self.target_url,
                payload="admin' OR '1'='1' --",
                success=False,
                error='Access denied'
            )]
        ]

        async def run_test():
            execution = await self.exploit_chain.execute_chain()
            return execution

        execution = asyncio.run(run_test())

        self.assertFalse(execution.success)
        self.assertEqual(len(execution.step_results), 1)
        self.assertFalse(execution.step_results[0].success)

    def test_prerequisite_checking(self):
        """Test prerequisite checking between steps"""
        # Add prerequisites to chain config
        self.chain_config['steps'][1]['prerequisites'] = ['admin_access']
        self.chain_config['steps'][2]['prerequisites'] = ['file_uploaded']

        chain = ExploitChain(self.target_url, self.chain_config)

        # Mock context with missing prerequisite
        context = {'sql_injection_success': True}

        can_execute = chain._check_prerequisites(1, context)
        self.assertFalse(can_execute)  # Missing admin_access

        # Add prerequisite
        context['admin_access'] = True
        can_execute = chain._check_prerequisites(1, context)
        self.assertTrue(can_execute)

    def test_context_sharing(self):
        """Test context sharing between chain steps"""
        chain = ExploitChain(self.target_url, self.chain_config)

        # First step result with context
        step1_result = ExploitResult(
            vulnerability_type='sql_injection',
            target_url=self.target_url,
            payload="admin' OR '1'='1' --",
            success=True,
            response_data={'session_id': 'abc123', 'admin_access': True}
        )

        context = chain._extract_context(step1_result)

        self.assertIn('session_id', context)
        self.assertIn('admin_access', context)
        self.assertEqual(context['session_id'], 'abc123')
        self.assertTrue(context['admin_access'])

    def test_chain_step_validation(self):
        """Test validation of chain step configuration"""
        # Valid configuration
        self.assertTrue(self.exploit_chain._validate_chain_config())

        # Invalid configuration - missing required fields
        invalid_config = {
            'name': 'Invalid Chain',
            'steps': [
                {'type': 'sql_injection'}  # Missing description
            ]
        }

        invalid_chain = ExploitChain(self.target_url, invalid_config)
        self.assertFalse(invalid_chain._validate_chain_config())


@pytest.mark.unit
class ExploitResultsManagerTest(TestCase):
    """Test ExploitResultsManager functionality"""

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.results_manager = ExploitResultsManager(self.temp_dir)

    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def test_result_storage(self):
        """Test storing exploitation results"""
        result = ExploitResult(
            vulnerability_type='sql_injection',
            target_url='https://example.com',
            payload="admin' OR '1'='1' --",
            success=True,
            response_data={'status_code': 200}
        )

        result_id = self.results_manager.store_result(result)

        self.assertIsNotNone(result_id)

        # Verify result can be retrieved
        stored_result = self.results_manager.get_result(result_id)
        self.assertIsNotNone(stored_result)
        self.assertEqual(stored_result.vulnerability_type, 'sql_injection')

    def test_result_querying(self):
        """Test querying stored results"""
        # Store multiple results
        results = [
            ExploitResult(
                vulnerability_type='sql_injection',
                target_url='https://example.com',
                payload="payload1",
                success=True
            ),
            ExploitResult(
                vulnerability_type='xss',
                target_url='https://example.com',
                payload="payload2",
                success=False
            ),
            ExploitResult(
                vulnerability_type='sql_injection',
                target_url='https://other.com',
                payload="payload3",
                success=True
            )
        ]

        for result in results:
            self.results_manager.store_result(result)

        # Query by vulnerability type
        sql_results = self.results_manager.query_results(
            vulnerability_type='sql_injection'
        )
        self.assertEqual(len(sql_results), 2)

        # Query by success status
        successful_results = self.results_manager.query_results(success=True)
        self.assertEqual(len(successful_results), 2)

        # Query by target URL
        example_results = self.results_manager.query_results(
            target_url='https://example.com'
        )
        self.assertEqual(len(example_results), 2)

    def test_result_analysis(self):
        """Test result analysis and statistics"""
        # Store results with different success rates
        results = [
            ExploitResult(vulnerability_type='sql_injection', success=True),
            ExploitResult(vulnerability_type='sql_injection', success=True),
            ExploitResult(vulnerability_type='sql_injection', success=False),
            ExploitResult(vulnerability_type='xss', success=True),
            ExploitResult(vulnerability_type='xss', success=False),
        ]

        for result in results:
            self.results_manager.store_result(result)

        stats = self.results_manager.get_statistics()

        self.assertEqual(stats['total_attempts'], 5)
        self.assertEqual(stats['successful_attempts'], 3)
        self.assertEqual(stats['success_rate'], 0.6)

        # Check vulnerability type breakdown
        self.assertIn('sql_injection', stats['by_vulnerability_type'])
        self.assertEqual(
            stats['by_vulnerability_type']['sql_injection']['total'], 3
        )
        self.assertEqual(
            stats['by_vulnerability_type']['sql_injection']['successful'], 2
        )

    def test_risk_scoring(self):
        """Test risk scoring for exploitation results"""
        # High-risk result
        high_risk_result = ExploitResult(
            vulnerability_type='command_injection',
            target_url='https://example.com',
            payload='whoami',
            success=True,
            response_data={'command_output': 'root'}
        )

        risk_score = self.results_manager.calculate_risk_score(high_risk_result)
        self.assertGreater(risk_score, 7.0)  # Should be high risk

        # Low-risk result
        low_risk_result = ExploitResult(
            vulnerability_type='information_disclosure',
            target_url='https://example.com',
            payload='info_request',
            success=True,
            response_data={'info': 'version number'}
        )

        risk_score = self.results_manager.calculate_risk_score(low_risk_result)
        self.assertLess(risk_score, 5.0)  # Should be lower risk

    def test_result_export(self):
        """Test exporting results to different formats"""
        # Store test results
        result = ExploitResult(
            vulnerability_type='sql_injection',
            target_url='https://example.com',
            payload="admin' OR '1'='1' --",
            success=True,
            timestamp='2023-10-01T12:00:00Z'
        )

        self.results_manager.store_result(result)

        # Export to JSON
        json_data = self.results_manager.export_results('json')
        self.assertIsInstance(json_data, str)
        parsed_data = json.loads(json_data)
        self.assertIn('results', parsed_data)
        self.assertEqual(len(parsed_data['results']), 1)

        # Export to CSV
        csv_data = self.results_manager.export_results('csv')
        self.assertIsInstance(csv_data, str)
        self.assertIn('vulnerability_type', csv_data)
        self.assertIn('sql_injection', csv_data)

    def test_evidence_management(self):
        """Test evidence file management"""
        result = ExploitResult(
            vulnerability_type='sql_injection',
            target_url='https://example.com',
            payload="test",
            success=True
        )

        # Add evidence files
        evidence_data = b"Screenshot evidence data"
        evidence_path = self.results_manager.store_evidence(
            result, 'screenshot.png', evidence_data
        )

        self.assertTrue(Path(evidence_path).exists())

        # Verify evidence is linked to result
        result_id = self.results_manager.store_result(result)
        stored_result = self.results_manager.get_result(result_id)

        # Evidence should be referenced in result
        self.assertIsNotNone(stored_result.evidence)

    def test_cleanup_old_results(self):
        """Test cleanup of old results"""
        # Store results with old timestamps
        old_result = ExploitResult(
            vulnerability_type='sql_injection',
            target_url='https://example.com',
            payload="old",
            success=True,
            timestamp='2023-01-01T12:00:00Z'
        )

        recent_result = ExploitResult(
            vulnerability_type='xss',
            target_url='https://example.com',
            payload="recent",
            success=True,
            timestamp='2023-10-01T12:00:00Z'
        )

        self.results_manager.store_result(old_result)
        self.results_manager.store_result(recent_result)

        # Cleanup results older than 6 months
        cleaned_count = self.results_manager.cleanup_old_results(days=180)

        self.assertEqual(cleaned_count, 1)  # Should remove old result

        # Verify only recent result remains
        all_results = self.results_manager.query_results()
        self.assertEqual(len(all_results), 1)
        self.assertEqual(all_results[0].payload, "recent")


@pytest.mark.unit
class ExploitationToolIntegrationTest(TestCase):
    """Integration tests for exploitation tools"""

    def setUp(self):
        self.vulnerability = VulnerabilityFactory.create(
            vulnerability_type='sql_injection',
            affected_url='https://example.com/login',
            affected_parameter='username'
        )
        self.target = self.vulnerability.scan_session.target

    @patch('aiohttp.ClientSession.post')
    def test_end_to_end_exploitation(self, mock_post):
        """Test complete exploitation workflow"""
        # Mock successful SQL injection
        mock_response = Mock()
        mock_response.status = 200
        mock_response.text = AsyncMock(return_value='Welcome administrator')
        mock_post.return_value.__aenter__.return_value = mock_response

        async def run_test():
            # Initialize exploitation
            exploit = InitialExploit(
                self.vulnerability.affected_url,
                self.vulnerability.vulnerability_type
            )

            # Run exploitation
            results = await exploit.exploit({
                self.vulnerability.affected_parameter: 'admin'
            })

            # Store results
            with tempfile.TemporaryDirectory() as temp_dir:
                results_manager = ExploitResultsManager(temp_dir)

                for result in results:
                    results_manager.store_result(result)

                # Analyze results
                stats = results_manager.get_statistics()

                return stats, results

        stats, results = asyncio.run(run_test())

        self.assertGreater(len(results), 0)
        self.assertGreater(stats['total_attempts'], 0)

    def test_tool_error_recovery(self):
        """Test tool error recovery and fallback mechanisms"""
        exploit = InitialExploit(
            'https://unreachable.invalid',
            'sql_injection'
        )

        async def run_test():
            try:
                results = await exploit.exploit({'username': 'test'})
                return results
            except Exception as e:
                return str(e)

        result = asyncio.run(run_test())

        # Should handle errors gracefully
        self.assertIsNotNone(result)