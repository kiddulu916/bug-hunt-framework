"""
Test suite for Vulnerability ViewSets
"""

import pytest
import uuid
from datetime import datetime, timedelta
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from unittest.mock import Mock, patch, AsyncMock

from app.main import app
from app.database import get_db, Base
from app.models import (
    Target, ScanSession, Vulnerability,
    VulnSeverity, ScanStatus, BugBountyPlatform,
    ExploitationChain
)
from app.views.vulnerability_views import VulnerabilityViewSet


# Test database setup
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base.metadata.create_all(bind=engine)


def override_get_db():
    """Override database dependency for testing"""
    try:
        db = TestingSessionLocal()
        yield db
    finally:
        db.close()


app.dependency_overrides[get_db] = override_get_db
client = TestClient(app)


# Fixtures
@pytest.fixture
def test_db():
    """Provide test database session"""
    db = TestingSessionLocal()
    yield db
    db.close()


@pytest.fixture
def test_target(test_db):
    """Create test target"""
    target = Target(
        id=uuid.uuid4(),
        target_name="Test Target",
        platform=BugBountyPlatform.HACKERONE,
        researcher_username="test_researcher",
        main_url="https://example.com",
        in_scope_urls=["https://example.com/*", "https://api.example.com/*"],
        out_of_scope_urls=["https://blog.example.com/*"],
        is_active=True
    )
    test_db.add(target)
    test_db.commit()
    return target


@pytest.fixture
def test_scan_session(test_db, test_target):
    """Create test scan session"""
    scan_session = ScanSession(
        id=uuid.uuid4(),
        target_id=test_target.id,
        session_name="Test Scan Session",
        status=ScanStatus.RUNNING,
        started_at=datetime.utcnow()
    )
    test_db.add(scan_session)
    test_db.commit()
    return scan_session


@pytest.fixture
def test_vulnerabilities(test_db, test_scan_session):
    """Create test vulnerabilities"""
    vulnerabilities = []

    severity_levels = [
        VulnSeverity.CRITICAL,
        VulnSeverity.HIGH,
        VulnSeverity.MEDIUM,
        VulnSeverity.LOW,
        VulnSeverity.INFO
    ]

    for i, severity in enumerate(severity_levels):
        vuln = Vulnerability(
            id=uuid.uuid4(),
            scan_session_id=test_scan_session.id,
            vulnerability_name=f"Test Vulnerability {i+1}",
            vulnerability_type=["sqli", "xss", "rce", "csrf", "info"][i],
            severity=severity,
            cvss_score=[9.8, 7.5, 5.3, 3.1, 0.0][i],
            impact_description=f"This is a {severity.value} severity vulnerability",
            affected_url=f"https://example.com/page{i+1}",
            discovered_by_tool="test_scanner",
            discovery_method="automated_scan",
            confidence_level=0.9,
            manually_verified=(i < 2),  # First two are verified
            is_exploitable=(i < 3)  # First three are exploitable
        )
        test_db.add(vuln)
        vulnerabilities.append(vuln)

    test_db.commit()
    return vulnerabilities


@pytest.fixture
def auth_headers():
    """Mock authentication headers"""
    return {"Authorization": "Bearer test_token"}


# Test Cases

class TestVulnerabilityList:
    """Test vulnerability listing endpoints"""

    def test_list_vulnerabilities_success(self, test_vulnerabilities, auth_headers):
        """Test successful vulnerability listing"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get("/api/v1/vulnerabilities/", headers=auth_headers)

        assert response.status_code == 200
        data = response.json()
        assert "items" in data
        assert "total" in data
        assert data["total"] == len(test_vulnerabilities)
        assert len(data["items"]) == len(test_vulnerabilities)

    def test_list_vulnerabilities_with_pagination(self, test_vulnerabilities, auth_headers):
        """Test vulnerability listing with pagination"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/?page=1&page_size=2",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert len(data["items"]) == 2
        assert data["page"] == 1
        assert data["page_size"] == 2
        assert data["total_pages"] == 3

    def test_list_vulnerabilities_filter_by_severity(self, test_vulnerabilities, auth_headers):
        """Test filtering vulnerabilities by severity"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/?severity=critical&severity=high",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 2
        for item in data["items"]:
            assert item["severity"] in ["critical", "high"]

    def test_list_vulnerabilities_filter_by_verified(self, test_vulnerabilities, auth_headers):
        """Test filtering by verification status"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/?manually_verified=true",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 2
        for item in data["items"]:
            assert item["manually_verified"] is True

    def test_list_vulnerabilities_search(self, test_vulnerabilities, auth_headers):
        """Test searching vulnerabilities"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/?search=sqli",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["total"] >= 1


class TestVulnerabilityStatistics:
    """Test vulnerability statistics endpoints"""

    def test_get_statistics_success(self, test_vulnerabilities, auth_headers):
        """Test getting vulnerability statistics"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get("/api/v1/vulnerabilities/statistics", headers=auth_headers)

        assert response.status_code == 200
        data = response.json()
        assert "total_vulnerabilities" in data
        assert "severity_distribution" in data
        assert "type_distribution" in data
        assert data["total_vulnerabilities"] == len(test_vulnerabilities)

    def test_get_statistics_with_date_filter(self, test_vulnerabilities, auth_headers):
        """Test statistics with date filtering"""
        date_from = (datetime.utcnow() - timedelta(days=7)).isoformat()

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                f"/api/v1/vulnerabilities/statistics?date_from={date_from}",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert "total_vulnerabilities" in data


class TestVulnerabilityDetail:
    """Test vulnerability detail endpoints"""

    def test_get_vulnerability_success(self, test_vulnerabilities, auth_headers):
        """Test getting vulnerability details"""
        vuln_id = test_vulnerabilities[0].id

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(f"/api/v1/vulnerabilities/{vuln_id}", headers=auth_headers)

        assert response.status_code == 200
        data = response.json()
        assert data["id"] == str(vuln_id)
        assert "target_info" in data
        assert "exploitation_chains" in data

    def test_get_vulnerability_not_found(self, auth_headers):
        """Test getting non-existent vulnerability"""
        fake_id = uuid.uuid4()

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(f"/api/v1/vulnerabilities/{fake_id}", headers=auth_headers)

        assert response.status_code == 404


class TestVulnerabilityCreate:
    """Test vulnerability creation endpoints"""

    def test_create_vulnerability_success(self, test_scan_session, auth_headers):
        """Test creating new vulnerability"""
        vuln_data = {
            "scan_session_id": str(test_scan_session.id),
            "vulnerability_name": "New SQL Injection",
            "vulnerability_type": "sqli",
            "severity": "high",
            "cvss_score": 8.5,
            "impact_description": "Allows database access",
            "affected_url": "https://example.com/login",
            "affected_parameter": "username",
            "discovered_by_tool": "sqlmap",
            "discovery_method": "automated",
            "confidence_level": 0.95
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            with patch('app.services.notification_service.NotificationService.send_high_severity_alert', new_callable=AsyncMock):
                response = client.post(
                    "/api/v1/vulnerabilities/",
                    json=vuln_data,
                    headers=auth_headers
                )

        assert response.status_code == 201
        data = response.json()
        assert data["vulnerability_name"] == vuln_data["vulnerability_name"]
        assert data["severity"] == vuln_data["severity"]

    def test_create_vulnerability_invalid_scan_session(self, auth_headers):
        """Test creating vulnerability with invalid scan session"""
        vuln_data = {
            "scan_session_id": str(uuid.uuid4()),
            "vulnerability_name": "Test Vulnerability",
            "vulnerability_type": "xss",
            "severity": "medium",
            "impact_description": "Test impact",
            "affected_url": "https://example.com",
            "discovered_by_tool": "test",
            "discovery_method": "test"
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                "/api/v1/vulnerabilities/",
                json=vuln_data,
                headers=auth_headers
            )

        assert response.status_code == 404


class TestVulnerabilityUpdate:
    """Test vulnerability update endpoints"""

    def test_update_vulnerability_success(self, test_vulnerabilities, auth_headers):
        """Test updating vulnerability"""
        vuln_id = test_vulnerabilities[0].id
        update_data = {
            "severity": "critical",
            "cvss_score": 9.9,
            "manually_verified": True,
            "verification_notes": "Confirmed through manual testing"
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.put(
                f"/api/v1/vulnerabilities/{vuln_id}",
                json=update_data,
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["severity"] == "critical"
        assert data["cvss_score"] == 9.9
        assert data["manually_verified"] is True

    def test_update_vulnerability_not_found(self, auth_headers):
        """Test updating non-existent vulnerability"""
        fake_id = uuid.uuid4()
        update_data = {"severity": "high"}

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.put(
                f"/api/v1/vulnerabilities/{fake_id}",
                json=update_data,
                headers=auth_headers
            )

        assert response.status_code == 404

    def test_verify_vulnerability(self, test_vulnerabilities, auth_headers):
        """Test vulnerability verification"""
        vuln_id = test_vulnerabilities[2].id  # Unverified vulnerability

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.patch(
                f"/api/v1/vulnerabilities/{vuln_id}/verify",
                params={"verification_notes": "Verified through proof of concept"},
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["verified"] is True


class TestVulnerabilityEvidence:
    """Test evidence upload endpoints"""

    @patch('app.utils.evidence_handler.EvidenceHandler.save_evidence')
    async def test_upload_evidence_success(self, mock_save, test_vulnerabilities, auth_headers):
        """Test uploading evidence files"""
        vuln_id = test_vulnerabilities[0].id
        mock_save.return_value = f"{vuln_id}/screenshot/test_screenshot.png"

        files = [
            ("files", ("screenshot.png", b"fake image data", "image/png"))
        ]

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                f"/api/v1/vulnerabilities/{vuln_id}/evidence",
                files=files,
                params={"evidence_type": "screenshot"},
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["files_uploaded"] == 1
        assert len(data["paths"]) == 1

    def test_upload_evidence_invalid_file_type(self, test_vulnerabilities, auth_headers):
        """Test uploading invalid file type"""
        vuln_id = test_vulnerabilities[0].id

        files = [
            ("files", ("malware.exe", b"fake exe data", "application/x-msdownload"))
        ]

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                f"/api/v1/vulnerabilities/{vuln_id}/evidence",
                files=files,
                params={"evidence_type": "screenshot"},
                headers=auth_headers
            )

        assert response.status_code == 400


class TestExploitationChain:
    """Test exploitation chain endpoints"""

    def test_add_exploitation_chain_success(self, test_vulnerabilities, test_db, auth_headers):
        """Test adding exploitation chain"""
        vuln_id = test_vulnerabilities[0].id
        chain_data = {
            "chain_name": "SQL to RCE Chain",
            "chain_description": "Escalate from SQL injection to remote code execution",
            "step_number": 1,
            "total_steps": 3,
            "step_description": "Extract database credentials",
            "payload": "' UNION SELECT password FROM users--",
            "step_successful": True,
            "chain_successful": False,
            "impact_increase": "high",
            "exploitation_difficulty": "medium"
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                f"/api/v1/vulnerabilities/{vuln_id}/exploitation-chain",
                json=chain_data,
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["chain_name"] == chain_data["chain_name"]
        assert data["vulnerability_id"] == str(vuln_id)


class TestBulkOperations:
    """Test bulk operation endpoints"""

    def test_bulk_update_vulnerabilities(self, test_vulnerabilities, auth_headers):
        """Test bulk updating vulnerabilities"""
        vuln_ids = [str(v.id) for v in test_vulnerabilities[:3]]
        bulk_data = {
            "vulnerability_ids": vuln_ids,
            "update_data": {
                "remediation_priority": "urgent",
                "manually_verified": True
            }
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                "/api/v1/vulnerabilities/bulk-update",
                json=bulk_data,
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["updated_count"] == 3

    def test_bulk_update_invalid_ids(self, auth_headers):
        """Test bulk update with invalid IDs"""
        bulk_data = {
            "vulnerability_ids": [str(uuid.uuid4()) for _ in range(3)],
            "update_data": {"severity": "high"}
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.post(
                "/api/v1/vulnerabilities/bulk-update",
                json=bulk_data,
                headers=auth_headers
            )

        assert response.status_code == 404


class TestVulnerabilityDelete:
    """Test vulnerability deletion endpoints"""

    def test_delete_vulnerability_success(self, test_vulnerabilities, test_db, auth_headers):
        """Test deleting vulnerability"""
        vuln_id = test_vulnerabilities[-1].id  # Delete the last one

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.delete(
                f"/api/v1/vulnerabilities/{vuln_id}",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert data["vulnerability_id"] == str(vuln_id)

        # Verify deletion
        deleted_vuln = test_db.query(Vulnerability).filter(
            Vulnerability.id == vuln_id
        ).first()
        assert deleted_vuln is None

    def test_delete_vulnerability_not_found(self, auth_headers):
        """Test deleting non-existent vulnerability"""
        fake_id = uuid.uuid4()

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.delete(
                f"/api/v1/vulnerabilities/{fake_id}",
                headers=auth_headers
            )

        assert response.status_code == 404


class TestVulnerabilityExport:
    """Test vulnerability export endpoints"""

    @patch('app.services.reporting_service.ReportingService.generate_csv_report')
    def test_export_csv(self, mock_csv, test_vulnerabilities, auth_headers):
        """Test exporting vulnerabilities as CSV"""
        import io
        mock_csv.return_value = io.StringIO("id,name,severity\n1,Test,High")

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/export/csv",
                headers=auth_headers
            )

        assert response.status_code == 200
        assert response.headers["content-type"] == "text/csv"

    @patch('app.services.reporting_service.ReportingService.generate_json_report')
    def test_export_json(self, mock_json, test_vulnerabilities, auth_headers):
        """Test exporting vulnerabilities as JSON"""
        mock_json.return_value = {
            "vulnerabilities": [],
            "total": 0
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/export/json",
                headers=auth_headers
            )

        assert response.status_code == 200
        assert response.headers["content-type"] == "application/json"

    @patch('app.services.reporting_service.ReportingService.generate_pdf_report')
    async def test_export_pdf(self, mock_pdf, test_vulnerabilities, auth_headers):
        """Test exporting vulnerabilities as PDF"""
        import io
        mock_pdf.return_value = io.BytesIO(b"fake pdf content")

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/export/pdf",
                headers=auth_headers
            )

        assert response.status_code == 200
        assert response.headers["content-type"] == "application/pdf"

    def test_export_invalid_format(self, auth_headers):
        """Test exporting with invalid format"""
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                "/api/v1/vulnerabilities/export/invalid",
                headers=auth_headers
            )

        assert response.status_code == 400


class TestRemediationSuggestions:
    """Test remediation suggestion endpoints"""

    @patch('app.utils.vulnerability_analyzer.VulnerabilityAnalyzer.generate_remediation_suggestions')
    async def test_get_remediation_suggestions(self, mock_suggestions, test_vulnerabilities, auth_headers):
        """Test getting remediation suggestions"""
        vuln_id = test_vulnerabilities[0].id
        mock_suggestions.return_value = [
            {
                "title": "Use Parameterized Queries",
                "description": "Implement parameterized queries to prevent SQL injection",
                "priority": "urgent"
            }
        ]

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            response = client.get(
                f"/api/v1/vulnerabilities/remediation-suggestions/{vuln_id}",
                headers=auth_headers
            )

        assert response.status_code == 200
        data = response.json()
        assert "remediation_suggestions" in data
        assert len(data["remediation_suggestions"]) > 0
        assert "estimated_effort" in data
        assert "references" in data


class TestVulnerabilityAnalysis:
    """Test vulnerability analysis functionality"""

    def test_calculate_risk_score(self):
        """Test risk score calculation"""
        analyzer = VulnerabilityAnalyzer()

        # Create mock vulnerability
        vuln = Mock()
        vuln.cvss_score = 7.5
        vuln.is_exploitable = True
        vuln.manually_verified = True
        vuln.false_positive_likelihood = 0.1

        risk_score = analyzer._calculate_risk_score(vuln)

        # Should be increased due to exploitability and verification
        assert risk_score > 7.5
        assert risk_score <= 10.0

    def test_analyze_attack_vector(self):
        """Test attack vector analysis"""
        analyzer = VulnerabilityAnalyzer()

        vuln = Mock()
        vuln.cvss_vector = "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"

        vector_analysis = analyzer._analyze_attack_vector(vuln)

        assert vector_analysis["vector_type"] == "network"
        assert vector_analysis["remote_exploitable"] is True
        assert vector_analysis["requires_authentication"] is False
        assert vector_analysis["requires_user_interaction"] is False

    def test_assess_potential_impact(self):
        """Test impact assessment"""
        analyzer = VulnerabilityAnalyzer()

        # Test SQL injection impact
        vuln = Mock()
        vuln.vulnerability_type = "sqli"

        impact = analyzer._assess_potential_impact(vuln)

        assert impact["confidentiality"] == "high"
        assert impact["integrity"] == "high"
        assert impact["data_exposure_risk"] is True

    def test_cvss_calculation(self):
        """Test CVSS score calculation"""
        calculator = CVSSCalculator()

        # Test with known CVSS vector
        vector = "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        score = calculator.calculate(vector)

        assert score > 0
        assert score <= 10.0

    def test_evidence_validation(self):
        """Test evidence file validation"""
        handler = EvidenceHandler()

        # Test valid screenshot extension
        assert handler.validate_file_type("screenshot.png", "screenshot") is True
        assert handler.validate_file_type("screenshot.jpg", "screenshot") is True

        # Test invalid extension
        assert handler.validate_file_type("malware.exe", "screenshot") is False
        assert handler.validate_file_type("document.pdf", "screenshot") is False

        # Test valid request file
        assert handler.validate_file_type("request.txt", "request") is True
        assert handler.validate_file_type("request.json", "request") is True


# Integration Tests
class TestVulnerabilityWorkflow:
    """Test complete vulnerability workflow"""

    def test_complete_vulnerability_lifecycle(self, test_scan_session, test_db, auth_headers):
        """Test creating, updating, verifying, and deleting vulnerability"""

        # 1. Create vulnerability
        vuln_data = {
            "scan_session_id": str(test_scan_session.id),
            "vulnerability_name": "Lifecycle Test Vulnerability",
            "vulnerability_type": "xss",
            "severity": "medium",
            "impact_description": "Allows script injection",
            "affected_url": "https://example.com/search",
            "discovered_by_tool": "test_scanner",
            "discovery_method": "automated",
            "confidence_level": 0.8
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            create_response = client.post(
                "/api/v1/vulnerabilities/",
                json=vuln_data,
                headers=auth_headers
            )

        assert create_response.status_code == 201
        created_vuln = create_response.json()
        vuln_id = created_vuln["id"]

        # 2. Update vulnerability
        update_data = {
            "severity": "high",
            "cvss_score": 7.5
        }

        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            update_response = client.put(
                f"/api/v1/vulnerabilities/{vuln_id}",
                json=update_data,
                headers=auth_headers
            )

        assert update_response.status_code == 200
        updated_vuln = update_response.json()
        assert updated_vuln["severity"] == "high"

        # 3. Verify vulnerability
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            verify_response = client.patch(
                f"/api/v1/vulnerabilities/{vuln_id}/verify",
                params={"verification_notes": "Manually confirmed"},
                headers=auth_headers
            )

        assert verify_response.status_code == 200

        # 4. Get vulnerability details
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            detail_response = client.get(
                f"/api/v1/vulnerabilities/{vuln_id}",
                headers=auth_headers
            )

        assert detail_response.status_code == 200
        details = detail_response.json()
        assert details["manually_verified"] is True

        # 5. Delete vulnerability
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            delete_response = client.delete(
                f"/api/v1/vulnerabilities/{vuln_id}",
                headers=auth_headers
            )

        assert delete_response.status_code == 200

        # 6. Verify deletion
        with patch('app.core.security.get_current_user', return_value={'id': 'test_user'}):
            get_deleted_response = client.get(
                f"/api/v1/vulnerabilities/{vuln_id}",
                headers=auth_headers
            )

        assert get_deleted_response.status_code == 404
