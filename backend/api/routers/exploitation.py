"""
FastAPI router for exploitation endpoints
"""

from typing import List, Optional, Dict, Any
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, Query, BackgroundTasks
from sqlalchemy.orm import Session

from backend.core.database import get_db
from backend.api.schemas.exploitation import (
    ExploitationConfigSchema, ExploitationResultSchema, ExploitationChainSchema,
    ExploitationChainCreate, ExploitationStatusSchema, ExploitationHistorySchema,
    VulnerabilityExploitRequest, ExploitationImpactAnalysis
)
from backend.models import (
    Vulnerability, ExploitationChain, ScanSession, Target,
    VulnSeverity
)
from backend.services.exploitation_service import ExploitationService, ExploitationResult
from backend.api.dependencies import get_current_user


router = APIRouter(prefix="/api/v1/exploitation", tags=["exploitation"])
exploitation_service = ExploitationService()


@router.post("/vulnerability/{vulnerability_id}/exploit")
async def exploit_vulnerability(
    vulnerability_id: UUID,
    exploit_request: VulnerabilityExploitRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Exploit a specific vulnerability"""
    
    # Verify vulnerability exists and user has access
    vulnerability = db.query(Vulnerability).filter(
        Vulnerability.id == vulnerability_id
    ).first()
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    # Check if user owns this target
    if vulnerability.scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Check if already being exploited
    if vulnerability.exploitation_notes:
        import json
        try:
            notes = json.loads(vulnerability.exploitation_notes)
            if notes.get("status") == "running":
                raise HTTPException(status_code=409, detail="Exploitation already in progress")
        except json.JSONDecodeError:
            pass
    
    # Start exploitation in background
    if exploit_request.async_execution:
        background_tasks.add_task(
            exploitation_service.exploit_vulnerability_async.delay,
            str(vulnerability_id)
        )
        
        return {
            "message": "Exploitation started in background",
            "vulnerability_id": str(vulnerability_id),
            "async": True
        }
    else:
        # Synchronous exploitation
        try:
            result = await exploitation_service.exploit_vulnerability(str(vulnerability_id))
            
            return {
                "message": "Exploitation completed",
                "vulnerability_id": str(vulnerability_id),
                "result": result.value,
                "async": False
            }
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Exploitation failed: {str(e)}")


@router.post("/chain/create", response_model=Dict[str, Any])
async def create_exploitation_chain(
    chain_request: ExploitationChainCreate,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Create and execute an exploitation chain"""
    
    # Verify all vulnerabilities exist and belong to user
    vulnerabilities = db.query(Vulnerability).filter(
        Vulnerability.id.in_(chain_request.vulnerability_ids)
    ).all()
    
    if len(vulnerabilities) != len(chain_request.vulnerability_ids):
        raise HTTPException(status_code=404, detail="Some vulnerabilities not found")
    
    # Check access to all vulnerabilities
    for vuln in vulnerabilities:
        if vuln.scan_session.target.researcher_username != current_user["username"]:
            raise HTTPException(status_code=403, detail="Access denied to one or more vulnerabilities")
    
    # Verify all vulnerabilities belong to same scan session
    scan_sessions = set(v.scan_session_id for v in vulnerabilities)
    if len(scan_sessions) > 1:
        raise HTTPException(
            status_code=400, 
            detail="All vulnerabilities must belong to the same scan session"
        )
    
    # Create exploitation chain
    try:
        chain_id = await exploitation_service.create_exploitation_chain(
            [str(vid) for vid in chain_request.vulnerability_ids],
            chain_request.chain_name,
            chain_request.chain_description
        )
        
        return {
            "message": "Exploitation chain created and executed",
            "chain_id": chain_id,
            "chain_name": chain_request.chain_name,
            "total_vulnerabilities": len(chain_request.vulnerability_ids)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chain creation failed: {str(e)}")


@router.get("/vulnerability/{vulnerability_id}/status", response_model=ExploitationStatusSchema)
async def get_exploitation_status(
    vulnerability_id: UUID,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get exploitation status for a vulnerability"""
    
    # Verify vulnerability exists and user has access
    vulnerability = db.query(Vulnerability).filter(
        Vulnerability.id == vulnerability_id
    ).first()
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    if vulnerability.scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Parse exploitation notes
    exploitation_info = {
        "last_attempt": None,
        "result": None,
        "framework_used": None,
        "execution_time": None,
        "error": None
    }
    
    if vulnerability.exploitation_notes:
        import json
        try:
            exploitation_info.update(json.loads(vulnerability.exploitation_notes))
        except json.JSONDecodeError:
            pass
    
    return {
        "vulnerability_id": str(vulnerability_id),
        "is_exploitable": vulnerability.is_exploitable,
        "exploitation_difficulty": vulnerability.exploitation_difficulty,
        "exploitation_attempted": bool(vulnerability.exploitation_notes),
        "last_attempt": exploitation_info.get("last_attempt"),
        "last_result": exploitation_info.get("result"),
        "framework_used": exploitation_info.get("framework_used"),
        "execution_time": exploitation_info.get("execution_time"),
        "error_message": exploitation_info.get("error"),
        "confidence_level": vulnerability.confidence_level
    }


@router.get("/scan/{scan_session_id}/status")
async def get_scan_exploitation_status(
    scan_session_id: UUID,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get overall exploitation status for a scan session"""
    
    # Verify access
    scan_session = db.query(ScanSession).filter(
        ScanSession.id == scan_session_id
    ).first()
    
    if not scan_session:
        raise HTTPException(status_code=404, detail="Scan session not found")
    
    if scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get exploitation status from service
    try:
        status = await exploitation_service.get_exploitation_status(str(scan_session_id))
        return status
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get status: {str(e)}")


@router.get("/scan/{scan_session_id}/history", response_model=List[ExploitationHistorySchema])
async def get_exploitation_history(
    scan_session_id: UUID,
    limit: int = Query(100, le=500),
    offset: int = Query(0),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get exploitation history for a scan session"""
    
    # Verify access
    scan_session = db.query(ScanSession).filter(
        ScanSession.id == scan_session_id
    ).first()
    
    if not scan_session:
        raise HTTPException(status_code=404, detail="Scan session not found")
    
    if scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get history from service
    try:
        history = await exploitation_service.get_exploitation_history(str(scan_session_id))
        
        # Apply pagination
        paginated_history = history[offset:offset + limit]
        
        return paginated_history
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to get history: {str(e)}")


@router.get("/vulnerability/{vulnerability_id}/impact-analysis", response_model=ExploitationImpactAnalysis)
async def analyze_exploitation_impact(
    vulnerability_id: UUID,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Analyze potential impact of exploiting a vulnerability"""
    
    # Verify vulnerability exists and user has access
    vulnerability = db.query(Vulnerability).filter(
        Vulnerability.id == vulnerability_id
    ).first()
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    if vulnerability.scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get impact analysis from service
    try:
        analysis = await exploitation_service.analyze_exploitation_impact(str(vulnerability_id))
        return analysis
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Impact analysis failed: {str(e)}")


@router.get("/chains", response_model=List[ExploitationChainSchema])
async def get_exploitation_chains(
    scan_session_id: Optional[UUID] = Query(None, description="Filter by scan session"),
    successful_only: bool = Query(False, description="Only return successful chains"),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get exploitation chains"""
    
    query = db.query(ExploitationChain).join(Vulnerability).join(ScanSession).join(Target)
    
    # Filter by user
    query = query.filter(Target.researcher_username == current_user["username"])
    
    # Apply filters
    if scan_session_id:
        query = query.filter(ScanSession.id == scan_session_id)
    
    if successful_only:
        query = query.filter(ExploitationChain.chain_successful == True)
    
    chains = query.order_by(ExploitationChain.executed_at.desc()).all()
    
    # Group chains by chain_name and return summary
    chain_groups = {}
    for chain in chains:
        if chain.chain_name not in chain_groups:
            chain_groups[chain.chain_name] = {
                "chain_name": chain.chain_name,
                "chain_description": chain.chain_description,
                "total_steps": chain.total_steps,
                "successful_steps": 0,
                "chain_successful": chain.chain_successful,
                "executed_at": chain.executed_at,
                "final_impact_description": chain.final_impact_description,
                "vulnerabilities": []
            }
        
        if chain.step_successful:
            chain_groups[chain.chain_name]["successful_steps"] += 1
        
        chain_groups[chain.chain_name]["vulnerabilities"].append({
            "vulnerability_id": str(chain.vulnerability_id),
            "vulnerability_name": chain.vulnerability.vulnerability_name,
            "step_number": chain.step_number,
            "step_successful": chain.step_successful,
            "payload": chain.payload,
            "impact_increase": chain.impact_increase
        })
    
    return list(chain_groups.values())


@router.get("/chain/{chain_name}/details")
async def get_chain_details(
    chain_name: str,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get detailed information about an exploitation chain"""
    
    chains = db.query(ExploitationChain).join(Vulnerability).join(ScanSession).join(Target).filter(
        ExploitationChain.chain_name == chain_name,
        Target.researcher_username == current_user["username"]
    ).order_by(ExploitationChain.step_number).all()
    
    if not chains:
        raise HTTPException(status_code=404, detail="Exploitation chain not found")
    
    chain_details = {
        "chain_name": chain_name,
        "chain_description": chains[0].chain_description,
        "total_steps": chains[0].total_steps,
        "chain_successful": chains[0].chain_successful,
        "executed_at": chains[0].executed_at.isoformat(),
        "final_impact_description": chains[0].final_impact_description,
        "steps": []
    }
    
    for chain in chains:
        step_data = {
            "step_number": chain.step_number,
            "vulnerability_id": str(chain.vulnerability_id),
            "vulnerability_name": chain.vulnerability.vulnerability_name,
            "vulnerability_type": chain.vulnerability.vulnerability_type,
            "affected_url": chain.vulnerability.affected_url,
            "step_description": chain.step_description,
            "payload": chain.payload,
            "expected_result": chain.expected_result,
            "actual_result": chain.actual_result,
            "step_successful": chain.step_successful,
            "impact_increase": chain.impact_increase,
            "screenshot_path": chain.screenshot_path,
            "request_response_log": chain.request_response_log
        }
        chain_details["steps"].append(step_data)
    
    return chain_details


@router.post("/vulnerability/{vulnerability_id}/manual-verify")
async def manually_verify_exploitation(
    vulnerability_id: UUID,
    verification_data: Dict[str, Any],
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Manually verify exploitation results"""
    
    # Verify vulnerability exists and user has access
    vulnerability = db.query(Vulnerability).filter(
        Vulnerability.id == vulnerability_id
    ).first()
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    if vulnerability.scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Update verification status
    vulnerability.manually_verified = verification_data.get("verified", False)
    vulnerability.verification_notes = verification_data.get("notes", "")
    
    if verification_data.get("verified"):
        vulnerability.is_exploitable = True
        vulnerability.confidence_level = min(1.0, vulnerability.confidence_level + 0.2)
    
    db.commit()
    
    return {
        "message": "Vulnerability verification updated",
        "vulnerability_id": str(vulnerability_id),
        "manually_verified": vulnerability.manually_verified,
        "verification_notes": vulnerability.verification_notes
    }


@router.get("/vulnerabilities/exploitable")
async def get_exploitable_vulnerabilities(
    scan_session_id: Optional[UUID] = Query(None, description="Filter by scan session"),
    severity: Optional[str] = Query(None, description="Filter by severity"),
    vulnerability_type: Optional[str] = Query(None, description="Filter by vulnerability type"),
    verified_only: bool = Query(False, description="Only return manually verified"),
    limit: int = Query(100, le=500),
    offset: int = Query(0),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get exploitable vulnerabilities"""
    
    query = db.query(Vulnerability).join(ScanSession).join(Target).filter(
        Target.researcher_username == current_user["username"],
        Vulnerability.is_exploitable == True
    )
    
    # Apply filters
    if scan_session_id:
        query = query.filter(ScanSession.id == scan_session_id)
    
    if severity:
        try:
            severity_enum = VulnSeverity(severity.lower())
            query = query.filter(Vulnerability.severity == severity_enum)
        except ValueError:
            raise HTTPException(status_code=400, detail="Invalid severity level")
    
    if vulnerability_type:
        query = query.filter(Vulnerability.vulnerability_type.ilike(f"%{vulnerability_type}%"))
    
    if verified_only:
        query = query.filter(Vulnerability.manually_verified == True)
    
    # Get total count
    total_count = query.count()
    
    # Apply pagination
    vulnerabilities = query.order_by(
        Vulnerability.severity.desc(),
        Vulnerability.confidence_level.desc()
    ).offset(offset).limit(limit).all()
    
    results = []
    for vuln in vulnerabilities:
        # Parse exploitation notes
        exploitation_info = {}
        if vuln.exploitation_notes:
            import json
            try:
                exploitation_info = json.loads(vuln.exploitation_notes)
            except json.JSONDecodeError:
                pass
        
        vuln_data = {
            "vulnerability_id": str(vuln.id),
            "vulnerability_name": vuln.vulnerability_name,
            "vulnerability_type": vuln.vulnerability_type,
            "severity": vuln.severity.value,
            "affected_url": vuln.affected_url,
            "affected_parameter": vuln.affected_parameter,
            "is_exploitable": vuln.is_exploitable,
            "exploitation_difficulty": vuln.exploitation_difficulty,
            "manually_verified": vuln.manually_verified,
            "confidence_level": vuln.confidence_level,
            "discovered_at": vuln.discovered_at.isoformat(),
            "exploitation_info": {
                "last_attempt": exploitation_info.get("last_attempt"),
                "framework_used": exploitation_info.get("framework_used"),
                "execution_time": exploitation_info.get("execution_time"),
                "result": exploitation_info.get("result")
            },
            "target_name": vuln.scan_session.target.target_name,
            "scan_session_id": str(vuln.scan_session_id)
        }
        results.append(vuln_data)
    
    return {
        "total_count": total_count,
        "exploitable_vulnerabilities": results,
        "page_info": {
            "limit": limit,
            "offset": offset,
            "has_more": total_count > offset + limit
        }
    }


@router.post("/scan/{scan_session_id}/auto-exploit")
async def auto_exploit_scan_vulnerabilities(
    scan_session_id: UUID,
    config: ExploitationConfigSchema,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Automatically exploit all suitable vulnerabilities in a scan session"""
    
    # Verify access
    scan_session = db.query(ScanSession).filter(
        ScanSession.id == scan_session_id
    ).first()
    
    if not scan_session:
        raise HTTPException(status_code=404, detail="Scan session not found")
    
    if scan_session.target.researcher_username != current_user["username"]:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Get vulnerabilities suitable for exploitation
    query = db.query(Vulnerability).filter(
        Vulnerability.scan_session_id == scan_session_id
    )
    
    # Apply severity filter
    if config.min_severity:
        severity_order = {
            VulnSeverity.INFO: 0,
            VulnSeverity.LOW: 1,
            VulnSeverity.MEDIUM: 2,
            VulnSeverity.HIGH: 3,
            VulnSeverity.CRITICAL: 4
        }
        min_severity_enum = VulnSeverity(config.min_severity.lower())
        min_order = severity_order[min_severity_enum]
        
        suitable_severities = [
            severity for severity, order in severity_order.items()
            if order >= min_order
        ]
        query = query.filter(Vulnerability.severity.in_(suitable_severities))
    
    # Apply vulnerability type filter
    if config.vulnerability_types:
        query = query.filter(Vulnerability.vulnerability_type.in_(config.vulnerability_types))
    
    # Exclude already exploited if specified
    if config.skip_exploited:
        query = query.filter(Vulnerability.is_exploitable != True)
    
    vulnerabilities = query.all()
    
    if not vulnerabilities:
        return {
            "message": "No suitable vulnerabilities found for exploitation",
            "scan_session_id": str(scan_session_id),
            "vulnerabilities_found": 0
        }
    
    # Start exploitation tasks
    exploitation_tasks = []
    for vuln in vulnerabilities:
        if config.max_concurrent and len(exploitation_tasks) >= config.max_concurrent:
            break
        
        background_tasks.add_task(
            exploitation_service.exploit_vulnerability_async.delay,
            str(vuln.id)
        )
        exploitation_tasks.append(str(vuln.id))
    
    return {
        "message": f"Started exploitation of {len(exploitation_tasks)} vulnerabilities",
        "scan_session_id": str(scan_session_id),
        "vulnerabilities_queued": len(exploitation_tasks),
        "total_suitable": len(vulnerabilities),
        "vulnerability_ids": exploitation_tasks
    }


@router.get("/statistics")
async def get_exploitation_statistics(
    scan_session_id: Optional[UUID] = Query(None, description="Filter by scan session"),
    timeframe_days: int = Query(30, description="Statistics timeframe in days"),
    db: Session = Depends(get_db),
    current_user: dict = Depends(get_current_user)
):
    """Get exploitation statistics"""
    
    from datetime import datetime, timedelta
    
    # Base query for user's vulnerabilities
    query = db.query(Vulnerability).join(ScanSession).join(Target).filter(
        Target.researcher_username == current_user["username"]
    )
    
    # Apply filters
    if scan_session_id:
        query = query.filter(ScanSession.id == scan_session_id)
    
    # Time filter
    cutoff_date = datetime.utcnow() - timedelta(days=timeframe_days)
    query = query.filter(Vulnerability.discovered_at >= cutoff_date)
    
    vulnerabilities = query.all()
    
    # Calculate statistics
    total_vulnerabilities = len(vulnerabilities)
    exploitable_count = len([v for v in vulnerabilities if v.is_exploitable])
    attempted_count = len([v for v in vulnerabilities if v.exploitation_notes])
    verified_count = len([v for v in vulnerabilities if v.manually_verified])
    
    # Statistics by severity
    severity_stats = {}
    for severity in VulnSeverity:
        severity_vulns = [v for v in vulnerabilities if v.severity == severity]
        severity_stats[severity.value] = {
            "total": len(severity_vulns),
            "exploitable": len([v for v in severity_vulns if v.is_exploitable]),
            "attempted": len([v for v in severity_vulns if v.exploitation_notes])
        }
    
    # Statistics by vulnerability type
    type_stats = {}
    vuln_types = set(v.vulnerability_type for v in vulnerabilities)
    for vuln_type in vuln_types:
        type_vulns = [v for v in vulnerabilities if v.vulnerability_type == vuln_type]
        type_stats[vuln_type] = {
            "total": len(type_vulns),
            "exploitable": len([v for v in type_vulns if v.is_exploitable]),
            "success_rate": len([v for v in type_vulns if v.is_exploitable]) / len(type_vulns) if type_vulns else 0
        }
    
    # Chain statistics
    chains = db.query(ExploitationChain).join(Vulnerability).join(ScanSession).join(Target).filter(
        Target.researcher_username == current_user["username"],
        ExploitationChain.executed_at >= cutoff_date
    ).all()
    
    unique_chains = set(c.chain_name for c in chains)
    successful_chains = set(c.chain_name for c in chains if c.chain_successful)
    
    return {
        "timeframe_days": timeframe_days,
        "total_vulnerabilities": total_vulnerabilities,
        "exploitation_stats": {
            "exploitable_count": exploitable_count,
            "attempted_count": attempted_count,
            "verified_count": verified_count,
            "success_rate": exploitable_count / attempted_count if attempted_count > 0 else 0,
            "exploitation_rate": attempted_count / total_vulnerabilities if total_vulnerabilities > 0 else 0
        },
        "severity_breakdown": severity_stats,
        "type_breakdown": type_stats,
        "chain_stats": {
            "total_chains": len(unique_chains),
            "successful_chains": len(successful_chains),
            "chain_success_rate": len(successful_chains) / len(unique_chains) if unique_chains else 0
        }
    }
    