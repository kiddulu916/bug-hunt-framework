"""
Pydantic schemas for exploitation API endpoints
"""

from typing import List, Optional, Dict, Any, Union
from datetime import datetime
from pydantic import BaseModel, Field, validator
from uuid import UUID


class VulnerabilityExploitRequest(BaseModel):
    """Schema for vulnerability exploitation requests"""
    async_execution: bool = Field(True, description="Execute exploitation asynchronously")
    manual_approval_override: bool = Field(False, description="Override manual approval requirement")
    custom_payload: Optional[str] = Field(None, description="Custom payload to use")
    framework_preference: Optional[str] = Field(None, description="Preferred exploitation framework")
    timeout_seconds: int = Field(300, ge=30, le=1800, description="Exploitation timeout")
    
    @validator('framework_preference')
    def validate_framework(cls, v):
        if v and v not in ['metasploit', 'sqlmap', 'nuclei', 'custom']:
            raise ValueError('framework_preference must be one of: metasploit, sqlmap, nuclei, custom')
        return v


class ExploitationConfigSchema(BaseModel):
    """Schema for exploitation configuration"""
    min_severity: Optional[str] = Field(None, description="Minimum severity to exploit")
    vulnerability_types: Optional[List[str]] = Field(None, description="Specific vulnerability types to exploit")
    skip_exploited: bool = Field(True, description="Skip already exploited vulnerabilities")
    max_concurrent: Optional[int] = Field(5, ge=1, le=20, description="Maximum concurrent exploitations")
    auto_chain: bool = Field(False, description="Automatically create exploitation chains")
    
    @validator('min_severity')
    def validate_severity(cls, v):
        if v and v.lower() not in ['info', 'low', 'medium', 'high', 'critical']:
            raise ValueError('min_severity must be one of: info, low, medium, high, critical')
        return v.lower() if v else v


class ExploitationResultSchema(BaseModel):
    """Schema for exploitation results"""
    vulnerability_id: str
    result: str  # success, failed, blocked, etc.
    framework_used: Optional[str] = None
    payload_type: Optional[str] = None
    execution_time: Optional[float] = None
    response_code: Optional[int] = None
    evidence: Dict[str, Any] = {}
    error_message: Optional[str] = None
    exploitation_chain_possible: bool = False
    executed_at: datetime


class ExploitationStatusSchema(BaseModel):
    """Schema for exploitation status"""
    vulnerability_id: str
    is_exploitable: bool
    exploitation_difficulty: Optional[str] = None
    exploitation_attempted: bool
    last_attempt: Optional[str] = None
    last_result: Optional[str] = None
    framework_used: Optional[str] = None
    execution_time: Optional[float] = None
    error_message: Optional[str] = None
    confidence_level: float


class ExploitationChainCreate(BaseModel):
    """Schema for creating exploitation chains"""
    vulnerability_ids: List[UUID] = Field(..., min_items=2, description="List of vulnerability IDs to chain")
    chain_name: str = Field(..., min_length=1, max_length=255, description="Name for the exploitation chain")
    chain_description: str = Field(..., min_length=1, description="Description of the exploitation chain")
    auto_execute: bool = Field(True, description="Automatically execute the chain after creation")


class ExploitationChainSchema(BaseModel):
    """Schema for exploitation chains"""
    chain_name: str
    chain_description: str
    total_steps: int
    successful_steps: int
    chain_successful: bool
    executed_at: datetime
    final_impact_description: Optional[str] = None
    vulnerabilities: List[Dict[str, Any]] = []


class ExploitationChainStepSchema(BaseModel):
    """Schema for individual exploitation chain steps"""
    step_number: int
    vulnerability_id: str
    vulnerability_name: str
    vulnerability_type: str
    affected_url: str
    step_description: str
    payload: Optional[str] = None
    expected_result: Optional[str] = None
    actual_result: Optional[str] = None
    step_successful: bool
    impact_increase: Optional[str] = None
    screenshot_path: Optional[str] = None
    request_response_log: Optional[str] = None


class ExploitationHistorySchema(BaseModel):
    """Schema for exploitation history"""
    chain_id: str
    chain_name: str
    vulnerability_name: str
    step_number: int
    total_steps: int
    successful: bool
    executed_at: str
    impact_increase: Optional[str] = None


class ExploitationImpactAnalysis(BaseModel):
    """Schema for exploitation impact analysis"""
    vulnerability_type: str
    current_severity: str
    potential_escalation: List[str]
    business_impact: str
    technical_impact: List[str]
    exploitability_score: float
    recommendations: List[str]


class ExploitationStatisticsSchema(BaseModel):
    """Schema for exploitation statistics"""
    timeframe_days: int
    total_vulnerabilities: int
    exploitation_stats: Dict[str, Any]
    severity_breakdown: Dict[str, Dict[str, int]]
    type_breakdown: Dict[str, Dict[str, Any]]
    chain_stats: Dict[str, Any]


class PayloadSchema(BaseModel):
    """Schema for exploitation payloads"""
    payload_id: Optional[str] = None
    payload_name: str
    payload_type: str  # sqli, xss, command_injection, etc.
    payload_content: str
    description: str
    success_indicators: List[str] = []
    framework: str  # custom, metasploit, etc.
    risk_level: str = Field("medium", description="Risk level of using this payload")
    tags: List[str] = []
    created_by: str
    created_at: datetime
    
    @validator('payload_type')
    def validate_payload_type(cls, v):
        valid_types = [
            'sqli', 'xss', 'command_injection', 'file_upload', 'path_traversal',
            'ssrf', 'csrf', 'idor', 'xxe', 'ssti', 'nosql_injection', 'rce'
        ]
        if v.lower() not in valid_types:
            raise ValueError(f'payload_type must be one of: {", ".join(valid_types)}')
        return v.lower()
    
    @validator('risk_level')
    def validate_risk_level(cls, v):
        if v.lower() not in ['low', 'medium', 'high', 'critical']:
            raise ValueError('risk_level must be one of: low, medium, high, critical')
        return v.lower()


class CustomPayloadRequest(BaseModel):
    """Schema for custom payload creation requests"""
    vulnerability_id: str
    payload_name: str
    payload_content: str
    description: Optional[str] = None
    expected_behavior: Optional[str] = None
    risk_assessment: str = Field("medium", description="Risk assessment for this payload")


class ExploitationReportSchema(BaseModel):
    """Schema for exploitation reports"""
    scan_session_id: str
    target_name: str
    total_vulnerabilities: int
    exploited_vulnerabilities: int
    exploitation_rate: float
    successful_chains: int
    high_impact_exploits: List[Dict[str, Any]]
    exploitation_timeline: List[Dict[str, Any]]
    recommendations: List[str]
    generated_at: datetime


class VulnerabilityExploitabilitySchema(BaseModel):
    """Schema for vulnerability exploitability assessment"""
    vulnerability_id: str
    vulnerability_name: str
    vulnerability_type: str
    severity: str
    affected_url: str
    affected_parameter: Optional[str] = None
    is_exploitable: bool
    exploitation_difficulty: Optional[str] = None
    manually_verified: bool
    confidence_level: float
    discovered_at: str
    exploitation_info: Dict[str, Any] = {}
    target_name: str
    scan_session_id: str


class FrameworkConfigSchema(BaseModel):
    """Schema for exploitation framework configuration"""
    framework_name: str
    enabled: bool = True
    priority: int = Field(1, ge=1, le=10, description="Framework priority (1=highest)")
    timeout_seconds: int = Field(300, ge=30, le=1800)
    max_concurrent: int = Field(3, ge=1, le=10)
    custom_parameters: Dict[str, Any] = {}
    
    @validator('framework_name')
    def validate_framework_name(cls, v):
        valid_frameworks = ['metasploit', 'sqlmap', 'nuclei', 'custom']
        if v.lower() not in valid_frameworks:
            raise ValueError(f'framework_name must be one of: {", ".join(valid_frameworks)}')
        return v.lower()


class ExploitationQueueSchema(BaseModel):
    """Schema for exploitation queue status"""
    total_queued: int
    currently_running: int
    completed: int
    failed: int
    queue_items: List[Dict[str, Any]]
    estimated_completion: Optional[datetime] = None


class ExploitationValidationSchema(BaseModel):
    """Schema for manual exploitation validation"""
    vulnerability_id: str
    verified: bool
    notes: str
    validation_method: str = Field("manual", description="Method used for validation")
    evidence_paths: List[str] = []
    impact_confirmed: bool = False
    additional_findings: Optional[str] = None


class ExploitationMetricsSchema(BaseModel):
    """Schema for exploitation metrics and analytics"""
    success_rate_by_type: Dict[str, float]
    average_execution_time: Dict[str, float]
    framework_effectiveness: Dict[str, Dict[str, Any]]
    exploitation_trends: List[Dict[str, Any]]
    false_positive_rate: float
    manual_verification_rate: float
    chain_success_patterns: List[Dict[str, Any]]


class ExploitationAlertSchema(BaseModel):
    """Schema for exploitation alerts and notifications"""
    alert_id: str
    alert_type: str  # success, failure, chain_complete, high_impact
    vulnerability_id: str
    target_name: str
    severity: str
    message: str
    timestamp: datetime
    requires_attention: bool = False
    metadata: Dict[str, Any] = {}


class ExploitationComplianceSchema(BaseModel):
    """Schema for exploitation compliance and safety"""
    scan_session_id: str
    compliance_checks: Dict[str, bool]
    safety_violations: List[str]
    scope_violations: List[str]
    rate_limit_violations: List[str]
    risk_assessment: str
    approval_required: bool
    approved_by: Optional[str] = None
    approved_at: Optional[datetime] = None


class AdvancedExploitationConfigSchema(BaseModel):
    """Schema for advanced exploitation configuration"""
    enable_auto_chaining: bool = Field(False, description="Automatically create exploitation chains")
    chain_discovery_threshold: float = Field(0.7, ge=0.1, le=1.0, description="Confidence threshold for auto-chaining")
    enable_impact_escalation: bool = Field(True, description="Attempt impact escalation")
    enable_persistence: bool = Field(False, description="Attempt to establish persistence")
    enable_lateral_movement: bool = Field(False, description="Attempt lateral movement")
    safe_mode: bool = Field(True, description="Enable safety checks and limitations")
    max_exploitation_depth: int = Field(3, ge=1, le=10, description="Maximum exploitation chain depth")
    respect_rate_limits: bool = Field(True, description="Respect target rate limits")
    enable_cleanup: bool = Field(True, description="Clean up after exploitation attempts")


class ExploitationAuditSchema(BaseModel):
    """Schema for exploitation audit logs"""
    audit_id: str
    action: str
    vulnerability_id: Optional[str] = None
    chain_id: Optional[str] = None
    performed_by: str
    timestamp: datetime
    details: Dict[str, Any]
    success: bool
    impact_level: str
    compliance_status: str


class ExploitationDashboardSchema(BaseModel):
    """Schema for exploitation dashboard data"""
    scan_session_id: str
    target_name: str
    exploitation_summary: Dict[str, Any]
    recent_exploitations: List[ExploitationResultSchema]
    active_chains: List[ExploitationChainSchema]
    success_metrics: Dict[str, float]
    alerts: List[ExploitationAlertSchema]
    recommendations: List[str]


class BulkExploitationRequest(BaseModel):
    """Schema for bulk exploitation requests"""
    vulnerability_ids: List[str]
    config: ExploitationConfigSchema
    execution_mode: str = Field("async", description="Execution mode: async or sync")
    priority: str = Field("normal", description="Priority level: low, normal, high")
    
    @validator('execution_mode')
    def validate_execution_mode(cls, v):
        if v not in ['async', 'sync']:
            raise ValueError('execution_mode must be either async or sync')
        return v
    
    @validator('priority')
    def validate_priority(cls, v):
        if v not in ['low', 'normal', 'high']:
            raise ValueError('priority must be one of: low, normal, high')
        return v


class ExploitationTemplateSchema(BaseModel):
    """Schema for exploitation templates"""
    template_id: str
    template_name: str
    vulnerability_types: List[str]
    description: str
    exploitation_steps: List[Dict[str, Any]]
    success_criteria: List[str]
    cleanup_steps: List[Dict[str, Any]]
    risk_level: str
    created_by: str
    created_at: datetime
    last_used: Optional[datetime] = None
    usage_count: int = 0


class ExploitationWorkflowSchema(BaseModel):
    """Schema for exploitation workflows"""
    workflow_id: str
    workflow_name: str
    description: str
    trigger_conditions: Dict[str, Any]
    exploitation_sequence: List[Dict[str, Any]]
    success_actions: List[Dict[str, Any]]
    failure_actions: List[Dict[str, Any]]
    enabled: bool = True
    created_by: str
    created_at: datetime


class RealTimeExploitationStatus(BaseModel):
    """Schema for real-time exploitation status updates"""
    scan_session_id: str
    current_exploitations: List[Dict[str, Any]]
    queue_status: ExploitationQueueSchema
    recent_completions: List[Dict[str, Any]]
    system_status: Dict[str, Any]
    last_updated: datetime
    