"""
Pydantic schemas for vulnerability management.
Defines data validation and serialization models for vulnerability-related API endpoints.
"""

from typing import List, Optional, Dict, Any, Union
from pydantic import BaseModel, Field, validator, root_validator
from datetime import datetime
from enum import Enum

from apps.vulnerabilities.models import VulnSeverity
from core.constants import VULNERABILITY_TYPES, OWASP_TOP_10_2021, COMMON_CWE_MAPPINGS

class VulnerabilityBase(BaseModel):
    """Base schema for vulnerability data."""
    
    vulnerability_name: str = Field(..., min_length=3, max_length=255, description="Vulnerability name")
    vulnerability_type: str = Field(..., description="Type of vulnerability")
    owasp_category: Optional[str] = Field(None, description="OWASP Top 10 category")
    cwe_id: Optional[str] = Field(None, regex=r'^CWE-\d+$', description="CWE identifier")
    severity: VulnSeverity = Field(..., description="Vulnerability severity")
    cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0, description="CVSS base score")
    impact_description: str = Field(..., min_length=10, description="Description of the vulnerability impact")
    affected_url: str = Field(..., description="URL where vulnerability was found")
    affected_parameter: Optional[str] = Field(None, max_length=255, description="Affected parameter name")
    http_method: Optional[str] = Field(None, regex=r'^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)$', description="HTTP method")
    payload_used: Optional[str] = Field(None, description="Payload used to discover the vulnerability")
    request_data: Optional[str] = Field(None, description="Full HTTP request data")
    response_data: Optional[str] = Field(None, description="HTTP response showing the vulnerability")
    discovered_by_tool: str = Field(..., max_length=100, description="Tool that discovered the vulnerability")
    discovery_method: str = Field(..., max_length=200, description="Method used to discover the vulnerability")
    confidence_level: float = Field(0.0, ge=0.0, le=1.0, description="Confidence in vulnerability accuracy")
    false_positive_likelihood: float = Field(0.0, ge=0.0, le=1.0, description="Likelihood of false positive")
    screenshot_paths: List[str] = Field(default_factory=list, description="Paths to evidence screenshots")
    additional_evidence: Dict[str, Any] = Field(default_factory=dict, description="Additional evidence data")
    is_exploitable: bool = Field(False, description="Whether vulnerability is exploitable")
    exploitation_difficulty: Optional[str] = Field(None, regex=r'^(easy|medium|hard)$', description="Exploitation difficulty")
    exploitation_notes: Optional[str] = Field(None, description="Notes on exploitation")
    remediation_suggestion: Optional[str] = Field(None, description="Suggested remediation steps")
    remediation_priority: Optional[str] = Field(None, regex=r'^(low|medium|high|critical)$', description="Remediation priority")

    @validator('vulnerability_type')
    def validate_vulnerability_type(cls, v):
        """Validate vulnerability type against known types."""
        if v not in VULNERABILITY_TYPES:
            raise ValueError(f'Invalid vulnerability type. Must be one of: {", ".join(VULNERABILITY_TYPES)}')
        return v

    @validator('owasp_category')
    def validate_owasp_category(cls, v):
        """Validate OWASP category."""
        if v is not None and v not in OWASP_TOP_10_2021:
            raise ValueError(f'Invalid OWASP category. Must be one of: {", ".join(OWASP_TOP_10_2021.keys())}')
        return v

    @root_validator
    def validate_cvss_severity_consistency(cls, values):
        """Ensure CVSS score is consistent with severity."""
        severity = values.get('severity')
        cvss_score = values.get('cvss_score')
        
        if severity and cvss_score is not None:
            from core.constants import CVSS_SCORE_RANGES
            expected_range = CVSS_SCORE_RANGES.get(severity.value)
            if expected_range and not (expected_range[0] <= cvss_score <= expected_range[1]):
                raise ValueError(f'CVSS score {cvss_score} inconsistent with severity {severity.value}')
        
        return values

class VulnerabilityCreate(VulnerabilityBase):
    """Schema for creating a new vulnerability."""
    
    scan_session_id: str = Field(..., description="ID of the scan session")

    class Config:
        schema_extra = {
            "example": {
                "scan_session_id": "12345678-1234-5678-9012-123456789012",
                "vulnerability_name": "SQL Injection in login form",
                "vulnerability_type": "sql_injection",
                "owasp_category": "A03",
                "cwe_id": "CWE-89",
                "severity": "high",
                "cvss_score": 8.1,
                "impact_description": "Allows attackers to bypass authentication and access sensitive data",
                "affected_url": "https://example.com/login",
                "affected_parameter": "username",
                "http_method": "POST",
                "payload_used": "admin' OR '1'='1'--",
                "discovered_by_tool": "sqlmap",
                "discovery_method": "automated_parameter_testing",
                "confidence_level": 0.95,
                "is_exploitable": True,
                "exploitation_difficulty": "easy"
            }
        }

class VulnerabilityUpdate(BaseModel):
    """Schema for updating vulnerability data."""
    
    vulnerability_name: Optional[str] = Field(None, min_length=3, max_length=255)
    vulnerability_type: Optional[str] = None
    owasp_category: Optional[str] = None
    cwe_id: Optional[str] = Field(None, regex=r'^CWE-\d+$')
    severity: Optional[VulnSeverity] = None
    cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0)
    impact_description: Optional[str] = Field(None, min_length=10)
    affected_parameter: Optional[str] = Field(None, max_length=255)
    http_method: Optional[str] = Field(None, regex=r'^(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)$')
    payload_used: Optional[str] = None
    request_data: Optional[str] = None
    response_data: Optional[str] = None
    confidence_level: Optional[float] = Field(None, ge=0.0, le=1.0)
    false_positive_likelihood: Optional[float] = Field(None, ge=0.0, le=1.0)
    additional_evidence: Optional[Dict[str, Any]] = None
    is_exploitable: Optional[bool] = None
    exploitation_difficulty: Optional[str] = Field(None, regex=r'^(easy|medium|hard)$')
    exploitation_notes: Optional[str] = None
    remediation_suggestion: Optional[str] = None
    remediation_priority: Optional[str] = Field(None, regex=r'^(low|medium|high|critical)$')
    manually_verified: Optional[bool] = None
    verification_notes: Optional[str] = None

    @validator('vulnerability_type')
    def validate_vulnerability_type(cls, v):
        if v is not None and v not in VULNERABILITY_TYPES:
            raise ValueError(f'Invalid vulnerability type. Must be one of: {", ".join(VULNERABILITY_TYPES)}')
        return v

class VulnerabilityResponse(VulnerabilityBase):
    """Schema for vulnerability response data."""
    
    id: str = Field(..., description="Vulnerability ID")
    scan_session_id: str = Field(..., description="Scan session ID")
    manually_verified: bool = Field(False, description="Whether vulnerability has been manually verified")
    verification_notes: Optional[str] = Field(None, description="Manual verification notes")
    discovered_at: datetime = Field(..., description="Discovery timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")

    class Config:
        orm_mode = True
        schema_extra = {
            "example": {
                "id": "87654321-4321-8765-4321-876543218765",
                "scan_session_id": "12345678-1234-5678-9012-123456789012",
                "vulnerability_name": "SQL Injection in login form",
                "vulnerability_type": "sql_injection",
                "owasp_category": "A03",
                "cwe_id": "CWE-89",
                "severity": "high",
                "cvss_score": 8.1,
                "impact_description": "Allows attackers to bypass authentication and access sensitive data",
                "affected_url": "https://example.com/login",
                "affected_parameter": "username",
                "http_method": "POST",
                "payload_used": "admin' OR '1'='1'--",
                "discovered_by_tool": "sqlmap",
                "discovery_method": "automated_parameter_testing",
                "confidence_level": 0.95,
                "is_exploitable": True,
                "exploitation_difficulty": "easy",
                "manually_verified": True,
                "verification_notes": "Confirmed exploitable in test environment",
                "discovered_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-01-15T14:20:00Z"
            }
        }

class VulnerabilityListResponse(BaseModel):
    """Schema for paginated vulnerability list response."""
    
    vulnerabilities: List[VulnerabilityResponse] = Field(..., description="List of vulnerabilities")
    pagination: Dict[str, Any] = Field(..., description="Pagination metadata")
    severity_counts: Dict[str, int] = Field(default_factory=dict, description="Count by severity")
    applied_filters: Dict[str, Any] = Field(default_factory=dict, description="Applied filters")

    class Config:
        schema_extra = {
            "example": {
                "vulnerabilities": [],
                "pagination": {
                    "count": 150,
                    "total_pages": 8,
                    "current_page": 1,
                    "page_size": 20,
                    "has_next": True,
                    "has_previous": False
                },
                "severity_counts": {
                    "critical": 5,
                    "high": 23,
                    "medium": 67,
                    "low": 45,
                    "info": 10
                },
                "applied_filters": {
                    "severity": "high"
                }
            }
        }

class VulnerabilityAnalysis(BaseModel):
    """Schema for vulnerability analysis results."""
    
    vulnerability_id: str = Field(..., description="Vulnerability ID")
    analysis_type: str = Field(..., description="Type of analysis performed")
    confidence_score: float = Field(..., ge=0.0, le=1.0, description="Overall confidence score")
    risk_score: float = Field(..., ge=0.0, le=10.0, description="Risk assessment score")
    exploitability_score: float = Field(..., ge=0.0, le=1.0, description="Exploitability assessment")
    false_positive_probability: float = Field(..., ge=0.0, le=1.0, description="False positive probability")
    similar_vulnerabilities: List[str] = Field(default_factory=list, description="IDs of similar vulnerabilities")
    attack_vectors: List[str] = Field(default_factory=list, description="Possible attack vectors")
    impact_analysis: Dict[str, Any] = Field(default_factory=dict, description="Detailed impact analysis")
    remediation_steps: List[str] = Field(default_factory=list, description="Recommended remediation steps")
    references: List[str] = Field(default_factory=list, description="External references and links")
    analyzed_at: datetime = Field(default_factory=datetime.utcnow, description="Analysis timestamp")

    class Config:
        schema_extra = {
            "example": {
                "vulnerability_id": "87654321-4321-8765-4321-876543218765",
                "analysis_type": "comprehensive",
                "confidence_score": 0.92,
                "risk_score": 8.1,
                "exploitability_score": 0.85,
                "false_positive_probability": 0.05,
                "similar_vulnerabilities": ["12345678-1234-5678-9012-123456789012"],
                "attack_vectors": ["parameter_injection", "authentication_bypass"],
                "impact_analysis": {
                    "data_exposure": "high",
                    "system_compromise": "medium",
                    "availability_impact": "low"
                },
                "remediation_steps": [
                    "Implement parameterized queries",
                    "Add input validation",
                    "Update framework to latest version"
                ],
                "references": [
                    "https://owasp.org/www-community/attacks/SQL_Injection",
                    "https://cwe.mitre.org/data/definitions/89.html"
                ]
            }
        }

class BulkVulnerabilityOperation(BaseModel):
    """Schema for bulk operations on vulnerabilities."""
    
    vulnerability_ids: List[str] = Field(..., min_items=1, description="List of vulnerability IDs")
    operation: str = Field(..., regex=r'^(verify|update_severity|delete|mark_false_positive)$', description="Operation to perform")
    data: Dict[str, Any] = Field(default_factory=dict, description="Operation-specific data")

    class Config:
        schema_extra = {
            "example": {
                "vulnerability_ids": [
                    "87654321-4321-8765-4321-876543218765",
                    "12345678-1234-5678-9012-123456789012"
                ],
                "operation": "verify",
                "data": {
                    "notes": "Bulk verified after manual testing"
                }
            }
        }

class VulnerabilityExport(BaseModel):
    """Schema for vulnerability export data."""
    
    vulnerabilities: List[VulnerabilityResponse] = Field(..., description="Vulnerabilities to export")
    export_format: str = Field(..., regex=r'^(csv|json|xml|pdf)$', description="Export format")
    filters: Dict[str, Any] = Field(default_factory=dict, description="Applied filters")
    generated_at: datetime = Field(..., description="Export generation timestamp")
    generated_by: str = Field(..., description="User who generated the export")
    total_count: Optional[int] = Field(None, description="Total number of vulnerabilities exported")
    
    @validator('total_count', always=True)
    def set_total_count(cls, v, values):
        if v is None:
            vulnerabilities = values.get('vulnerabilities', [])
            return len(vulnerabilities)
        return v

class VulnerabilityFilter(BaseModel):
    """Schema for vulnerability filtering options."""
    
    severity: Optional[List[VulnSeverity]] = Field(None, description="Filter by severity levels")
    vulnerability_types: Optional[List[str]] = Field(None, description="Filter by vulnerability types")
    owasp_categories: Optional[List[str]] = Field(None, description="Filter by OWASP categories")
    verified_only: bool = Field(False, description="Show only verified vulnerabilities")
    exploitable_only: bool = Field(False, description="Show only exploitable vulnerabilities")
    min_cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0, description="Minimum CVSS score")
    max_cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0, description="Maximum CVSS score")
    discovered_after: Optional[datetime] = Field(None, description="Discovered after date")
    discovered_before: Optional[datetime] = Field(None, description="Discovered before date")
    tools: Optional[List[str]] = Field(None, description="Filter by discovery tools")
    target_ids: Optional[List[str]] = Field(None, description="Filter by target IDs")
    scan_session_ids: Optional[List[str]] = Field(None, description="Filter by scan session IDs")

    @root_validator
    def validate_cvss_range(cls, values):
        min_score = values.get('min_cvss_score')
        max_score = values.get('max_cvss_score')
        
        if min_score is not None and max_score is not None and min_score > max_score:
            raise ValueError('min_cvss_score must be less than or equal to max_cvss_score')
        
        return values

    @root_validator
    def validate_date_range(cls, values):
        after_date = values.get('discovered_after')
        before_date = values.get('discovered_before')
        
        if after_date is not None and before_date is not None and after_date > before_date:
            raise ValueError('discovered_after must be before discovered_before')
        
        return values

class ExploitationChainStep(BaseModel):
    """Schema for exploitation chain step."""
    
    step_number: int = Field(..., ge=1, description="Step number in the chain")
    step_description: str = Field(..., min_length=10, description="Description of exploitation step")
    payload: Optional[str] = Field(None, description="Payload for this step")
    expected_result: Optional[str] = Field(None, description="Expected result")
    actual_result: Optional[str] = Field(None, description="Actual result observed")
    screenshot_path: Optional[str] = Field(None, description="Screenshot evidence")
    step_successful: bool = Field(False, description="Whether step was successful")
    impact_increase: Optional[str] = Field(None, regex=r'^(none|low|medium|high)$', description="Impact increase")

class ExploitationChain(BaseModel):
    """Schema for vulnerability exploitation chain."""
    
    vulnerability_id: str = Field(..., description="Associated vulnerability ID")
    chain_name: str = Field(..., min_length=3, max_length=255, description="Name of exploitation chain")
    chain_description: str = Field(..., min_length=10, description="Description of the exploitation chain")
    steps: List[ExploitationChainStep] = Field(..., min_items=1, description="Exploitation steps")
    total_steps: int = Field(..., ge=1, description="Total number of steps")
    chain_successful: bool = Field(False, description="Whether entire chain was successful")
    final_impact_description: Optional[str] = Field(None, description="Final impact achieved")
    executed_at: datetime = Field(default_factory=datetime.utcnow, description="Execution timestamp")

    @validator('total_steps', always=True)
    def validate_total_steps(cls, v, values):
        steps = values.get('steps', [])
        if len(steps) != v:
            raise ValueError('total_steps must match the number of steps provided')
        return v

# Statistics and reporting schemas

class VulnerabilityStatistics(BaseModel):
    """Schema for vulnerability statistics."""
    
    total_vulnerabilities: int = Field(..., ge=0, description="Total number of vulnerabilities")
    verified_vulnerabilities: int = Field(..., ge=0, description="Number of verified vulnerabilities")
    unverified_vulnerabilities: int = Field(..., ge=0, description="Number of unverified vulnerabilities")
    recent_discoveries: int = Field(..., ge=0, description="Recent discoveries count")
    severity_distribution: Dict[str, int] = Field(..., description="Distribution by severity")
    top_vulnerability_types: List[Dict[str, Union[str, int]]] = Field(..., description="Most common vulnerability types")
    owasp_distribution: Dict[str, int] = Field(..., description="Distribution by OWASP category")
    average_cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0, description="Average CVSS score")
    exploitability_rate: Optional[float] = Field(None, ge=0.0, le=1.0, description="Percentage of exploitable vulnerabilities")

class VulnerabilityTrends(BaseModel):
    """Schema for vulnerability discovery trends."""
    
    period: Dict[str, Union[str, int]] = Field(..., description="Analysis period information")
    daily_discoveries: List[Dict[str, Union[str, int]]] = Field(..., description="Daily discovery counts")
    severity_trends: List[Dict[str, Union[str, int]]] = Field(..., description="Severity trends over time")
    top_discovery_tools: List[Dict[str, Union[str, int]]] = Field(..., description="Most productive discovery tools")
    verification_trends: List[Dict[str, Union[str, int]]] = Field(default_factory=list, description="Verification trends")

# Export all schemas
__all__ = [
    "VulnerabilityBase",
    "VulnerabilityCreate", 
    "VulnerabilityUpdate",
    "VulnerabilityResponse",
    "VulnerabilityListResponse",
    "VulnerabilityAnalysis",
    "BulkVulnerabilityOperation",
    "VulnerabilityExport",
    "VulnerabilityFilter",
    "ExploitationChainStep",
    "ExploitationChain",
    "VulnerabilityStatistics",
    "VulnerabilityTrends",
]