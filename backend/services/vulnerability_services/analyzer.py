"""
Vulnerability analysis service.
Provides comprehensive analysis, validation, and enrichment of vulnerability data.
"""

import re
import logging
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
import statistics

from apps.vulnerabilities.models import Vulnerability, VulnSeverity
from core.constants import (
    VULNERABILITY_TYPES, OWASP_TOP_10_2021, COMMON_CWE_MAPPINGS,
    CVSS_SCORE_RANGES, TEST_PAYLOADS
)
from core.exceptions import (
    VulnerabilityProcessingException,
    InvalidVulnerabilityDataException
)

logger = logging.getLogger(__name__)

class VulnerabilityAnalyzer:
    """
    Advanced vulnerability analysis and enrichment service.
    Provides confidence scoring, false positive detection, and impact assessment.
    """
    
    def __init__(self):
        self.confidence_weights = {
            'payload_validation': 0.3,
            'response_analysis': 0.25,
            'contextual_analysis': 0.2,
            'tool_reliability': 0.15,
            'historical_patterns': 0.1
        }
        
        # Tool reliability scores (0.0 to 1.0)
        self.tool_reliability = {
            'sqlmap': 0.95,
            'nuclei': 0.85,
            'burp': 0.90,
            'zap': 0.80,
            'custom': 0.70,
            'manual': 1.0
        }
        
        # False positive indicators
        self.false_positive_patterns = [
            r'test[_\-]?(page|environment|staging)',
            r'(dev|development|test|staging)\..*',
            r'.*\.(test|dev|staging)\..*',
            r'localhost|127\.0\.0\.1|0\.0\.0\.0',
            r'example\.(com|org|net)',
        ]

    def analyze_vulnerability(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """
        Perform basic vulnerability analysis and confidence scoring.
        
        Args:
            vulnerability: Vulnerability instance to analyze
            
        Returns:
            dict: Analysis results with confidence adjustments
        """
        try:
            analysis_result = {
                'vulnerability_id': str(vulnerability.id),
                'original_confidence': vulnerability.confidence_level,
                'analysis_timestamp': datetime.utcnow(),
                'confidence_factors': {},
                'recommendations': [],
                'risk_indicators': []
            }
            
            # Analyze payload effectiveness
            payload_score = self._analyze_payload_effectiveness(
                vulnerability.payload_used,
                vulnerability.vulnerability_type,
                vulnerability.response_data
            )
            analysis_result['confidence_factors']['payload_validation'] = payload_score
            
            # Analyze response patterns
            response_score = self._analyze_response_patterns(
                vulnerability.response_data,
                vulnerability.vulnerability_type
            )
            analysis_result['confidence_factors']['response_analysis'] = response_score
            
            # Contextual analysis (URL, parameter patterns)
            context_score = self._analyze_context(
                vulnerability.affected_url,
                vulnerability.affected_parameter,
                vulnerability.vulnerability_type
            )
            analysis_result['confidence_factors']['contextual_analysis'] = context_score
            
            # Tool reliability factor
            tool_score = self.tool_reliability.get(
                vulnerability.discovered_by_tool.lower(), 
                0.75
            )
            analysis_result['confidence_factors']['tool_reliability'] = tool_score
            
            # Calculate adjusted confidence
            confidence_adjustment = self._calculate_confidence_score(
                analysis_result['confidence_factors']
            )
            
            analysis_result['confidence_adjustment'] = confidence_adjustment
            analysis_result['adjusted_confidence'] = min(1.0, max(0.0, confidence_adjustment))
            
            # False positive likelihood
            fp_likelihood = self._calculate_false_positive_likelihood(vulnerability)
            analysis_result['false_positive_likelihood'] = fp_likelihood
            
            # Generate recommendations
            analysis_result['recommendations'] = self._generate_recommendations(
                vulnerability, analysis_result
            )
            
            # Risk indicators
            analysis_result['risk_indicators'] = self._identify_risk_indicators(vulnerability)
            
            logger.info(f"Analyzed vulnerability {vulnerability.id} with confidence {confidence_adjustment:.2f}")
            
            return analysis_result
            
        except Exception as e:
            logger.error(f"Error analyzing vulnerability {vulnerability.id}: {e}")
            raise VulnerabilityProcessingException("analysis", str(e))

    def comprehensive_analysis(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """
        Perform comprehensive vulnerability analysis including impact assessment.
        
        Args:
            vulnerability: Vulnerability instance to analyze
            
        Returns:
            dict: Comprehensive analysis results
        """
        try:
            # Start with basic analysis
            basic_analysis = self.analyze_vulnerability(vulnerability)
            
            # Enhanced analysis
            comprehensive_result = {
                **basic_analysis,
                'analysis_type': 'comprehensive',
                'impact_analysis': self._assess_impact(vulnerability),
                'exploitability_assessment': self._assess_exploitability(vulnerability),
                'similar_vulnerabilities': self._find_similar_vulnerabilities(vulnerability),
                'attack_vectors': self._identify_attack_vectors(vulnerability),
                'remediation_priority': self._calculate_remediation_priority(vulnerability),
                'compliance_mapping': self._map_compliance_frameworks(vulnerability)
            }
            
            # Risk scoring
            comprehensive_result['risk_score'] = self._calculate_risk_score(
                vulnerability, comprehensive_result
            )
            
            logger.info(f"Comprehensive analysis completed for vulnerability {vulnerability.id}")
            
            return comprehensive_result
            
        except Exception as e:
            logger.error(f"Error in comprehensive analysis for {vulnerability.id}: {e}")
            raise VulnerabilityProcessingException("comprehensive_analysis", str(e))

    def _analyze_payload_effectiveness(self, payload: str, vuln_type: str, response: str) -> float:
        """Analyze how effective the payload was for the vulnerability type."""
        if not payload or not vuln_type:
            return 0.5
        
        # Get expected payloads for vulnerability type
        expected_payloads = TEST_PAYLOADS.get(vuln_type, [])
        if not expected_payloads:
            return 0.6  # Unknown type, moderate confidence
        
        # Check if payload matches known effective patterns
        payload_lower = payload.lower()
        effectiveness_score = 0.0
        
        for expected in expected_payloads:
            if expected.lower() in payload_lower:
                effectiveness_score = max(effectiveness_score, 0.8)
            elif self._payload_similarity(payload, expected) > 0.7:
                effectiveness_score = max(effectiveness_score, 0.7)
        
        # Analyze response for payload indicators
        if response and self._response_indicates_success(response, vuln_type):
            effectiveness_score = min(1.0, effectiveness_score + 0.2)
        
        return max(0.3, effectiveness_score)  # Minimum baseline confidence

    def _analyze_response_patterns(self, response: str, vuln_type: str) -> float:
        """Analyze response patterns to validate vulnerability type."""
        if not response:
            return 0.4
        
        response_lower = response.lower()
        score = 0.5  # Baseline
        
        # Vulnerability-specific response patterns
        patterns = {
            'sql_injection': [
                r'sql syntax.*error', r'mysql.*error', r'ora-\d+',
                r'microsoft.*odbc.*sql', r'postgresql.*error'
            ],
            'xss_reflected': [
                r'<script[^>]*>.*</script>', r'javascript:', r'onerror=',
                r'alert\(', r'document\.cookie'
            ],
            'xss_stored': [
                r'<script[^>]*>.*</script>', r'javascript:', r'stored.*xss'
            ],
            'lfi': [
                r'root:.*:0:0:', r'boot\.ini', r'windows.*system32',
                r'/etc/passwd', r'for %%i in'
            ],
            'rce': [
                r'uid=\d+.*gid=\d+', r'total \d+', r'volume.*serial',
                r'command.*not.*found'
            ]
        }
        
        if vuln_type in patterns:
            for pattern in patterns[vuln_type]:
                if re.search(pattern, response_lower, re.IGNORECASE):
                    score += 0.15
        
        return min(1.0, score)

    def _analyze_context(self, url: str, parameter: str, vuln_type: str) -> float:
        """Analyze URL and parameter context for vulnerability plausibility."""
        score = 0.5  # Baseline
        
        if not url:
            return score
        
        url_lower = url.lower()
        
        # Context indicators that increase confidence
        high_risk_contexts = {
            'sql_injection': ['login', 'search', 'id=', 'user', 'admin'],
            'xss_reflected': ['search', 'query', 'message', 'comment'],
            'lfi': ['file', 'page', 'include', 'template', 'view'],
            'rce': ['cmd', 'exec', 'system', 'shell']
        }
        
        if vuln_type in high_risk_contexts:
            for indicator in high_risk_contexts[vuln_type]:
                if indicator in url_lower or (parameter and indicator in parameter.lower()):
                    score += 0.1
        
        # Context indicators that decrease confidence (test/dev environments)
        for pattern in self.false_positive_patterns:
            if re.search(pattern, url_lower):
                score -= 0.2
                break
        
        return max(0.1, min(1.0, score))

    def _calculate_confidence_score(self, factors: Dict[str, float]) -> float:
        """Calculate weighted confidence score from analysis factors."""
        total_score = 0.0
        total_weight = 0.0
        
        for factor, score in factors.items():
            weight = self.confidence_weights.get(factor, 0.1)
            total_score += score * weight
            total_weight += weight
        
        return total_score / total_weight if total_weight > 0 else 0.5

    def _calculate_false_positive_likelihood(self, vulnerability: Vulnerability) -> float:
        """Calculate likelihood that vulnerability is a false positive."""
        fp_score = 0.0
        
        # URL-based indicators
        url = vulnerability.affected_url.lower()
        for pattern in self.false_positive_patterns:
            if re.search(pattern, url):
                fp_score += 0.15
        
        # Tool-based false positive rates
        tool_fp_rates = {
            'nuclei': 0.1,
            'sqlmap': 0.05,
            'burp': 0.08,
            'zap': 0.15,
            'custom': 0.25
        }
        
        tool_name = vulnerability.discovered_by_tool.lower()
        fp_score += tool_fp_rates.get(tool_name, 0.2)
        
        # Confidence-based adjustment
        if vulnerability.confidence_level < 0.5:
            fp_score += 0.2
        elif vulnerability.confidence_level > 0.8:
            fp_score -= 0.1
        
        return max(0.0, min(1.0, fp_score))

    def _assess_impact(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Assess the potential impact of the vulnerability."""
        impact_categories = {
            'confidentiality': 'none',
            'integrity': 'none', 
            'availability': 'none',
            'scope': 'unchanged',
            'business_impact': 'low'
        }
        
        # Impact based on vulnerability type
        impact_mappings = {
            'sql_injection': {
                'confidentiality': 'high',
                'integrity': 'high',
                'availability': 'low',
                'business_impact': 'high'
            },
            'xss_reflected': {
                'confidentiality': 'low',
                'integrity': 'low',
                'availability': 'none',
                'business_impact': 'medium'
            },
            'xss_stored': {
                'confidentiality': 'low', 
                'integrity': 'low',
                'availability': 'none',
                'scope': 'changed',
                'business_impact': 'high'
            },
            'rce': {
                'confidentiality': 'high',
                'integrity': 'high',
                'availability': 'high',
                'scope': 'changed',
                'business_impact': 'critical'
            }
        }
        
        if vulnerability.vulnerability_type in impact_mappings:
            impact_categories.update(impact_mappings[vulnerability.vulnerability_type])
        
        return {
            'impact_vector': impact_categories,
            'affected_users': self._estimate_affected_users(vulnerability),
            'data_exposure_risk': self._assess_data_exposure_risk(vulnerability),
            'system_compromise_risk': self._assess_system_compromise_risk(vulnerability)
        }

    def _assess_exploitability(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Assess how easily the vulnerability can be exploited."""
        exploitability = {
            'attack_vector': 'network',
            'attack_complexity': 'low',
            'privileges_required': 'none',
            'user_interaction': 'none',
            'exploitation_likelihood': 'medium'
        }
        
        # Adjust based on vulnerability type
        complexity_mappings = {
            'sql_injection': {'attack_complexity': 'low', 'exploitation_likelihood': 'high'},
            'xss_reflected': {'user_interaction': 'required', 'exploitation_likelihood': 'medium'},
            'xss_stored': {'attack_complexity': 'low', 'exploitation_likelihood': 'high'},
            'csrf': {'user_interaction': 'required', 'exploitation_likelihood': 'medium'},
            'rce': {'attack_complexity': 'low', 'exploitation_likelihood': 'high'}
        }
        
        if vulnerability.vulnerability_type in complexity_mappings:
            exploitability.update(complexity_mappings[vulnerability.vulnerability_type])
        
        # Authentication requirements
        url = vulnerability.affected_url.lower()
        if any(auth_indicator in url for auth_indicator in ['admin', 'dashboard', 'panel']):
            exploitability['privileges_required'] = 'high'
            exploitability['exploitation_likelihood'] = 'medium'
        
        return exploitability

    def _find_similar_vulnerabilities(self, vulnerability: Vulnerability) -> List[str]:
        """Find similar vulnerabilities for pattern analysis."""
        # This would query the database for similar vulnerabilities
        # For now, return empty list - implement with actual database queries
        return []

    def _identify_attack_vectors(self, vulnerability: Vulnerability) -> List[str]:
        """Identify possible attack vectors for the vulnerability."""
        vectors = []
        
        vuln_type = vulnerability.vulnerability_type
        
        attack_vector_mappings = {
            'sql_injection': [
                'data_extraction', 'authentication_bypass', 'privilege_escalation',
                'database_modification', 'os_command_execution'
            ],
            'xss_reflected': [
                'session_hijacking', 'credential_theft', 'phishing',
                'malware_delivery', 'defacement'
            ],
            'xss_stored': [
                'persistent_attack', 'mass_exploitation', 'admin_compromise',
                'data_harvesting', 'malware_propagation'
            ],
            'csrf': [
                'unauthorized_actions', 'data_modification', 'account_takeover',
                'privilege_escalation'
            ],
            'lfi': [
                'file_disclosure', 'code_execution', 'configuration_exposure',
                'log_poisoning'
            ],
            'rce': [
                'system_compromise', 'lateral_movement', 'data_exfiltration',
                'service_disruption', 'backdoor_installation'
            ]
        }
        
        return attack_vector_mappings.get(vuln_type, ['unknown_vector'])

    def _calculate_remediation_priority(self, vulnerability: Vulnerability) -> str:
        """Calculate remediation priority based on multiple factors."""
        priority_score = 0
        
        # Severity weight
        severity_weights = {
            VulnSeverity.CRITICAL: 10,
            VulnSeverity.HIGH: 7,
            VulnSeverity.MEDIUM: 4,
            VulnSeverity.LOW: 2,
            VulnSeverity.INFO: 1
        }
        priority_score += severity_weights.get(vulnerability.severity, 2)
        
        # Exploitability weight
        if vulnerability.is_exploitable:
            priority_score += 5
        
        # CVSS score weight
        if vulnerability.cvss_score:
            priority_score += int(vulnerability.cvss_score)
        
        # Confidence weight
        priority_score += int(vulnerability.confidence_level * 3)
        
        # Determine priority level
        if priority_score >= 15:
            return 'critical'
        elif priority_score >= 10:
            return 'high'
        elif priority_score >= 6:
            return 'medium'
        else:
            return 'low'

    def _map_compliance_frameworks(self, vulnerability: Vulnerability) -> Dict[str, List[str]]:
        """Map vulnerability to compliance framework requirements."""
        mappings = {
            'owasp_top10': [],
            'pci_dss': [],
            'iso27001': [],
            'nist': []
        }
        
        # OWASP Top 10 mapping
        if vulnerability.owasp_category:
            mappings['owasp_top10'].append(vulnerability.owasp_category)
        
        # PCI DSS requirements
        high_risk_types = ['sql_injection', 'xss_stored', 'authentication_bypass']
        if vulnerability.vulnerability_type in high_risk_types:
            mappings['pci_dss'].extend(['6.5.1', '6.5.7'])
        
        return mappings

    def _calculate_risk_score(self, vulnerability: Vulnerability, analysis: Dict[str, Any]) -> float:
        """Calculate overall risk score (0-10 scale)."""
        # Base score from CVSS
        base_score = vulnerability.cvss_score or 5.0
        
        # Adjustments based on analysis
        confidence_adj = analysis.get('adjusted_confidence', 0.5) * 2 - 1  # -1 to +1
        exploitability_adj = 1.0 if vulnerability.is_exploitable else -1.0
        
        # Apply adjustments
        risk_score = base_score + (confidence_adj * 1.5) + exploitability_adj
        
        return max(0.0, min(10.0, risk_score))

    def _generate_recommendations(self, vulnerability: Vulnerability, analysis: Dict[str, Any]) -> List[str]:
        """Generate specific recommendations based on analysis."""
        recommendations = []
        
        # Confidence-based recommendations
        if analysis.get('adjusted_confidence', 0) < 0.6:
            recommendations.append("Manual verification recommended due to low confidence score")
        
        if analysis.get('false_positive_likelihood', 0) > 0.3:
            recommendations.append("High false positive likelihood - verify in production-like environment")
        
        # Type-specific recommendations
        type_recommendations = {
            'sql_injection': [
                "Implement parameterized queries/prepared statements",
                "Apply input validation and sanitization",
                "Use least privilege database accounts",
                "Enable SQL injection detection rules in WAF"
            ],
            'xss_reflected': [
                "Implement output encoding/escaping",
                "Use Content Security Policy (CSP)",
                "Apply input validation",
                "Consider using auto-escaping template engines"
            ],
            'xss_stored': [
                "Implement output encoding for all user input",
                "Use strong Content Security Policy",
                "Sanitize input before storage",
                "Implement admin review for user-generated content"
            ]
        }
        
        specific_recs = type_recommendations.get(vulnerability.vulnerability_type, [])
        recommendations.extend(specific_recs)
        
        return recommendations

    def _identify_risk_indicators(self, vulnerability: Vulnerability) -> List[str]:
        """Identify risk indicators that affect vulnerability severity."""
        indicators = []
        
        # URL-based indicators
        url = vulnerability.affected_url.lower()
        if 'admin' in url:
            indicators.append('administrative_interface')
        if 'api' in url:
            indicators.append('api_endpoint')
        if 'upload' in url:
            indicators.append('file_upload_functionality')
        
        # Parameter-based indicators
        if vulnerability.affected_parameter:
            param = vulnerability.affected_parameter.lower()
            if param in ['id', 'userid', 'user_id']:
                indicators.append('user_enumeration_possible')
            if param in ['file', 'filename', 'path']:
                indicators.append('file_system_access')
        
        return indicators

    # Helper methods
    
    def _payload_similarity(self, payload1: str, payload2: str) -> float:
        """Calculate similarity between two payloads."""
        if not payload1 or not payload2:
            return 0.0
        
        # Simple character-based similarity
        set1 = set(payload1.lower())
        set2 = set(payload2.lower())
        
        intersection = len(set1.intersection(set2))
        union = len(set1.union(set2))
        
        return intersection / union if union > 0 else 0.0

    def _response_indicates_success(self, response: str, vuln_type: str) -> bool:
        """Check if response indicates successful exploitation."""
        if not response:
            return False
        
        success_indicators = {
            'sql_injection': ['error', 'mysql', 'sql', 'ora-', 'sqlite'],
            'xss_reflected': ['<script>', 'javascript:', 'alert(', 'onerror='],
            'lfi': ['root:', 'boot.ini', '/etc/passwd', 'system32'],
            'rce': ['uid=', 'gid=', 'total', 'volume']
        }
        
        indicators = success_indicators.get(vuln_type, [])
        response_lower = response.lower()
        
        return any(indicator in response_lower for indicator in indicators)

    def _estimate_affected_users(self, vulnerability: Vulnerability) -> str:
        """Estimate number of potentially affected users."""
        # This is a simplified estimation - in practice, would consider
        # application usage patterns, user base size, etc.
        
        if vulnerability.severity == VulnSeverity.CRITICAL:
            return 'all_users'
        elif vulnerability.severity == VulnSeverity.HIGH:
            return 'many_users'
        elif vulnerability.severity == VulnSeverity.MEDIUM:
            return 'some_users'
        else:
            return 'few_users'

    def _assess_data_exposure_risk(self, vulnerability: Vulnerability) -> str:
        """Assess risk of data exposure."""
        high_risk_types = ['sql_injection', 'lfi', 'information_disclosure']
        if vulnerability.vulnerability_type in high_risk_types:
            return 'high'
        
        medium_risk_types = ['xss_stored', 'csrf']
        if vulnerability.vulnerability_type in medium_risk_types:
            return 'medium'
        
        return 'low'

    def _assess_system_compromise_risk(self, vulnerability: Vulnerability) -> str:
        """Assess risk of system compromise."""
        critical_types = ['rce', 'authentication_bypass', 'insecure_deserialization']
        if vulnerability.vulnerability_type in critical_types:
            return 'high'
        
        moderate_types = ['sql_injection', 'xxe', 'ssrf']
        if vulnerability.vulnerability_type in moderate_types:
            return 'medium'
        
        return 'low'
      