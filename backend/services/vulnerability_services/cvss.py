"""
CVSS (Common Vulnerability Scoring System) calculation service.
Provides CVSS v3.1 base, temporal, and environmental score calculations.
"""

import logging
from typing import Any, Dict, List, Optional, Tuple
from enum import Enum
import math

from apps.vulnerabilities.models import VulnSeverity
from core.constants import CVSS_SCORE_RANGES, VULNERABILITY_TYPES
from core.exceptions import InvalidVulnerabilityDataException

logger = logging.getLogger(__name__)

class CVSSMetric(Enum):
    """CVSS v3.1 metric enumerations."""
    
    # Base Metrics
    ATTACK_VECTOR_NETWORK = "N"
    ATTACK_VECTOR_ADJACENT = "A" 
    ATTACK_VECTOR_LOCAL = "L"
    ATTACK_VECTOR_PHYSICAL = "P"
    
    ATTACK_COMPLEXITY_LOW = "L"
    ATTACK_COMPLEXITY_HIGH = "H"
    
    PRIVILEGES_REQUIRED_NONE = "N"
    PRIVILEGES_REQUIRED_LOW = "L"
    PRIVILEGES_REQUIRED_HIGH = "H"
    
    USER_INTERACTION_NONE = "N"
    USER_INTERACTION_REQUIRED = "R"
    
    SCOPE_UNCHANGED = "U"
    SCOPE_CHANGED = "C"
    
    CONFIDENTIALITY_NONE = "N"
    CONFIDENTIALITY_LOW = "L"
    CONFIDENTIALITY_HIGH = "H"
    
    INTEGRITY_NONE = "N"
    INTEGRITY_LOW = "L"
    INTEGRITY_HIGH = "H"
    
    AVAILABILITY_NONE = "N"
    AVAILABILITY_LOW = "L"
    AVAILABILITY_HIGH = "H"

class CVSSCalculator:
    """
    CVSS v3.1 calculator for vulnerability scoring.
    Provides base score calculation and automatic scoring based on vulnerability types.
    """
    
    def __init__(self):
        # CVSS v3.1 metric values
        self.metric_values = {
            # Attack Vector
            "AV:N": 0.85,  # Network
            "AV:A": 0.62,  # Adjacent Network
            "AV:L": 0.55,  # Local
            "AV:P": 0.2,   # Physical
            
            # Attack Complexity
            "AC:L": 0.77,  # Low
            "AC:H": 0.44,  # High
            
            # Privileges Required (Scope Unchanged)
            "PR:N:U": 0.85,  # None
            "PR:L:U": 0.62,  # Low
            "PR:H:U": 0.27,  # High
            
            # Privileges Required (Scope Changed)
            "PR:N:C": 0.85,  # None
            "PR:L:C": 0.68,  # Low
            "PR:H:C": 0.50,  # High
            
            # User Interaction
            "UI:N": 0.85,  # None
            "UI:R": 0.62,  # Required
            
            # Confidentiality/Integrity/Availability Impact
            "C:N": 0.0,   # None
            "C:L": 0.22,  # Low
            "C:H": 0.56,  # High
            
            "I:N": 0.0,   # None
            "I:L": 0.22,  # Low
            "I:H": 0.56,  # High
            
            "A:N": 0.0,   # None
            "A:L": 0.22,  # Low
            "A:H": 0.56,  # High
        }
        
        # Default CVSS vectors for vulnerability types
        self.vulnerability_cvss_defaults = {
            'sql_injection': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'U',
                'C': 'H', 'I': 'H', 'A': 'N'
            },
            'xss_reflected': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'R', 'S': 'C',
                'C': 'L', 'I': 'L', 'A': 'N'
            },
            'xss_stored': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'L', 'I': 'L', 'A': 'N'
            },
            'csrf': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'R', 'S': 'U',
                'C': 'N', 'I': 'L', 'A': 'N'
            },
            'lfi': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'U',
                'C': 'H', 'I': 'N', 'A': 'N'
            },
            'rfi': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'H', 'I': 'H', 'A': 'H'
            },
            'rce': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'H', 'I': 'H', 'A': 'H'
            },
            'authentication_bypass': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'H', 'I': 'H', 'A': 'N'
            },
            'authorization_bypass': {
                'AV': 'N', 'AC': 'L', 'PR': 'L', 'UI': 'N', 'S': 'U',
                'C': 'H', 'I': 'H', 'A': 'N'
            },
            'information_disclosure': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'U',
                'C': 'L', 'I': 'N', 'A': 'N'
            },
            'directory_traversal': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'U',
                'C': 'H', 'I': 'N', 'A': 'N'
            },
            'insecure_deserialization': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'H', 'I': 'H', 'A': 'H'
            },
            'xxe': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'U',
                'C': 'H', 'I': 'L', 'A': 'L'
            },
            'ssrf': {
                'AV': 'N', 'AC': 'L', 'PR': 'N', 'UI': 'N', 'S': 'C',
                'C': 'H', 'I': 'L', 'A': 'L'
            }
        }

    def calculate_base_score(self, severity: str, vulnerability_type: str, 
                           custom_vector: Optional[Dict[str, str]] = None) -> float:
        """
        Calculate CVSS v3.1 base score.
        
        Args:
            severity: Vulnerability severity (for fallback)
            vulnerability_type: Type of vulnerability
            custom_vector: Custom CVSS vector (optional)
            
        Returns:
            float: CVSS base score (0.0-10.0)
        """
        try:
            # Use custom vector if provided, otherwise get default
            if custom_vector:
                vector = custom_vector
            else:
                vector = self.vulnerability_cvss_defaults.get(vulnerability_type)
                
            if not vector:
                # Fallback to severity-based scoring
                return self._severity_to_score(severity)
            
            # Calculate base score using CVSS v3.1 formula
            base_score = self._calculate_cvss_base(vector)
            
            logger.debug(f"Calculated CVSS base score {base_score:.1f} for {vulnerability_type}")
            return round(base_score, 1)
            
        except Exception as e:
            logger.error(f"Error calculating CVSS base score: {e}")
            return self._severity_to_score(severity)

    def calculate_temporal_score(self, base_score: float, exploit_code_maturity: str = "F",
                               remediation_level: str = "O", report_confidence: str = "C") -> float:
        """
        Calculate CVSS v3.1 temporal score.
        
        Args:
            base_score: Base CVSS score
            exploit_code_maturity: E (Unproven), F (Functional), H (High), X (Not Defined)
            remediation_level: O (Official Fix), T (Temporary Fix), W (Workaround), U (Unavailable), X (Not Defined)
            report_confidence: U (Unknown), R (Reasonable), C (Confirmed), X (Not Defined)
            
        Returns:
            float: Temporal score
        """
        temporal_values = {
            # Exploit Code Maturity
            "E:X": 1.0, "E:U": 0.91, "E:P": 0.94, "E:F": 0.97, "E:H": 1.0,
            
            # Remediation Level
            "RL:X": 1.0, "RL:O": 0.95, "RL:T": 0.96, "RL:W": 0.97, "RL:U": 1.0,
            
            # Report Confidence
            "RC:X": 1.0, "RC:U": 0.92, "RC:R": 0.96, "RC:C": 1.0
        }
        
        e_val = temporal_values.get(f"E:{exploit_code_maturity}", 1.0)
        rl_val = temporal_values.get(f"RL:{remediation_level}", 1.0)
        rc_val = temporal_values.get(f"RC:{report_confidence}", 1.0)
        
        temporal_score = base_score * e_val * rl_val * rc_val
        return round(temporal_score, 1)

    def calculate_environmental_score(self, temporal_score: float, 
                                    modified_vector: Optional[Dict[str, str]] = None,
                                    requirements: Optional[Dict[str, str]] = None) -> float:
        """
        Calculate CVSS v3.1 environmental score.
        
        Args:
            temporal_score: Temporal CVSS score
            modified_vector: Modified base metrics
            requirements: Confidentiality/Integrity/Availability requirements
            
        Returns:
            float: Environmental score
        """
        # Simplified environmental calculation
        # In practice, this would use modified base metrics and requirements
        
        if not modified_vector and not requirements:
            return temporal_score
        
        # Apply requirements multipliers if specified
        multiplier = 1.0
        if requirements:
            req_values = {"L": 0.5, "M": 1.0, "H": 1.5}
            cr = req_values.get(requirements.get("CR", "M"), 1.0)
            ir = req_values.get(requirements.get("IR", "M"), 1.0)
            ar = req_values.get(requirements.get("AR", "M"), 1.0)
            multiplier = (cr + ir + ar) / 3.0
        
        environmental_score = temporal_score * multiplier
        return round(min(10.0, environmental_score), 1)

    def get_severity_from_score(self, score: float) -> VulnSeverity:
        """
        Convert CVSS score to severity rating.
        
        Args:
            score: CVSS score (0.0-10.0)
            
        Returns:
            VulnSeverity: Corresponding severity level
        """
        if score == 0.0:
            return VulnSeverity.INFO
        elif 0.1 <= score <= 3.9:
            return VulnSeverity.LOW
        elif 4.0 <= score <= 6.9:
            return VulnSeverity.MEDIUM
        elif 7.0 <= score <= 8.9:
            return VulnSeverity.HIGH
        elif 9.0 <= score <= 10.0:
            return VulnSeverity.CRITICAL
        else:
            return VulnSeverity.LOW

    def create_cvss_vector_string(self, vector: Dict[str, str]) -> str:
        """
        Create CVSS v3.1 vector string from components.
        
        Args:
            vector: Dictionary of CVSS metrics
            
        Returns:
            str: CVSS vector string
        """
        required_metrics = ['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A']
        
        # Validate required metrics
        for metric in required_metrics:
            if metric not in vector:
                raise InvalidVulnerabilityDataException(
                    metric, "missing", "Required CVSS metric missing"
                )
        
        vector_parts = [
            f"AV:{vector['AV']}",
            f"AC:{vector['AC']}",
            f"PR:{vector['PR']}",
            f"UI:{vector['UI']}",
            f"S:{vector['S']}",
            f"C:{vector['C']}",
            f"I:{vector['I']}",
            f"A:{vector['A']}"
        ]
        
        return "CVSS:3.1/" + "/".join(vector_parts)

    def parse_cvss_vector_string(self, vector_string: str) -> Dict[str, str]:
        """
        Parse CVSS vector string into components.
        
        Args:
            vector_string: CVSS vector string
            
        Returns:
            dict: CVSS metrics dictionary
        """
        if not vector_string.startswith("CVSS:3.1/"):
            raise InvalidVulnerabilityDataException(
                "cvss_vector", vector_string, "Invalid CVSS v3.1 vector format"
            )
        
        vector_part = vector_string.replace("CVSS:3.1/", "")
        metrics = {}
        
        for metric_pair in vector_part.split("/"):
            if ":" in metric_pair:
                metric, value = metric_pair.split(":", 1)
                metrics[metric] = value
        
        return metrics

    def validate_cvss_vector(self, vector: Dict[str, str]) -> Tuple[bool, List[str]]:
        """
        Validate CVSS vector components.
        
        Args:
            vector: CVSS metrics dictionary
            
        Returns:
            tuple: (is_valid, list_of_errors)
        """
        errors = []
        
        valid_values = {
            'AV': ['N', 'A', 'L', 'P'],
            'AC': ['L', 'H'],
            'PR': ['N', 'L', 'H'],
            'UI': ['N', 'R'],
            'S': ['U', 'C'],
            'C': ['N', 'L', 'H'],
            'I': ['N', 'L', 'H'],
            'A': ['N', 'L', 'H']
        }
        
        required_metrics = ['AV', 'AC', 'PR', 'UI', 'S', 'C', 'I', 'A']
        
        # Check required metrics
        for metric in required_metrics:
            if metric not in vector:
                errors.append(f"Missing required metric: {metric}")
            elif vector[metric] not in valid_values[metric]:
                errors.append(f"Invalid value for {metric}: {vector[metric]}")
        
        return len(errors) == 0, errors

    def adjust_score_for_context(self, base_score: float, context: Dict[str, Any]) -> float:
        """
        Adjust CVSS score based on environmental context.
        
        Args:
            base_score: Base CVSS score
            context: Environmental context information
            
        Returns:
            float: Adjusted score
        """
        adjusted_score = base_score
        
        # Adjust for authentication requirements
        if context.get('requires_authentication'):
            adjusted_score *= 0.85
        
        # Adjust for network accessibility
        if context.get('internal_only'):
            adjusted_score *= 0.7
        
        # Adjust for exploit availability
        if context.get('public_exploit_available'):
            adjusted_score *= 1.1
        
        # Adjust for affected user count
        user_impact = context.get('affected_users', 'unknown')
        if user_impact == 'single':
            adjusted_score *= 0.8
        elif user_impact == 'all':
            adjusted_score *= 1.2
        
        return round(min(10.0, max(0.0, adjusted_score)), 1)

    def _calculate_cvss_base(self, vector: Dict[str, str]) -> float:
        """
        Calculate CVSS base score using the official formula.
        
        Args:
            vector: CVSS metrics dictionary
            
        Returns:
            float: Base score
        """
        # Get metric values
        av = self.metric_values[f"AV:{vector['AV']}"]
        ac = self.metric_values[f"AC:{vector['AC']}"]
        
        # Privileges Required depends on Scope
        pr_key = f"PR:{vector['PR']}:{vector['S']}"
        pr = self.metric_values[pr_key]
        
        ui = self.metric_values[f"UI:{vector['UI']}"]
        
        c = self.metric_values[f"C:{vector['C']}"]
        i = self.metric_values[f"I:{vector['I']}"]
        a = self.metric_values[f"A:{vector['A']}"]
        
        # Calculate ISC (Impact Sub-score)
        isc_base = 1 - ((1 - c) * (1 - i) * (1 - a))
        
        if vector['S'] == 'U':  # Scope Unchanged
            isc = 6.42 * isc_base
        else:  # Scope Changed
            isc = 7.52 * (isc_base - 0.029) - 3.25 * pow(isc_base - 0.02, 15)
        
        # Calculate ESC (Exploitability Sub-score)
        esc = 8.22 * av * ac * pr * ui
        
        # Calculate Base Score
        if isc <= 0:
            base_score = 0
        else:
            if vector['S'] == 'U':  # Scope Unchanged
                base_score = min(isc + esc, 10)
            else:  # Scope Changed
                base_score = min(1.08 * (isc + esc), 10)
        
        # Round up to nearest 0.1
        return math.ceil(base_score * 10) / 10

    def _severity_to_score(self, severity: str) -> float:
        """
        Convert severity string to approximate CVSS score.
        
        Args:
            severity: Severity level string
            
        Returns:
            float: Approximate CVSS score
        """
        severity_scores = {
            'critical': 9.5,
            'high': 8.0,
            'medium': 5.5,
            'low': 3.0,
            'info': 0.0
        }
        
        return severity_scores.get(severity.lower(), 5.0)

    def generate_detailed_scoring_report(self, vector: Dict[str, str], 
                                       base_score: float) -> Dict[str, Any]:
        """
        Generate detailed CVSS scoring report.
        
        Args:
            vector: CVSS metrics dictionary
            base_score: Calculated base score
            
        Returns:
            dict: Detailed scoring report
        """
        report = {
            'cvss_version': '3.1',
            'vector_string': self.create_cvss_vector_string(vector),
            'base_score': base_score,
            'severity': self.get_severity_from_score(base_score).value,
            'metrics': {
                'attack_vector': self._get_metric_description('AV', vector['AV']),
                'attack_complexity': self._get_metric_description('AC', vector['AC']),
                'privileges_required': self._get_metric_description('PR', vector['PR']),
                'user_interaction': self._get_metric_description('UI', vector['UI']),
                'scope': self._get_metric_description('S', vector['S']),
                'confidentiality': self._get_metric_description('C', vector['C']),
                'integrity': self._get_metric_description('I', vector['I']),
                'availability': self._get_metric_description('A', vector['A'])
            },
            'score_breakdown': {
                'impact_subscore': self._calculate_impact_subscore(vector),
                'exploitability_subscore': self._calculate_exploitability_subscore(vector)
            }
        }
        
        return report

    def _get_metric_description(self, metric: str, value: str) -> Dict[str, str]:
        """Get human-readable description for metric value."""
        descriptions = {
            'AV': {
                'N': {'value': 'Network', 'description': 'Exploitable remotely over network'},
                'A': {'value': 'Adjacent Network', 'description': 'Exploitable over adjacent network'},
                'L': {'value': 'Local', 'description': 'Requires local access'},
                'P': {'value': 'Physical', 'description': 'Requires physical access'}
            },
            'AC': {
                'L': {'value': 'Low', 'description': 'No special conditions required'},
                'H': {'value': 'High', 'description': 'Special conditions required'}
            },
            'PR': {
                'N': {'value': 'None', 'description': 'No privileges required'},
                'L': {'value': 'Low', 'description': 'Low privileges required'},
                'H': {'value': 'High', 'description': 'High privileges required'}
            },
            'UI': {
                'N': {'value': 'None', 'description': 'No user interaction required'},
                'R': {'value': 'Required', 'description': 'User interaction required'}
            },
            'S': {
                'U': {'value': 'Unchanged', 'description': 'Scope is unchanged'},
                'C': {'value': 'Changed', 'description': 'Scope is changed'}
            },
            'C': {
                'N': {'value': 'None', 'description': 'No confidentiality impact'},
                'L': {'value': 'Low', 'description': 'Limited confidentiality impact'},
                'H': {'value': 'High', 'description': 'High confidentiality impact'}
            },
            'I': {
                'N': {'value': 'None', 'description': 'No integrity impact'},
                'L': {'value': 'Low', 'description': 'Limited integrity impact'},
                'H': {'value': 'High', 'description': 'High integrity impact'}
            },
            'A': {
                'N': {'value': 'None', 'description': 'No availability impact'},
                'L': {'value': 'Low', 'description': 'Limited availability impact'},
                'H': {'value': 'High', 'description': 'High availability impact'}
            }
        }
        
        return descriptions.get(metric, {}).get(value, {'value': 'Unknown', 'description': 'Unknown value'})

    def _calculate_impact_subscore(self, vector: Dict[str, str]) -> float:
        """Calculate impact subscore component."""
        c = self.metric_values[f"C:{vector['C']}"]
        i = self.metric_values[f"I:{vector['I']}"]
        a = self.metric_values[f"A:{vector['A']}"]
        
        isc_base = 1 - ((1 - c) * (1 - i) * (1 - a))
        
        if vector['S'] == 'U':
            return round(6.42 * isc_base, 2)
        else:
            return round(7.52 * (isc_base - 0.029) - 3.25 * pow(isc_base - 0.02, 15), 2)

    def _calculate_exploitability_subscore(self, vector: Dict[str, str]) -> float:
        """Calculate exploitability subscore component."""
        av = self.metric_values[f"AV:{vector['AV']}"]
        ac = self.metric_values[f"AC:{vector['AC']}"]
        pr_key = f"PR:{vector['PR']}:{vector['S']}"
        pr = self.metric_values[pr_key]
        ui = self.metric_values[f"UI:{vector['UI']}"]
        
        return round(8.22 * av * ac * pr * ui, 2)