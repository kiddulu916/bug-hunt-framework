"""
Vulnerability Scanner Service for Bug Bounty Automation Platform
Main orchestration service for vulnerability scanning operations
"""

import asyncio
import json
import logging
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass
from enum import Enum

from celery import shared_task
from sqlalchemy import Column, String, Text, DateTime, Boolean, JSON, Integer, Float, Enum as SQLEnum
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Session

from apps.targets.models import Target
from apps.scanning.models import ScanSession, ScanStatus
from apps.reconnaissance.models import ReconResult
from apps.vulnerabilities.models import Vulnerability, VulnSeverity
from core.database import get_db_session, Base
from services.notification_service import NotificationService
from services.callback_server import CallbackService


class ScanProfileType(Enum):
    QUICK = "quick"
    COMPREHENSIVE = "comprehensive"
    STEALTH = "stealth"
    AGGRESSIVE = "aggressive"
    CUSTOM = "custom"


class ScanEngineType(Enum):
    NUCLEI = "nuclei"
    CUSTOM_WEB = "custom_web"
    CUSTOM_API = "custom_api"
    CUSTOM_INFRA = "custom_infra"
    NIKTO = "nikto"
    SQLMAP = "sqlmap"
    GOBUSTER = "gobuster"


class VulnScanStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class ScanProfile:
    """Vulnerability scan profile configuration"""
    name: str
    description: str
    engines: List[ScanEngineType]
    scan_depth: int  # 1-5 scale
    max_scan_time: int  # seconds
    rate_limit: float  # requests per second
    include_intrusive_checks: bool
    custom_parameters: Dict[str, Any]


@dataclass
class VulnerabilityFinding:
    """Individual vulnerability finding"""
    vulnerability_id: str
    name: str
    description: str
    severity: VulnSeverity
    confidence: float  # 0-1
    affected_url: str
    affected_parameter: Optional[str]
    http_method: str
    payload: Optional[str]
    evidence: Dict[str, Any]
    remediation: str
    references: List[str]
    tags: List[str]
    discovered_by: str
    scan_engine: ScanEngineType
    template_id: Optional[str]


class VulnerabilityScans(Base):
    """Database model for vulnerability scans"""
    __tablename__ = "vulnerability_scans"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    scan_session_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    scan_profile = Column(String(50), nullable=False)
    
    # Scan configuration
    engines_used = Column(JSON, default=[])
    scan_parameters = Column(JSON, default={})
    target_urls = Column(JSON, default=[])
    
    # Status and timing
    status = Column(SQLEnum(VulnScanStatus), default=VulnScanStatus.PENDING)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    scan_duration = Column(Float, nullable=True)  # seconds
    
    # Results summary
    total_vulnerabilities = Column(Integer, default=0)
    critical_count = Column(Integer, default=0)
    high_count = Column(Integer, default=0)
    medium_count = Column(Integer, default=0)
    low_count = Column(Integer, default=0)
    info_count = Column(Integer, default=0)
    
    # Performance metrics
    total_requests = Column(Integer, default=0)
    requests_per_second = Column(Float, default=0.0)
    false_positive_rate = Column(Float, default=0.0)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    error_message = Column(Text, nullable=True)
    scan_logs = Column(JSON, default={})


class VulnerabilityScanner:
    """Main vulnerability scanner orchestration service"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.notification_service = NotificationService()
        self.callback_service = CallbackService()
        
        # Load scan engines
        self.engines = {}
        self._load_scan_engines()
        
        # Predefined scan profiles
        self.scan_profiles = self._initialize_scan_profiles()
        
        # Scanning state
        self.active_scans: Dict[str, Dict[str, Any]] = {}
        self.scan_queue: List[Dict[str, Any]] = []
        
    def _load_scan_engines(self):
        """Load and initialize scan engines"""
        try:
            from backend.services.scanner_engines.nuclei_engine import NucleiEngine
            from backend.services.scanner_engines.custom_web_engine import CustomWebEngine
            from backend.services.scanner_engines.custom_api_engine import CustomAPIEngine
            from backend.services.scanner_engines.custom_infra_engine import CustomInfraEngine
            
            self.engines[ScanEngineType.NUCLEI] = NucleiEngine()
            self.engines[ScanEngineType.CUSTOM_WEB] = CustomWebEngine()
            self.engines[ScanEngineType.CUSTOM_API] = CustomAPIEngine()
            self.engines[ScanEngineType.CUSTOM_INFRA] = CustomInfraEngine()
            
            self.logger.info(f"Loaded {len(self.engines)} scan engines")
            
        except ImportError as e:
            self.logger.warning(f"Some scan engines not available: {e}")
    
    def _initialize_scan_profiles(self) -> Dict[str, ScanProfile]:
        """Initialize predefined scan profiles"""
        return {
            "quick": ScanProfile(
                name="Quick Scan",
                description="Fast vulnerability scan for common issues",
                engines=[ScanEngineType.NUCLEI, ScanEngineType.CUSTOM_WEB],
                scan_depth=2,
                max_scan_time=1800,  # 30 minutes
                rate_limit=5.0,
                include_intrusive_checks=False,
                custom_parameters={"nuclei_severity": ["critical", "high"]}
            ),
            
            "comprehensive": ScanProfile(
                name="Comprehensive Scan",
                description="Thorough vulnerability assessment",
                engines=[
                    ScanEngineType.NUCLEI, 
                    ScanEngineType.CUSTOM_WEB,
                    ScanEngineType.CUSTOM_API,
                    ScanEngineType.CUSTOM_INFRA
                ],
                scan_depth=4,
                max_scan_time=7200,  # 2 hours
                rate_limit=2.0,
                include_intrusive_checks=True,
                custom_parameters={}
            ),
            
            "stealth": ScanProfile(
                name="Stealth Scan",
                description="Low-impact scanning to avoid detection",
                engines=[ScanEngineType.NUCLEI, ScanEngineType.CUSTOM_WEB],
                scan_depth=3,
                max_scan_time=3600,  # 1 hour
                rate_limit=0.5,
                include_intrusive_checks=False,
                custom_parameters={"stealth_mode": True, "random_delay": True}
            ),
            
            "aggressive": ScanProfile(
                name="Aggressive Scan",
                description="High-intensity scan with all available checks",
                engines=[
                    ScanEngineType.NUCLEI,
                    ScanEngineType.CUSTOM_WEB,
                    ScanEngineType.CUSTOM_API,
                    ScanEngineType.CUSTOM_INFRA
                ],
                scan_depth=5,
                max_scan_time=14400,  # 4 hours
                rate_limit=10.0,
                include_intrusive_checks=True,
                custom_parameters={"aggressive_mode": True, "deep_crawl": True}
            )
        }
    
    @shared_task
    def start_vulnerability_scan_async(self, scan_session_id: str, scan_profile: str,
                                     custom_config: Dict[str, Any] = None):
        """Celery task for asynchronous vulnerability scanning"""
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(
                self.start_vulnerability_scan(scan_session_id, scan_profile, custom_config)
            )
            return result
        finally:
            loop.close()
    
    async def start_vulnerability_scan(self, scan_session_id: str, scan_profile: str,
                                     custom_config: Dict[str, Any] = None) -> Dict[str, Any]:
        """Start vulnerability scanning for a scan session"""
        
        with get_db_session() as db:
            scan_session = db.query(ScanSession).filter(
                ScanSession.id == scan_session_id
            ).first()
            
            if not scan_session:
                raise ValueError(f"Scan session {scan_session_id} not found")
            
            target = scan_session.target
            if not target.is_active:
                raise ValueError(f"Target {target.target_name} is not active")
            
            # Get scan profile
            profile = self.scan_profiles.get(scan_profile)
            if not profile:
                raise ValueError(f"Unknown scan profile: {scan_profile}")
            
            # Apply custom configuration
            if custom_config:
                profile = self._apply_custom_config(profile, custom_config)
            
            # Create vulnerability scan record
            vuln_scan = VulnerabilityScans(
                scan_session_id=scan_session_id,
                scan_profile=scan_profile,
                engines_used=[engine.value for engine in profile.engines],
                scan_parameters=profile.custom_parameters,
                status=VulnScanStatus.PENDING
            )
            
            db.add(vuln_scan)
            db.commit()
            vuln_scan_id = str(vuln_scan.id)
            
            # Update scan session
            scan_session.current_phase = "vulnerability_testing"
            scan_session.phase_progress = scan_session.phase_progress or {}
            scan_session.phase_progress["vulnerability_testing"] = 0
            db.commit()
            
            # Send start notification
            await self.notification_service.send_scan_notification(scan_session, "started")
            
            try:
                # Get targets for scanning
                scan_targets = await self._get_scan_targets(scan_session_id, db)
                
                if not scan_targets:
                    raise ValueError("No targets found for vulnerability scanning")
                
                vuln_scan.target_urls = [target["url"] for target in scan_targets]
                vuln_scan.status = VulnScanStatus.RUNNING
                vuln_scan.started_at = datetime.utcnow()
                db.commit()
                
                self.logger.info(f"Starting vulnerability scan for {len(scan_targets)} targets")
                
                # Execute vulnerability scanning
                scan_results = await self._execute_vulnerability_scan(
                    vuln_scan_id, scan_targets, profile, target, db
                )
                
                # Process and store results
                processed_results = await self._process_scan_results(
                    scan_results, scan_session_id, vuln_scan_id, db
                )
                
                # Update scan completion
                vuln_scan.status = VulnScanStatus.COMPLETED
                vuln_scan.completed_at = datetime.utcnow()
                vuln_scan.scan_duration = (vuln_scan.completed_at - vuln_scan.started_at).total_seconds()
                
                # Update counts
                vuln_scan.total_vulnerabilities = len(processed_results)
                vuln_scan.critical_count = len([v for v in processed_results if v.severity == VulnSeverity.CRITICAL])
                vuln_scan.high_count = len([v for v in processed_results if v.severity == VulnSeverity.HIGH])
                vuln_scan.medium_count = len([v for v in processed_results if v.severity == VulnSeverity.MEDIUM])
                vuln_scan.low_count = len([v for v in processed_results if v.severity == VulnSeverity.LOW])
                vuln_scan.info_count = len([v for v in processed_results if v.severity == VulnSeverity.INFO])
                
                # Update scan session
                scan_session.total_vulnerabilities = vuln_scan.total_vulnerabilities
                scan_session.critical_vulnerabilities = vuln_scan.critical_count
                scan_session.high_vulnerabilities = vuln_scan.high_count
                scan_session.phase_progress["vulnerability_testing"] = 100
                
                db.commit()
                
                # Send completion notification
                await self.notification_service.send_scan_notification(scan_session, "completed")
                
                # Generate callback payloads for blind vulnerabilities
                await self._generate_callback_payloads_for_blind_vulns(processed_results)
                
                self.logger.info(f"Vulnerability scan completed: {len(processed_results)} vulnerabilities found")
                
                return {
                    "scan_id": vuln_scan_id,
                    "status": "completed",
                    "vulnerabilities_found": len(processed_results),
                    "critical_count": vuln_scan.critical_count,
                    "high_count": vuln_scan.high_count,
                    "scan_duration": vuln_scan.scan_duration
                }
                
            except Exception as e:
                # Handle scan failure
                vuln_scan.status = VulnScanStatus.FAILED
                vuln_scan.error_message = str(e)
                vuln_scan.completed_at = datetime.utcnow()
                scan_session.status = ScanStatus.FAILED
                db.commit()
                
                await self.notification_service.send_scan_notification(scan_session, "failed")
                
                self.logger.error(f"Vulnerability scan failed: {e}")
                raise
    
    async def _get_scan_targets(self, scan_session_id: str, db: Session) -> List[Dict[str, Any]]:
        """Get targets for vulnerability scanning from reconnaissance results"""
        
        # Get all in-scope reconnaissance results
        recon_results = db.query(ReconResult).filter(
            ReconResult.scan_session_id == scan_session_id,
            ReconResult.is_in_scope == True
        ).all()
        
        scan_targets = []
        processed_urls = set()
        
        for result in recon_results:
            if result.result_type in ["subdomain", "endpoint"]:
                # Generate URLs for scanning
                asset = result.discovered_asset
                
                # Handle different asset types
                if result.result_type == "subdomain":
                    urls = [f"http://{asset}", f"https://{asset}"]
                else:  # endpoint
                    urls = [asset] if asset.startswith(('http://', 'https://')) else [f"http://{asset}", f"https://{asset}"]
                
                for url in urls:
                    if url not in processed_urls:
                        processed_urls.add(url)
                        
                        scan_targets.append({
                            "url": url,
                            "asset_type": result.result_type,
                            "discovered_by": result.discovered_by_tool,
                            "confidence": result.confidence_score,
                            "technologies": result.technologies or [],
                            "service_info": {
                                "port": result.port,
                                "service_name": result.service_name,
                                "service_version": result.service_version
                            }
                        })
        
        return scan_targets
    
    async def _execute_vulnerability_scan(self, vuln_scan_id: str, scan_targets: List[Dict[str, Any]],
                                        profile: ScanProfile, target: Target, db: Session) -> List[VulnerabilityFinding]:
        """Execute vulnerability scanning using configured engines"""
        
        all_findings = []
        completed_engines = 0
        total_engines = len(profile.engines)
        
        # Respect target rate limits
        effective_rate_limit = min(profile.rate_limit, target.requests_per_second)
        
        for engine_type in profile.engines:
            try:
                engine = self.engines.get(engine_type)
                if not engine:
                    self.logger.warning(f"Engine {engine_type.value} not available")
                    continue
                
                self.logger.info(f"Running {engine_type.value} engine on {len(scan_targets)} targets")
                
                # Configure engine
                engine_config = {
                    "rate_limit": effective_rate_limit,
                    "timeout": profile.max_scan_time // total_engines,  # Distribute time
                    "scan_depth": profile.scan_depth,
                    "intrusive_checks": profile.include_intrusive_checks,
                    **profile.custom_parameters
                }
                
                # Execute engine scan
                engine_findings = await engine.scan_targets(scan_targets, engine_config)
                
                # Add engine metadata to findings
                for finding in engine_findings:
                    finding.scan_engine = engine_type
                    finding.vulnerability_id = str(uuid.uuid4())
                
                all_findings.extend(engine_findings)
                completed_engines += 1
                
                # Update progress
                progress = (completed_engines / total_engines) * 100
                await self._update_scan_progress(vuln_scan_id, progress, db)
                
                self.logger.info(f"{engine_type.value} completed: {len(engine_findings)} findings")
                
            except Exception as e:
                self.logger.error(f"Engine {engine_type.value} failed: {e}")
                continue
        
        return all_findings
    
    async def _process_scan_results(self, findings: List[VulnerabilityFinding], 
                                   scan_session_id: str, vuln_scan_id: str, 
                                   db: Session) -> List[VulnerabilityFinding]:
        """Process and deduplicate scan results"""
        
        # Import vulnerability analyzer
        from backend.services.vulnerability_analyzer import VulnerabilityAnalyzer
        analyzer = VulnerabilityAnalyzer()
        
        # Deduplicate and correlate findings
        processed_findings = await analyzer.analyze_findings(findings)
        
        # Store vulnerabilities in database
        stored_vulnerabilities = []
        
        for finding in processed_findings:
            try:
                vulnerability = Vulnerability(
                    scan_session_id=scan_session_id,
                    vulnerability_name=finding.name,
                    vulnerability_type=self._normalize_vulnerability_type(finding.name),
                    owasp_category=self._get_owasp_category(finding.name),
                    cwe_id=self._extract_cwe_id(finding.references),
                    severity=finding.severity,
                    cvss_score=self._calculate_cvss_score(finding),
                    impact_description=finding.description,
                    affected_url=finding.affected_url,
                    affected_parameter=finding.affected_parameter,
                    http_method=finding.http_method,
                    payload_used=finding.payload,
                    request_data=finding.evidence.get("request"),
                    response_data=finding.evidence.get("response"),
                    discovered_by_tool=finding.discovered_by,
                    discovery_method=finding.scan_engine.value,
                    confidence_level=finding.confidence,
                    false_positive_likelihood=1.0 - finding.confidence,
                    screenshot_paths=finding.evidence.get("screenshots", []),
                    additional_evidence=finding.evidence,
                    remediation_suggestion=finding.remediation,
                    manually_verified=False
                )
                
                db.add(vulnerability)
                stored_vulnerabilities.append(finding)
                
                # Send notification for critical/high vulnerabilities
                if finding.severity in [VulnSeverity.CRITICAL, VulnSeverity.HIGH]:
                    await self.notification_service.send_vulnerability_notification(vulnerability)
                
            except Exception as e:
                self.logger.error(f"Failed to store vulnerability: {e}")
                continue
        
        db.commit()
        
        return stored_vulnerabilities
    
    async def _generate_callback_payloads_for_blind_vulns(self, findings: List[VulnerabilityFinding]):
        """Generate callback payloads for blind vulnerabilities"""
        
        blind_vuln_types = ["blind_sqli", "blind_xss", "ssrf", "xxe", "blind_rce"]
        
        for finding in findings:
            vuln_type = self._normalize_vulnerability_type(finding.name).lower()
            
            if any(blind_type in vuln_type for blind_type in blind_vuln_types):
                try:
                    # Generate callback payloads for blind vulnerability testing
                    callback_payloads = self.callback_service.generate_callback_payloads(
                        vulnerability_id=finding.vulnerability_id,
                        vuln_type=vuln_type,
                        affected_url=finding.affected_url,
                        parameter=finding.affected_parameter or ""
                    )
                    
                    self.logger.info(f"Generated callback payloads for blind vulnerability: {finding.name}")
                    
                except Exception as e:
                    self.logger.error(f"Failed to generate callback payloads: {e}")
    
    async def _update_scan_progress(self, vuln_scan_id: str, progress: float, db: Session):
        """Update scan progress in database"""
        try:
            vuln_scan = db.query(VulnerabilityScans).filter(
                VulnerabilityScans.id == vuln_scan_id
            ).first()
            
            if vuln_scan:
                # Update scan session progress
                scan_session = db.query(ScanSession).filter(
                    ScanSession.id == vuln_scan.scan_session_id
                ).first()
                
                if scan_session:
                    if not scan_session.phase_progress:
                        scan_session.phase_progress = {}
                    scan_session.phase_progress["vulnerability_testing"] = progress
                    
                db.commit()
                
        except Exception as e:
            self.logger.error(f"Failed to update scan progress: {e}")
    
    def _apply_custom_config(self, profile: ScanProfile, custom_config: Dict[str, Any]) -> ScanProfile:
        """Apply custom configuration to scan profile"""
        # Create a copy of the profile with custom parameters
        custom_profile = ScanProfile(
            name=profile.name,
            description=profile.description,
            engines=custom_config.get("engines", profile.engines),
            scan_depth=custom_config.get("scan_depth", profile.scan_depth),
            max_scan_time=custom_config.get("max_scan_time", profile.max_scan_time),
            rate_limit=custom_config.get("rate_limit", profile.rate_limit),
            include_intrusive_checks=custom_config.get("include_intrusive_checks", profile.include_intrusive_checks),
            custom_parameters={**profile.custom_parameters, **custom_config.get("custom_parameters", {})}
        )
        
        return custom_profile
    
    def _normalize_vulnerability_type(self, vuln_name: str) -> str:
        """Normalize vulnerability name to standard type"""
        vuln_name_lower = vuln_name.lower()
        
        # Mapping of vulnerability names to standard types
        type_mappings = {
            "sql injection": "sql_injection",
            "cross-site scripting": "xss",
            "server-side request forgery": "ssrf",
            "cross-site request forgery": "csrf",
            "xml external entity": "xxe",
            "remote code execution": "rce",
            "command injection": "command_injection",
            "path traversal": "path_traversal",
            "file inclusion": "file_inclusion",
            "insecure direct object reference": "idor",
            "security misconfiguration": "misconfiguration",
            "sensitive data exposure": "data_exposure"
        }
        
        for pattern, vuln_type in type_mappings.items():
            if pattern in vuln_name_lower:
                return vuln_type
        
        # Default fallback
        return vuln_name.lower().replace(" ", "_").replace("-", "_")
    
    def _get_owasp_category(self, vuln_name: str) -> Optional[str]:
        """Map vulnerability to OWASP Top 10 category"""
        vuln_name_lower = vuln_name.lower()
        
        owasp_mappings = {
            "A01": ["injection", "sql", "nosql", "command", "ldap"],
            "A02": ["authentication", "session", "password", "credential"],
            "A03": ["sensitive data", "encryption", "crypto", "data exposure"],
            "A04": ["xxe", "xml external entity"],
            "A05": ["access control", "authorization", "idor", "privilege"],
            "A06": ["security misconfiguration", "default", "config"],
            "A07": ["xss", "cross-site scripting"],
            "A08": ["deserialization", "serialization"],
            "A09": ["vulnerable components", "outdated", "cve"],
            "A10": ["logging", "monitoring", "incident response"]
        }
        
        for category, keywords in owasp_mappings.items():
            if any(keyword in vuln_name_lower for keyword in keywords):
                return category
        
        return None
    
    def _extract_cwe_id(self, references: List[str]) -> Optional[str]:
        """Extract CWE ID from references"""
        import re
        
        for reference in references:
            cwe_match = re.search(r'CWE-(\d+)', reference, re.IGNORECASE)
            if cwe_match:
                return f"CWE-{cwe_match.group(1)}"
        
        return None
    
    def _calculate_cvss_score(self, finding: VulnerabilityFinding) -> Optional[float]:
        """Calculate CVSS score based on vulnerability characteristics"""
        # Simplified CVSS calculation based on severity and characteristics
        base_scores = {
            VulnSeverity.CRITICAL: 9.0,
            VulnSeverity.HIGH: 7.0,
            VulnSeverity.MEDIUM: 5.0,
            VulnSeverity.LOW: 3.0,
            VulnSeverity.INFO: 0.0
        }
        
        base_score = base_scores.get(finding.severity, 5.0)
        
        # Adjust based on confidence
        confidence_modifier = finding.confidence * 2.0  # Max +2.0
        
        # Adjust based on exploitability indicators
        if finding.payload and "exploit" in finding.payload.lower():
            base_score += 1.0
        
        if finding.evidence.get("poc_available"):
            base_score += 0.5
        
        return min(10.0, max(0.0, base_score + confidence_modifier))
    
    async def get_scan_results(self, vuln_scan_id: str) -> Dict[str, Any]:
        """Get vulnerability scan results"""
        with get_db_session() as db:
            vuln_scan = db.query(VulnerabilityScans).filter(
                VulnerabilityScans.id == vuln_scan_id
            ).first()
            
            if not vuln_scan:
                return {}
            
            # Get associated vulnerabilities
            vulnerabilities = db.query(Vulnerability).filter(
                Vulnerability.scan_session_id == vuln_scan.scan_session_id
            ).all()
            
            return {
                "scan_id": str(vuln_scan.id),
                "status": vuln_scan.status.value,
                "profile": vuln_scan.scan_profile,
                "started_at": vuln_scan.started_at.isoformat() if vuln_scan.started_at else None,
                "completed_at": vuln_scan.completed_at.isoformat() if vuln_scan.completed_at else None,
                "duration": vuln_scan.scan_duration,
                "engines_used": vuln_scan.engines_used,
                "targets_scanned": len(vuln_scan.target_urls or []),
                "summary": {
                    "total_vulnerabilities": vuln_scan.total_vulnerabilities,
                    "critical": vuln_scan.critical_count,
                    "high": vuln_scan.high_count,
                    "medium": vuln_scan.medium_count,
                    "low": vuln_scan.low_count,
                    "info": vuln_scan.info_count
                },
                "vulnerabilities": [
                    {
                        "id": str(v.id),
                        "name": v.vulnerability_name,
                        "severity": v.severity.value,
                        "url": v.affected_url,
                        "confidence": v.confidence_level
                    }
                    for v in vulnerabilities
                ]
            }
    
    async def cancel_scan(self, vuln_scan_id: str) -> bool:
        """Cancel a running vulnerability scan"""
        try:
            with get_db_session() as db:
                vuln_scan = db.query(VulnerabilityScans).filter(
                    VulnerabilityScans.id == vuln_scan_id
                ).first()
                
                if not vuln_scan:
                    return False
                
                if vuln_scan.status == VulnScanStatus.RUNNING:
                    vuln_scan.status = VulnScanStatus.CANCELLED
                    vuln_scan.completed_at = datetime.utcnow()
                    db.commit()
                    
                    # Remove from active scans
                    if vuln_scan_id in self.active_scans:
                        del self.active_scans[vuln_scan_id]
                    
                    return True
                
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to cancel scan: {e}")
            return False
    
    def get_available_profiles(self) -> Dict[str, Dict[str, Any]]:
        """Get available scan profiles"""
        return {
            name: {
                "name": profile.name,
                "description": profile.description,
                "engines": [engine.value for engine in profile.engines],
                "scan_depth": profile.scan_depth,
                "max_scan_time": profile.max_scan_time,
                "rate_limit": profile.rate_limit,
                "intrusive": profile.include_intrusive_checks
            }
            for name, profile in self.scan_profiles.items()
        }


# Shared scanner service instance
vulnerability_scanner = VulnerabilityScanner
