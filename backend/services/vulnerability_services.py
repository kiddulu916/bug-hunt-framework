"""
Support services for vulnerability management
"""

import asyncio
import hashlib
import json
import csv
import io
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from pathlib import Path
import re
import aiofiles
from uuid import UUID

# For PDF generation
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch


class VulnerabilityAnalyzer:
    """
    Advanced vulnerability analysis and enrichment service
    """
    
    def __init__(self):
        self.vulnerability_db = self._load_vulnerability_database()
        self.remediation_db = self._load_remediation_database()
    
    async def analyze_vulnerability(self, vulnerability) -> Dict[str, Any]:
        """
        Perform deep analysis on vulnerability
        """
        analysis = {
            "risk_score": self._calculate_risk_score(vulnerability),
            "attack_vector_analysis": self._analyze_attack_vector(vulnerability),
            "potential_impact": self._assess_potential_impact(vulnerability),
            "exploitation_likelihood": self._calculate_exploitation_likelihood(vulnerability),
            "related_vulnerabilities": await self._find_related_vulnerabilities(vulnerability),
            "attack_chain_potential": self._analyze_attack_chain_potential(vulnerability),
            "business_impact": self._assess_business_impact(vulnerability),
            "compliance_impact": self._check_compliance_impact(vulnerability)
        }
        
        return analysis
    
    def _calculate_risk_score(self, vulnerability) -> float:
        """Calculate comprehensive risk score"""
        base_score = vulnerability.cvss_score or 0.0
        
        # Adjust based on exploitability
        if vulnerability.is_exploitable:
            base_score *= 1.3
        
        # Adjust based on verification
        if vulnerability.manually_verified:
            base_score *= 1.1
        
        # Adjust based on false positive likelihood
        base_score *= (1 - vulnerability.false_positive_likelihood)
        
        return min(10.0, base_score)
    
    def _analyze_attack_vector(self, vulnerability) -> Dict[str, Any]:
        """Analyze the attack vector"""
        vector_analysis = {
            "vector_type": "unknown",
            "requires_authentication": False,
            "requires_user_interaction": False,
            "remote_exploitable": True
        }
        
        # Parse CVSS vector if available
        if hasattr(vulnerability, 'cvss_vector') and vulnerability.cvss_vector:
            vector_parts = vulnerability.cvss_vector.split('/')
            for part in vector_parts:
                if 'AV:' in part:
                    if 'N' in part:
                        vector_analysis["vector_type"] = "network"
                    elif 'A' in part:
                        vector_analysis["vector_type"] = "adjacent"
                    elif 'L' in part:
                        vector_analysis["vector_type"] = "local"
                        vector_analysis["remote_exploitable"] = False
                elif 'AC:' in part:
                    vector_analysis["complexity"] = "high" if 'H' in part else "low"
                elif 'PR:' in part:
                    vector_analysis["requires_authentication"] = 'N' not in part
                elif 'UI:' in part:
                    vector_analysis["requires_user_interaction"] = 'R' in part
        
        return vector_analysis
    
    def _assess_potential_impact(self, vulnerability) -> Dict[str, Any]:
        """Assess the potential impact of exploitation"""
        impact = {
            "confidentiality": "none",
            "integrity": "none",
            "availability": "none",
            "data_exposure_risk": False,
            "system_compromise_risk": False,
            "service_disruption_risk": False
        }
        
        # Check vulnerability type for impact assessment
        vuln_type = vulnerability.vulnerability_type.lower()
        
        if 'sqli' in vuln_type or 'sql injection' in vuln_type:
            impact["confidentiality"] = "high"
            impact["integrity"] = "high"
            impact["data_exposure_risk"] = True
        elif 'rce' in vuln_type or 'remote code' in vuln_type:
            impact["confidentiality"] = "high"
            impact["integrity"] = "high"
            impact["availability"] = "high"
            impact["system_compromise_risk"] = True
        elif 'xss' in vuln_type:
            impact["confidentiality"] = "medium"
            impact["integrity"] = "medium"
        elif 'dos' in vuln_type or 'denial' in vuln_type:
            impact["availability"] = "high"
            impact["service_disruption_risk"] = True
        elif 'ssrf' in vuln_type:
            impact["confidentiality"] = "high"
            impact["system_compromise_risk"] = True
        
        return impact
    
    def _calculate_exploitation_likelihood(self, vulnerability) -> str:
        """Calculate likelihood of exploitation"""
        score = 0
        
        # Check if already exploitable
        if vulnerability.is_exploitable:
            score += 40
        
        # Check vulnerability type
        high_risk_types = ['sqli', 'rce', 'xxe', 'ssti', 'path traversal']
        if any(risk_type in vulnerability.vulnerability_type.lower() for risk_type in high_risk_types):
            score += 30
        
        # Check if public exploit exists (would need external API check)
        # For now, simulate based on CVE/CWE
        if vulnerability.cwe_id:
            score += 20
        
        # Check confidence level
        score += int(vulnerability.confidence_level * 10)
        
        if score >= 70:
            return "high"
        elif score >= 40:
            return "medium"
        else:
            return "low"
    
    async def _find_related_vulnerabilities(self, vulnerability) -> List[Dict[str, Any]]:
        """Find related vulnerabilities in the same context"""
        # This would query the database for similar vulnerabilities
        # For now, return empty list
        return []
    
    def _analyze_attack_chain_potential(self, vulnerability) -> Dict[str, Any]:
        """Analyze potential for chaining with other attacks"""
        chain_potential = {
            "can_escalate_privileges": False,
            "can_bypass_authentication": False,
            "can_enable_data_exfiltration": False,
            "can_establish_persistence": False,
            "chain_complexity": "single",
            "suggested_chains": []
        }
        
        vuln_type = vulnerability.vulnerability_type.lower()
        
        if 'authentication' in vuln_type or 'auth bypass' in vuln_type:
            chain_potential["can_bypass_authentication"] = True
            chain_potential["chain_complexity"] = "medium"
        
        if 'privilege' in vuln_type or 'lpe' in vuln_type:
            chain_potential["can_escalate_privileges"] = True
            chain_potential["chain_complexity"] = "medium"
        
        if 'sqli' in vuln_type or 'xxe' in vuln_type:
            chain_potential["can_enable_data_exfiltration"] = True
        
        if 'rce' in vuln_type or 'file upload' in vuln_type:
            chain_potential["can_establish_persistence"] = True
            chain_potential["chain_complexity"] = "high"
        
        return chain_potential
    
    def _assess_business_impact(self, vulnerability) -> Dict[str, Any]:
        """Assess business impact of the vulnerability"""
        return {
            "financial_impact": self._estimate_financial_impact(vulnerability),
            "reputation_impact": self._estimate_reputation_impact(vulnerability),
            "operational_impact": self._estimate_operational_impact(vulnerability),
            "compliance_risk": self._estimate_compliance_risk(vulnerability)
        }
    
    def _estimate_financial_impact(self, vulnerability) -> str:
        """Estimate financial impact"""
        if vulnerability.severity in ['CRITICAL', 'HIGH']:
            if 'data' in vulnerability.vulnerability_type.lower():
                return "high"
            return "medium"
        return "low"
    
    def _estimate_reputation_impact(self, vulnerability) -> str:
        """Estimate reputation impact"""
        if vulnerability.severity in ['CRITICAL', 'HIGH']:
            if any(term in vulnerability.vulnerability_type.lower() 
                   for term in ['xss', 'sqli', 'rce', 'data']):
                return "high"
        return "low"
    
    def _estimate_operational_impact(self, vulnerability) -> str:
        """Estimate operational impact"""
        if 'dos' in vulnerability.vulnerability_type.lower():
            return "high"
        if vulnerability.severity == 'CRITICAL':
            return "medium"
        return "low"
    
    def _estimate_compliance_risk(self, vulnerability) -> str:
        """Estimate compliance risk"""
        if 'data' in vulnerability.vulnerability_type.lower() or 'pii' in vulnerability.impact_description.lower():
            return "high"
        return "low"
    
    def _check_compliance_impact(self, vulnerability) -> Dict[str, bool]:
        """Check impact on various compliance standards"""
        compliance = {
            "pci_dss": False,
            "gdpr": False,
            "hipaa": False,
            "sox": False
        }
        
        # Check for PCI DSS relevance
        if any(term in vulnerability.vulnerability_type.lower() 
               for term in ['payment', 'card', 'transaction']):
            compliance["pci_dss"] = True
        
        # Check for GDPR relevance
        if any(term in vulnerability.impact_description.lower() 
               for term in ['personal', 'privacy', 'data', 'pii']):
            compliance["gdpr"] = True
        
        # Check for HIPAA relevance
        if any(term in vulnerability.impact_description.lower() 
               for term in ['health', 'medical', 'patient']):
            compliance["hipaa"] = True
        
        return compliance
    
    async def generate_remediation_suggestions(
        self, 
        vulnerability_type: str,
        cwe_id: Optional[str],
        technology_stack: List[str],
        severity: str
    ) -> List[Dict[str, Any]]:
        """Generate AI-powered remediation suggestions"""
        suggestions = []
        
        # Get base remediation from database
        base_remediation = self._get_base_remediation(vulnerability_type, cwe_id)
        
        # Customize for technology stack
        for tech in technology_stack:
            tech_specific = self._get_technology_specific_remediation(
                vulnerability_type, 
                tech
            )
            if tech_specific:
                suggestions.append(tech_specific)
        
        # Add priority based on severity
        priority = "urgent" if severity in ["CRITICAL", "HIGH"] else "normal"
        
        # Structure suggestions
        for suggestion in base_remediation:
            suggestions.append({
                "title": suggestion["title"],
                "description": suggestion["description"],
                "implementation_steps": suggestion.get("steps", []),
                "estimated_effort": suggestion.get("effort", "medium"),
                "priority": priority,
                "code_examples": suggestion.get("code_examples", []),
                "testing_approach": suggestion.get("testing", ""),
                "references": suggestion.get("references", [])
            })
        
        return suggestions
    
    def estimate_remediation_effort(self, vulnerability_type: str, severity: str) -> str:
        """Estimate effort required for remediation"""
        effort_matrix = {
            "sqli": "high",
            "xss": "medium",
            "csrf": "low",
            "rce": "high",
            "xxe": "medium",
            "ssrf": "medium",
            "path traversal": "medium",
            "authentication": "high",
            "authorization": "high"
        }
        
        base_effort = effort_matrix.get(vulnerability_type.lower(), "medium")
        
        # Adjust based on severity
        if severity in ["CRITICAL", "HIGH"] and base_effort == "low":
            return "medium"
        
        return base_effort
    
    def get_remediation_references(self, vulnerability_type: str, cwe_id: Optional[str]) -> List[Dict[str, str]]:
        """Get remediation references and resources"""
        references = [
            {
                "title": "OWASP Prevention Cheat Sheet",
                "url": f"https://cheatsheetseries.owasp.org/cheatsheets/{vulnerability_type}_Prevention_Cheat_Sheet.html"
            }
        ]
        
        if cwe_id:
            references.append({
                "title": f"CWE-{cwe_id} Details",
                "url": f"https://cwe.mitre.org/data/definitions/{cwe_id.replace('CWE-', '')}.html"
            })
        
        return references
    
    def _load_vulnerability_database(self) -> Dict:
        """Load vulnerability knowledge base"""
        # This would load from actual database or file
        return {}
    
    def _load_remediation_database(self) -> Dict:
        """Load remediation knowledge base"""
        # This would load from actual database or file
        return {}
    
    def _get_base_remediation(self, vulnerability_type: str, cwe_id: Optional[str]) -> List[Dict]:
        """Get base remediation suggestions"""
        # Simplified remediation database
        remediations = {
            "sqli": [
                {
                    "title": "Use Parameterized Queries",
                    "description": "Replace dynamic SQL with parameterized queries or prepared statements",
                    "steps": [
                        "Identify all database queries in the application",
                        "Replace string concatenation with parameterized queries",
                        "Use ORM frameworks properly",
                        "Validate and sanitize all inputs"
                    ],
                    "effort": "high",
                    "code_examples": [
                        "# Python example\ncursor.execute('SELECT * FROM users WHERE id = ?', (user_id,))"
                    ]
                }
            ],
            "xss": [
                {
                    "title": "Output Encoding and Input Validation",
                    "description": "Encode all user-controlled data before rendering",
                    "steps": [
                        "Implement context-aware output encoding",
                        "Use Content Security Policy (CSP)",
                        "Validate and sanitize inputs",
                        "Use secure frameworks with built-in XSS protection"
                    ],
                    "effort": "medium"
                }
            ]
        }
        
        return remediations.get(vulnerability_type.lower(), [])
    
    def _get_technology_specific_remediation(self, vulnerability_type: str, technology: str) -> Optional[Dict]:
        """Get technology-specific remediation"""
        # This would have technology-specific recommendations
        return None


class CVSSCalculator:
    """
    CVSS score calculation service
    """
    
    def calculate(self, cvss_vector: str) -> float:
        """
        Calculate CVSS score from vector string
        """
        if not cvss_vector or not cvss_vector.startswith('CVSS:'):
            return 0.0
        
        # Parse CVSS v3 vector
        metrics = self._parse_vector(cvss_vector)
        
        # Calculate base score
        base_score = self._calculate_base_score(metrics)
        
        return round(base_score, 1)
    
    def _parse_vector(self, vector: str) -> Dict[str, str]:
        """Parse CVSS vector string into metrics"""
        metrics = {}
        parts = vector.split('/')
        
        for part in parts[1:]:  # Skip CVSS:3.x part
            if ':' in part:
                key, value = part.split(':')
                metrics[key] = value
        
        return metrics
    
    def _calculate_base_score(self, metrics: Dict[str, str]) -> float:
        """Calculate CVSS base score"""
        # Simplified CVSS calculation
        # In production, implement full CVSS v3.1 calculation
        
        score = 0.0
        
        # Attack Vector
        av_scores = {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2}
        score += av_scores.get(metrics.get('AV', 'N'), 0.85)
        
        # Attack Complexity
        ac_scores = {'L': 0.77, 'H': 0.44}
        score += ac_scores.get(metrics.get('AC', 'L'), 0.77)
        
        # Privileges Required
        pr_scores = {'N': 0.85, 'L': 0.62, 'H': 0.27}
        score += pr_scores.get(metrics.get('PR', 'N'), 0.85)
        
        # User Interaction
        ui_scores = {'N': 0.85, 'R': 0.62}
        score += ui_scores.get(metrics.get('UI', 'N'), 0.85)
        
        # Impact metrics
        impact_score = 0.0
        for impact_metric in ['C', 'I', 'A']:
            impact_values = {'H': 0.56, 'L': 0.22, 'N': 0}
            impact_score += impact_values.get(metrics.get(impact_metric, 'N'), 0)
        
        # Simplified calculation
        if impact_score == 0:
            return 0.0
        
        base_score = min(10, (score + impact_score) * 2)
        
        return base_score


class EvidenceHandler:
    """
    Handle evidence files for vulnerabilities
    """
    
    def __init__(self, base_path: str = "/app/evidence"):
        self.base_path = Path(base_path)
        self.allowed_extensions = {
            'screenshot': ['.png', '.jpg', '.jpeg', '.gif', '.bmp'],
            'request': ['.txt', '.json', '.xml', '.har'],
            'video': ['.mp4', '.avi', '.mov', '.webm'],
            'document': ['.pdf', '.docx', '.txt', '.md']
        }
    
    def validate_file_type(self, filename: str, evidence_type: str) -> bool:
        """Validate file type for evidence"""
        file_ext = Path(filename).suffix.lower()
        allowed = self.allowed_extensions.get(evidence_type, [])
        return file_ext in allowed
    
    async def save_evidence(
        self, 
        file, 
        vulnerability_id: UUID,
        evidence_type: str
    ) -> str:
        """Save evidence file and return path"""
        # Create directory structure
        evidence_dir = self.base_path / str(vulnerability_id) / evidence_type
        evidence_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate unique filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        file_hash = hashlib.md5(file.filename.encode()).hexdigest()[:8]
        filename = f"{timestamp}_{file_hash}_{file.filename}"
        file_path = evidence_dir / filename
        
        # Save file
        async with aiofiles.open(file_path, 'wb') as f:
            content = await file.read()
            await f.write(content)
        
        # Return relative path
        return str(file_path.relative_to(self.base_path))
    
    async def get_evidence(self, evidence_path: str) -> bytes:
        """Retrieve evidence file"""
        full_path = self.base_path / evidence_path
        
        if not full_path.exists():
            raise FileNotFoundError(f"Evidence file not found: {evidence_path}")
        
        async with aiofiles.open(full_path, 'rb') as f:
            return await f.read()
    
    async def delete_evidence(self, evidence_path: str) -> bool:
        """Delete evidence file"""
        full_path = self.base_path / evidence_path
        
        if full_path.exists():
            full_path.unlink()
            return True
        
        return False


class NotificationService:
    """
    Handle notifications for vulnerability discoveries
    """
    
    def __init__(self):
        self.notification_channels = []
        self.severity_thresholds = {
            'email': ['CRITICAL', 'HIGH'],
            'slack': ['CRITICAL', 'HIGH', 'MEDIUM'],
            'webhook': ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
        }
    
    async def send_high_severity_alert(self, vulnerability, target):
        """Send alert for high severity vulnerability"""
        message = self._format_alert_message(vulnerability, target)
        
        # Send to all configured channels
        tasks = []
        if vulnerability.severity.value in self.severity_thresholds.get('email', []):
            tasks.append(self._send_email_alert(message))
        
        if vulnerability.severity.value in self.severity_thresholds.get('slack', []):
            tasks.append(self._send_slack_alert(message))
        
        if vulnerability.severity.value in self.severity_thresholds.get('webhook', []):
            tasks.append(self._send_webhook_alert(message))
        
        if tasks:
            await asyncio.gather(*tasks)
    
    def _format_alert_message(self, vulnerability, target) -> Dict[str, Any]:
        """Format alert message"""
        return {
            'title': f"🚨 {vulnerability.severity.value} Severity Vulnerability Discovered",
            'target': target.target_name,
            'vulnerability': vulnerability.vulnerability_name,
            'type': vulnerability.vulnerability_type,
            'url': vulnerability.affected_url,
            'severity': vulnerability.severity.value,
            'cvss_score': vulnerability.cvss_score,
            'discovered_at': vulnerability.discovered_at.isoformat(),
            'description': vulnerability.impact_description[:500]
        }
    
    async def _send_email_alert(self, message: Dict[str, Any]):
        """Send email notification"""
        # Implement email sending logic
        pass
    
    async def _send_slack_alert(self, message: Dict[str, Any]):
        """Send Slack notification"""
        # Implement Slack webhook integration
        pass
    
    async def _send_webhook_alert(self, message: Dict[str, Any]):
        """Send generic webhook notification"""
        # Implement webhook sending logic
        pass


class ReportingService:
    """
    Generate various report formats for vulnerabilities
    """
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
    
    def _setup_custom_styles(self):
        """Setup custom styles for PDF reports"""
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1a1a1a'),
            spaceAfter=30,
            alignment=1  # Center
        ))
        
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            textColor=colors.HexColor('#2c3e50'),
            spaceAfter=12,
            spaceBefore=12
        ))
    
    def generate_csv_report(self, vulnerabilities: List) -> io.StringIO:
        """Generate CSV report"""
        output = io.StringIO()
        
        fieldnames = [
            'ID', 'Vulnerability Name', 'Type', 'Severity', 'CVSS Score',
            'Affected URL', 'Parameter', 'OWASP Category', 'CWE ID',
            'Verified', 'Exploitable', 'Discovered By', 'Discovered At',
            'Impact Description', 'Remediation Suggestion'
        ]
        
        writer = csv.DictWriter(output, fieldnames=fieldnames)
        writer.writeheader()
        
        for vuln in vulnerabilities:
            writer.writerow({
                'ID': str(vuln.id),
                'Vulnerability Name': vuln.vulnerability_name,
                'Type': vuln.vulnerability_type,
                'Severity': vuln.severity.value if hasattr(vuln.severity, 'value') else vuln.severity,
                'CVSS Score': vuln.cvss_score or 'N/A',
                'Affected URL': vuln.affected_url,
                'Parameter': vuln.affected_parameter or 'N/A',
                'OWASP Category': vuln.owasp_category or 'N/A',
                'CWE ID': vuln.cwe_id or 'N/A',
                'Verified': 'Yes' if vuln.manually_verified else 'No',
                'Exploitable': 'Yes' if vuln.is_exploitable else 'No',
                'Discovered By': vuln.discovered_by_tool,
                'Discovered At': vuln.discovered_at.strftime('%Y-%m-%d %H:%M:%S'),
                'Impact Description': vuln.impact_description,
                'Remediation Suggestion': vuln.remediation_suggestion or 'N/A'
            })
        
        output.seek(0)
        return output
    
    def generate_json_report(self, vulnerabilities: List) -> Dict[str, Any]:
        """Generate JSON report"""
        report = {
            'generated_at': datetime.now().isoformat(),
            'total_vulnerabilities': len(vulnerabilities),
            'severity_summary': self._calculate_severity_summary(vulnerabilities),
            'vulnerabilities': []
        }
        
        for vuln in vulnerabilities:
            vuln_dict = {
                'id': str(vuln.id),
                'vulnerability_name': vuln.vulnerability_name,
                'vulnerability_type': vuln.vulnerability_type,
                'severity': vuln.severity.value if hasattr(vuln.severity, 'value') else vuln.severity,
                'cvss_score': vuln.cvss_score,
                'affected_url': vuln.affected_url,
                'affected_parameter': vuln.affected_parameter,
                'http_method': vuln.http_method,
                'owasp_category': vuln.owasp_category,
                'cwe_id': vuln.cwe_id,
                'impact_description': vuln.impact_description,
                'discovered_by_tool': vuln.discovered_by_tool,
                'discovery_method': vuln.discovery_method,
                'confidence_level': vuln.confidence_level,
                'manually_verified': vuln.manually_verified,
                'is_exploitable': vuln.is_exploitable,
                'exploitation_difficulty': vuln.exploitation_difficulty,
                'remediation_suggestion': vuln.remediation_suggestion,
                'discovered_at': vuln.discovered_at.isoformat(),
                'evidence': {
                    'screenshots': vuln.screenshot_paths or [],
                    'additional': vuln.additional_evidence or {}
                }
            }
            
            # Add scan session and target info if available
            if hasattr(vuln, 'scan_session') and vuln.scan_session:
                vuln_dict['scan_session'] = {
                    'id': str(vuln.scan_session.id),
                    'name': vuln.scan_session.session_name
                }
                
                if hasattr(vuln.scan_session, 'target') and vuln.scan_session.target:
                    vuln_dict['target'] = {
                        'id': str(vuln.scan_session.target.id),
                        'name': vuln.scan_session.target.target_name,
                        'platform': vuln.scan_session.target.platform.value
                    }
            
            report['vulnerabilities'].append(vuln_dict)
        
        return report
    
    async def generate_pdf_report(self, vulnerabilities: List) -> io.BytesIO:
        """Generate PDF report"""
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(
            buffer,
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18,
        )
        
        # Container for the 'Flowable' objects
        elements = []
        
        # Title
        title = Paragraph("Vulnerability Assessment Report", self.styles['CustomTitle'])
        elements.append(title)
        elements.append(Spacer(1, 12))
        
        # Report metadata
        metadata = f"""
        <para>
        <b>Report Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br/>
        <b>Total Vulnerabilities:</b> {len(vulnerabilities)}<br/>
        </para>
        """
        elements.append(Paragraph(metadata, self.styles['Normal']))
        elements.append(Spacer(1, 20))
        
        # Executive Summary
        elements.append(Paragraph("Executive Summary", self.styles['SectionHeader']))
        
        severity_summary = self._calculate_severity_summary(vulnerabilities)
        summary_text = f"""
        <para>
        This report contains {len(vulnerabilities)} identified vulnerabilities across the tested application.
        The severity distribution is as follows:<br/><br/>
        • Critical: {severity_summary.get('critical', 0)}<br/>
        • High: {severity_summary.get('high', 0)}<br/>
        • Medium: {severity_summary.get('medium', 0)}<br/>
        • Low: {severity_summary.get('low', 0)}<br/>
        • Informational: {severity_summary.get('info', 0)}<br/>
        </para>
        """
        elements.append(Paragraph(summary_text, self.styles['Normal']))
        elements.append(PageBreak())
        
        # Vulnerability Details
        elements.append(Paragraph("Vulnerability Details", self.styles['SectionHeader']))
        elements.append(Spacer(1, 12))
        
        # Create vulnerability table
        for i, vuln in enumerate(vulnerabilities, 1):
            # Vulnerability header
            vuln_header = f"<b>{i}. {vuln.vulnerability_name}</b>"
            elements.append(Paragraph(vuln_header, self.styles['Heading3']))
            
            # Vulnerability details table
            vuln_data = [
                ['Severity:', vuln.severity.value if hasattr(vuln.severity, 'value') else vuln.severity],
                ['Type:', vuln.vulnerability_type],
                ['CVSS Score:', str(vuln.cvss_score) if vuln.cvss_score else 'N/A'],
                ['Affected URL:', self._truncate_url(vuln.affected_url)],
                ['Parameter:', vuln.affected_parameter or 'N/A'],
                ['OWASP Category:', vuln.owasp_category or 'N/A'],
                ['CWE ID:', vuln.cwe_id or 'N/A'],
                ['Verified:', 'Yes' if vuln.manually_verified else 'No'],
                ['Exploitable:', 'Yes' if vuln.is_exploitable else 'No'],
            ]
            
            table = Table(vuln_data, colWidths=[2*inch, 4*inch])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.grey),
                ('TEXTCOLOR', (0, 0), (0, -1), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            elements.append(table)
            elements.append(Spacer(1, 12))
            
            # Impact Description
            elements.append(Paragraph("<b>Impact:</b>", self.styles['Normal']))
            elements.append(Paragraph(vuln.impact_description, self.styles['Normal']))
            elements.append(Spacer(1, 12))
            
            # Remediation
            if vuln.remediation_suggestion:
                elements.append(Paragraph("<b>Remediation:</b>", self.styles['Normal']))
                elements.append(Paragraph(vuln.remediation_suggestion, self.styles['Normal']))
                elements.append(Spacer(1, 12))
            
            # Add page break after each vulnerability except the last
            if i < len(vulnerabilities):
                elements.append(PageBreak())
        
        # Build PDF
        doc.build(elements)
        buffer.seek(0)
        return buffer
    
    def _calculate_severity_summary(self, vulnerabilities: List) -> Dict[str, int]:
        """Calculate severity distribution"""
        summary = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        for vuln in vulnerabilities:
            severity = vuln.severity.value if hasattr(vuln.severity, 'value') else vuln.severity
            severity_lower = severity.lower()
            if severity_lower in summary:
                summary[severity_lower] += 1
        
        return summary
    
    def _truncate_url(self, url: str, max_length: int = 60) -> str:
        """Truncate long URLs for display"""
        if len(url) <= max_length:
            return url
        return url[:max_length-3] + '...'